<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>ROP &amp; JOP</title>
    <url>/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.1%20ROP&amp;JOP/</url>
    <content><![CDATA[<h1 id="rop-jop">ROP &amp; JOP</h1>
<h2 id="x86-架构复习">x86 架构复习</h2>
<h3 id="寄存器">1、寄存器</h3>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\图片1-16768586729361.png" alt="图片1" style="zoom:80%;" /></p>
<ul>
<li><p>寄存器：</p>
<ul>
<li><p>ABCD：Accumulator 累加器，Base 基地址，Counter 计数器，Data
数据</p></li>
<li><p>SI，DI：Src，Dst</p>
<p>其中 <code>memcpy(des, src)</code> 函数的两个地址参数就专门存储在
DI，SI</p></li>
</ul>
<p>在 <span class="math inline">\(8086\)</span> 时代，Intel
对以上寄存器根据其各自功能进行相应的优化，直到今天也还存在</p>
<p>x86 的 <span class="math inline">\(8\)</span>
通用寄存器：EA/B/C/DX，ESI，EDI，ESP，EBP</p></li>
<li><p>x86 的进化（x<span class="math inline">\(86\)</span>-<span
class="math inline">\(64\)</span>）：</p>
<ul>
<li>更长的寄存器长度</li>
<li>更多的寄存器数量（<span class="math inline">\(16\)</span>
个通用寄存器，RA/B/C/DX，RSI，RDI，RSP，RDP，R<span
class="math inline">\(8\)</span>-<span
class="math inline">\(15\)</span>）</li>
</ul></li>
<li><p><strong>问题：</strong></p>
<p>逻辑寄存器越多越好吗？</p>
<ul>
<li><p>对于汇编指令而言，寄存器越多会导致编码越来越长，而 x86
在兼容性上的要求也使得汇编指令不易于扩展</p></li>
<li><p>寄存器增多，CPU 的任务切换开销会加大</p></li>
<li><p>现代 CPU 的物理寄存器堆有成百上千个寄存器，CPU
使用寄存器重命名的方法将相同逻辑寄存器映射到不同的物理寄存器上，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add 1, %eax</span><br><span class="line">...</span><br><span class="line">add 2, %eax</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>中的两条指令在不冲突的条件下可以并行执行</p></li>
</ul>
<p>逻辑寄存器越长越好吗？</p>
<ul>
<li><p>同样是并行计算的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 1, %rax</span><br><span class="line">...</span><br><span class="line">mov 2, %eax</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在该例中，这两条指令是显然无法并行计算的，因为机器不知道程序员使用
<code>mov 2, %eax</code> 指令是否为了得到
<code>(%rax) &amp; 0x00000000 | (%eax)</code>
的值，因此若程序中存在使用到 <code>%rax</code> 的指令时，后面所有的
<code>%eax</code> 都无法执行并行计算。为了解决这个问题，Intel
加入一个规范：对通用寄存器的低 <span class="math inline">\(32\)</span>
位进行操作会导致其高 <span class="math inline">\(32\)</span>
位清零</p></li>
</ul></li>
</ul>
<h3 id="函数调用">2、函数调用</h3>
<ul>
<li><p>寄存器与数据传递</p>
<ul>
<li>参数传递：RDI，RSI，RDX，RCX，R<span
class="math inline">\(8\)</span>，R<span
class="math inline">\(9\)</span>，按顺序使用</li>
<li>返回参数：RAX，多余的保存在栈中</li>
</ul></li>
<li><p>Volatile(Caller-save) Registers</p>
<p>RAX，RCX，RDX，RDI，RSI，RSP，R<span
class="math inline">\(8\)</span>-<span
class="math inline">\(11\)</span></p>
<p>被调用者可以随意写这些寄存器而不需要去保存它们的值，如果需要保存，则由调用者自行保存</p></li>
<li><p>Non-volatile(Callee-save) Registers</p>
<p>RBX，RBP，R<span class="math inline">\(12\)</span>-<span
class="math inline">\(15\)</span></p>
<p>被调用者如果要使用这些寄存器则需要先保存其中的值</p></li>
</ul>
<p>CPU 不关心哪些是 volatile 的或 non-volaitle
的，这些是编译器的工作</p>
<h2 id="buffer-overflow">Buffer Overflow</h2>
<h3 id="normal-program-behavior">Normal program behavior</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">int</span> i = function();</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221010093724511.png" alt="image-20221010093724511" style="zoom: 67%;" /></p>
<p>==注：其中，<code>xor</code> 指令常常被用于将寄存器清零==</p>
<h3 id="buffer-overflow-1">Buffer Overflow</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">silly_function</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">char</span>* src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, src, len); <span class="comment">// &lt;-function(%rdi, %rsi, %rdx)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> silly_function(<span class="number">50</span>, <span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可得到如下汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># silly_function:</span><br><span class="line">    sub    $0x64, %rsp # &lt;- stack layout from this time</span><br><span class="line">    movq   %rdi, %rdx</span><br><span class="line">    movq   %rsp, %rdi</span><br><span class="line">    callq  &lt;memcpy&gt;</span><br><span class="line">    xor    %rax,%rax</span><br><span class="line">    add    $0x64, %rsp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>
<p>以及如下栈布局：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221010094615625.png" alt="image-20221010094615625" style="zoom:67%;" /></p>
<p>对于 C 函数 <code>memcpy</code> 而言，其不会检查复制是否溢出，即对于
<code>buffer[100]</code> 而言，即使 <code>memcpy</code> 中的长度参数为
<span class="math inline">\(101\)</span> 个字节，它也会照常复制</p>
<p>当 <code>silly_function</code> 执行到 <code>retq</code> 指令时：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221010095156900.png" alt="image-20221010095156900" style="zoom:80%;" /></p>
<p><code>%rsp</code> 指向栈中的返回地址，在 <code>retq</code>
指令被执行的时刻，CPU
取出返回地址送入指令寄存器，跳转到返回地址所在内存继续执行剩下的指令，而注意到
<code>buffer[100]</code> 的内存位置就紧挨着返回地址的内存位置，因此当
<code>main</code> 函数中存在如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> silly_function(<span class="number">108</span>, <span class="string">&quot;Hello…ABCDEFGH&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>时，就会出现以下情况：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221010095513873.png" alt="image-20221010095513873" style="zoom:80%;" /></p>
<p>这样会导致 <code>silly_function</code> 在执行到 <code>retq</code>
指令时跳转到地址 <code>0x4847464544434241</code>（即 <code>AB...H</code>
的 ASCII 码值，而 x86
为小端模式）去执行，通常这种随机的跳转值会指向一个未被使用的段或页，此时将出现段错误（segmentation
fault）</p>
<p>但对于攻击者而言，该 bug 可以令攻击者能够</p>
<ul>
<li>跳转到其任意想跳转到的位置去执行某些指令</li>
<li>写任意指令到栈上</li>
</ul>
<p>而以上两点使得攻击者能够完全劫持程序的控制流，因此存在安全风险</p>
<h2 id="ropreturn-oriented-programming">ROP（Return Oriented
Programming）</h2>
<h3 id="defend-buffer-overflow">Defend Buffer Overflow</h3>
<h4 id="check">1. Check</h4>
<p>设有如下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># a[i] = 0; 对a[i]赋值为0</span><br><span class="line">add %ecx, %eax;  //given eax saves the address of a, ecx saves i.</span><br><span class="line">mov 0, (%eax);</span><br></pre></td></tr></table></figure>
<p>则可以增加以下边界检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># a[i] = 0;</span><br><span class="line">add %ecx, %eax;</span><br><span class="line">cmp %eax, %ebi;    // given ebi saves the bound of a[].</span><br><span class="line">jg exception;      // jump if greater</span><br><span class="line">mov 0, (%eax);</span><br></pre></td></tr></table></figure>
<p>该边界检查对数组的右边界进行了检查（但未对左边界进行检查）</p>
<p>边界检查可以解决一部分 Buffer Overflow 的问题，但边界检查需要使用到
<code>jump</code> 指令，而 <code>jump</code> 指令对于流水线 CPU
而言相较其它指令的开销较大，频繁不正确地使用 <code>jump</code>
指令会导致程序效率变低</p>
<h4 id="随机初始化程序地址">2. 随机初始化程序地址</h4>
<p>令程序在每次装载到内存中的地址都不同，可以保证攻击者无法跳转到其预先写好的某个包含一系列攻击代码的代码段去执行</p>
<h4 id="canary-guards">3. Canary Guards</h4>
<p>Canary Guards 即在返回地址（return
address）的低位存储一个随机数，称之为 canary，在执行返回指令（ret
instruction）时先对 canary 进行检查，若 canary
数值不变，则说明返回地址未被覆盖；若改变，则此时程序会调用
<code>__stack_chk_fail</code> 函数，而该函数将会终结该进程</p>
<h4 id="硬件保护">4. 硬件保护</h4>
<p>现代 CPU
支持分段分页的形式，而在段表或页表中存在专门的标志位用于标识该段/页是否可读、可写、可执行，一般而言</p>
<ul>
<li>代码段：可读可执行不可写</li>
<li>数据段（包括堆栈）：可读可写不可执行</li>
</ul>
<p>硬件保护阻止了攻击者在栈上写指令后执行的行为</p>
<h3 id="bypass-those-defenses">Bypass those Defenses</h3>
<h4 id="泄露栈中的-canary">1. 泄露栈中的 Canary</h4>
<p>如代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">silly_function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x300</span>uLL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, buf);</span><br><span class="line">    write(...);</span><br><span class="line">    read(<span class="number">0</span>, v5, <span class="number">0x300</span>uLL);</span><br><span class="line">    <span class="built_in">printf</span>(...);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到代码中存在两个 <code>read</code> 函数，此时可以使用第一个
<code>read</code> 将 canary 的低字节 <code>\x00</code> 覆盖（canary
的低字节恒为 <code>\x00</code>，这也是为了截断字符串的输出）后利用
<code>printf</code> 将 canary 打印出来，接着就可以利用第二个
<code>read</code> 绕过 canary 将返回地址覆盖</p>
<h4 id="跳转到未被随机化的且可执行的代码段">2.
跳转到未被随机化的且可执行的代码段</h4>
<p>对于程序而言，其装载的地址是随机的，但在其虚拟地址空间中，存在固定留给操作系统的空间，而该空间是不被随机化的。在该地址空间中存在大量各种指令
+ <code>ret</code> 的指令组合，可以跳转到这些指令发起攻击</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221010120259820.png" alt="image-20221010120259820" style="zoom:80%;" /></p>
<p>此时当 ESP 指向 G<span class="math inline">\(1\)</span>
地址时，原函数执行 <code>ret</code> 指令，因此</p>
<ul>
<li>EIP 跳转到 G<span class="math inline">\(1\)</span> 处执行，使得
<code>%eax = 5</code>，然后返回指令取出 G<span
class="math inline">\(2\)</span> 地址送入 EIP</li>
<li>EIP 跳转到 G<span class="math inline">\(2\)</span> 处执行，使得
<code>%ebx = 0x804800</code>，然后返回指令取出 G<span
class="math inline">\(3\)</span> 地址送入 EIP</li>
<li>EIP 跳转到 G<span class="math inline">\(3\)</span> 处执行，令
<code>(0x804800) = 5</code>，完成一次任意写。然后返回指令取出之后的地址，依此类推</li>
</ul>
<p>其中，G<span class="math inline">\(1-3\)</span>
都是从系统空间中的代码段找出的各种小片段（gadget）</p>
<p>可以看出通过该方式可以执行任何指令。只要满足：</p>
<ul>
<li><p>一次 buffer overflow 完成栈的覆盖（覆盖栈数据）</p></li>
<li><p>系统固定代码段中存在所需指令 + <code>ret</code>
指令的结构，这种结构被称为 gadget（截取控制流）</p></li>
</ul>
<p>这种攻击方式即称为 ROP（Return Oriented
Programming），并且<strong>这种攻击方式是图灵完备的</strong>，也就是说它能够模拟任何代码、完成任何能用代码实现的功能</p>
<p>==可以利用程序将各种指令 + <code>ret</code> 指令的结构寻找出来==</p>
<h3 id="rop-variant-jop">ROP Variant: JOP</h3>
<p>同理 ROP，JOP（Jump Oriented Programming）实质上是寻找所需指令 +
<code>jmp (%reg)</code> 结构的攻击方式，对于 x<span
class="math inline">\(86\)</span>，其 <code>jmp</code>
指令本质上可以划分为四种寻址方式：</p>
<ul>
<li>直接寻址</li>
<li>间接寻址</li>
<li>绝对寻址</li>
<li>相对寻址</li>
</ul>
<p>其中 JOP 使用的即为间接绝对寻址（在 x<span
class="math inline">\(86\)</span> 中只称为间接寻址），而在 x<span
class="math inline">\(86\)</span> 架构中，会使用间接寻址的操作只有
<code>call &lt;func&gt;</code>，因此 JOP 也被称为 COP（Call Oriented
Programming）</p>
<p>相较于 ROP，<code>jmp</code> 指令在代码中出现的频率要比
<code>ret</code> 指令高得多，因此寻找到所需 gadget 的可能性更大</p>
<h3 id="jop-defense">JOP Defense</h3>
<ul>
<li>Assumes that ROP gadgets are called across functions.</li>
<li>But normal jumps do not.</li>
<li>Push a different canary for every function.</li>
<li>Check canary when indirectly jumping.</li>
</ul>
<p>对于 <code>jmp</code> 指令而言，其是不会跳出函数的（在跳转指令中只有
<code>call</code> 是能够跳出函数）</p>
<p>因此可以对每个函数区域增加一个 canary，每次 <code>jmp</code>
指令执行结束就检查当前函数的 canary 是否与跳转前相同</p>
<ul>
<li>Pros
<ul>
<li>Very fine grained</li>
</ul></li>
<li>Cons
<ul>
<li>Jump overhead</li>
<li>Different .text segment every time the binary is loaded.</li>
</ul></li>
</ul>
<h2 id="mitigations">Mitigations</h2>
<h4 id="pic-和-pie">1. PIC 和 PIE</h4>
<p>所有库代码全部采取动态链接的方式，此时库的加载位置就是随机的，但同时也会导致代码执行效率变低，并且攻击者只要能够打印库的某段代码地址即可得知整个库所在地址，因此力度不足</p>
<h4 id="硬件保护-1">2. 硬件保护</h4>
<ul>
<li><p>Stack Shadow（SS）</p>
<p>即为每个栈存储一个影子栈，影子栈专门存取返回地址且只能由
<code>ret</code> 指令和 <code>call</code> 指令修改，每次执行
<code>ret</code>
指令前比对影子栈和普通栈中的返回地址，相同则返回否则终结程序</p></li>
<li><p>Indirect Branch Tracking（IBT）</p>
<p>IBT
的设计原理是通过编译器在合理的间接跳转（<code>call/jmp</code>）中⽤新的指令做标记，新指令包含
<code>endbr32</code> 和
<code>endbr64</code>。其要求执行间接跳转指令后跳转到的第一条指令必须是
<code>endbr</code>
指令。而在一个程序中，直接跳转只能跳转到固定的位置，那么该行为一定是在编程中就考虑到的，因此不会有问题；而间接跳转非常灵活，很容易可以跳转到程序不应该跳转的位置，而
IBT 就是为了解决间接跳转的问题</p></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Code Analysis Basics</title>
    <url>/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.10%20Code%20Analysis%20Basics/</url>
    <content><![CDATA[<h1 id="code-analysis-basics">Code Analysis Basics</h1>
<h2 id="code-analysis">Code Analysis</h2>
<p>Code Analysis 可以用于：</p>
<ul>
<li><p>Dissecting app to understand</p>
<ul>
<li><p>Does it do what it should not do?</p>
<p>如 Apple Store 的代码检查</p></li>
<li><p>How it works?</p></li>
<li><p>Does it have bugs?</p></li>
</ul></li>
<li><p>A critical part of software security</p>
<ul>
<li><p>Automatic software testing before release</p>
<p>中小公司通常跑测试样例，大公司则有自己的一套 Code Analysis
程序</p></li>
<li><p>Malware detection</p>
<p>早年杀毒软件对病毒的检测采用特征值比对的方式，但躲避该方式只需攻击者将病毒程序进行压缩加密后其特征值就会发生改变（密码不同显然特征值也会不同）</p></li>
<li><p>App Censorship</p>
<p>应用审查</p></li>
<li><p>Reverse Engineer</p></li>
</ul></li>
</ul>
<h3 id="dynamic-vs.-static">Dynamic vs. Static</h3>
<ul>
<li><p>Static Analysis</p>
<ul>
<li><p>Examines apps without running it</p>
<p>分析器本质上一个以文本为输入输出结果的程序。其中，输入为代码；输出为代码是否符合规则</p></li>
<li><p>Tools: Soot, FlowDroid, BAP</p>
<p>Soot 是一个 Java 优化框架，它能够用来分析、检测、优化及可视化 Java 和
Android 应用程序</p></li>
</ul></li>
<li><p>Dynamic Analysis</p>
<p>动态检测方式本质上是捕获进程的各种状态来进行检测的</p>
<ul>
<li><p>Run the app and monitor its effect</p></li>
<li><p>Usually use a virtual machine and take snapshots</p></li>
<li><p>Tools: TaintDroid, Ptrace, KLEE</p>
<p>以及 Android 的 xposed 框架，除了其它功能以外，其还能监控 Android
系统的各种 Syscall API</p></li>
</ul></li>
<li><p>Hybrid</p>
<ul>
<li>Combine static and dynamic techniques, like BitBlaze</li>
</ul></li>
</ul>
<h2 id="static-analysis">Static Analysis</h2>
<ul>
<li><p>Input:</p>
<ul>
<li>Machine Code, Assembly Code, Intermediate Code, Source Code</li>
</ul></li>
<li><p>Convert input to graph</p>
<ul>
<li><p>Call Graph, Control Flow Graph, Data Flow Graph, Dependency
Graph, Syntax Tree, etc.</p>
<p>其中 Call Graph，即函数关系图：其作用在于对于某些重点关注的
API（如可能泄露隐私或可能危害系统的系统调用）的函数调用关系进行跟踪，如存在以下调用图：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">D(str) -&gt; A -&gt; C(send(str))</span><br></pre></td></tr></table></figure>
<p>那么此时即可重点跟踪 <code>str</code> 变量，防止 <code>str</code>
是某些隐私数据</p></li>
</ul></li>
<li><p>Compute over the graph</p>
<ul>
<li>Search Algorithm: DFS, BFS…</li>
</ul></li>
<li><p>Output:</p>
<ul>
<li>If certain pattern appears</li>
<li>To achieve analysis goals</li>
</ul></li>
</ul>
<h3 id="static-analysis-pre-process">Static Analysis Pre-process</h3>
<p>若无法直接获得被测试程序的源代码，则需要对测试程序进行预处理</p>
<ul>
<li><p>Disassemble</p>
<p>反汇编</p>
<ul>
<li>Convert binary to assembly</li>
<li>Two algorithms: Recursive Descent, Linear Sweep</li>
</ul>
<p>值得注意的是，反汇编器得到的结果不一定时正确的，如：</p>
<ul>
<li><p>当反汇编器解释的起点与程序的起点不同时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line">jmp rax</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>
<p>此时对于 <code>jmp</code>
指令之后的数据，反汇编器有两种选择：继续解释为指令，或是不继续解释。但无论如何由于
<code>rax</code> 的值未知，反汇编器将无法继续跟踪这条执行流</p></li>
<li><p>```asm jmp imm -&gt; another imm <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    此时 `jmp` 指令将会跳转到一个立即数的数据上，但该立即数可能本身就可以被解释为一条指令，因此反汇编器将会解释错误，这也是抗逆向的手段之一（这条 `jmp` 指令可能在程序运行过程中永远不会被执行，但却可以用来误导反汇编器）</span><br><span class="line"></span><br><span class="line">  对于不同平台的汇编指令，其中 x$86$ 由于为变长指令集，反汇编的难度更大；而对于 Java 的 Bytecode 而言，虽然其也为变长指令，但 Java Bytecode 中本身就包含了丰富的信息，因此 Java 的 Bytecode 反而要更容易被反汇编</span><br><span class="line"></span><br><span class="line">- Lifting</span><br><span class="line"></span><br><span class="line">  反汇编→转换为中间语言</span><br><span class="line"></span><br><span class="line">  - Convert assembly to intermediate representation (IR)</span><br><span class="line"></span><br><span class="line">    中间语言的意义在于跨平台，屏蔽架构区别。如对于寄存器其屏蔽的方式为假设有无穷多个寄存器</span><br><span class="line"></span><br><span class="line">  - In convenience for cross-platform analysis</span><br><span class="line"></span><br><span class="line">  - May introduce error</span><br><span class="line"></span><br><span class="line">- Decompile</span><br><span class="line"></span><br><span class="line">  反编译</span><br><span class="line"></span><br><span class="line">  - Convert assembly or IR to source code</span><br><span class="line"></span><br><span class="line">  - Many introduce error </span><br><span class="line"></span><br><span class="line">    可能会引入很多错误</span><br><span class="line"></span><br><span class="line">### Disassemble</span><br><span class="line"></span><br><span class="line">在反汇编的同时可以生成控制流图（Control Flow Graph，CFG），其生成方式很简单，图中每个代码块称为基本块：</span><br><span class="line"></span><br><span class="line">对起点设置为基本块的开始，当遇到 Label 时说明程序可能跳转到此处执行，因此将 Label 前一条指令作为当前遍历基本块的结束，而 Label 对应指令作为下一个基本块的开始。此时就得到了 CFG</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221205234419097.png&quot; alt=&quot;image-20221205234419097&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">当然，CFG 仍然无法解决 `goto reg` 的问题，静态分析的各种方法都难以解决一个不确定的跳转产生的问题</span><br><span class="line"></span><br><span class="line">### Lifting</span><br><span class="line"></span><br><span class="line">- Analyze IR simplifies multiple platform analysis.</span><br><span class="line">- Assembly to IR may not be 1 to 1 mapping, so there may be error.</span><br><span class="line"></span><br><span class="line">中间语言的出现最初是由于编译器实现的重复性。假设存在 $n$ 种语言，$m$ 种平台架构，那么每种语言需要在每种架构上都实现对应的编译器，此时就需要实现 $n×m$ 个编译器</span><br><span class="line"></span><br><span class="line">然而若实现一种中间语言（语言无关，架构无关），要求将所有语言先编译为中间语言，再编译为汇编语言，那么此时只需要实现 $n+m$ 个编译器即可，大大减少了工作量</span><br><span class="line"></span><br><span class="line">采用中间语言时，静态分析器就只需要写一种代码即可，此即为 LLVM 技术</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221205233809448.png&quot; alt=&quot;image-20221205233809448&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">### Decompile</span><br><span class="line"></span><br><span class="line">- Infer source code from assembly or IR</span><br><span class="line"></span><br><span class="line">- Only moderate correctness</span><br><span class="line">  - Multiple variables may be combined, as they belong to the same reg.</span><br><span class="line">  - Data structure is unknown, so there may be not-understood pointer calculations..</span><br><span class="line">  - Many other errors.</span><br><span class="line"></span><br><span class="line">- May help manual analysis</span><br><span class="line"></span><br><span class="line">Decompiler 是针对 Compiler 的编译行为逆向出来的，其正确性较低，并且可读性也并不强</span><br><span class="line"></span><br><span class="line">如对于一个结构体：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct stc&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int *b;</span><br><span class="line">&#125; N;</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<p>那么此时反汇编出来的调用变量 <code>b</code> 的代码一定会是类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov reg + 4, ...</span><br></pre></td></tr></table></figure>
<p>的情况，我们无法得知这个 <code>reg + 4</code> 的具体含义</p>
<h3 id="live-variable">Live Variable</h3>
<ul>
<li>Is the value of a variable needed?
<ul>
<li>Some developers may define a variable but not use it.</li>
<li>Use before Initialization</li>
</ul></li>
<li>At each instruction, each variable in the program is either live or
dead.</li>
</ul>
<p>存活变量的分析可以帮助编译器进行优化，如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Program 1</span></span><br><span class="line"><span class="keyword">int</span> x = y * z;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> x; <span class="comment">// x = y * z alive</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Program 2</span></span><br><span class="line"><span class="keyword">int</span> x = y * z;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">x = a + b; <span class="comment">// x = y * z dead</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure>
<p>其中，当一个变量被赋值语句所赋值之后，显然后面的操作都将与前面无关了</p>
<p><strong>Liveness Detection Algorithm</strong></p>
<p>LVA is a backwards data-flow analysis</p>
<p>Information from future instructions must be propagated backwards
through the program to discover which variables are live.</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\图片1-16769686631271.png" alt="图片1" style="zoom: 60%;" /><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\图片2-16769686706973.png" alt="图片2" style="zoom: 60%;" /></p>
<p>LVA 算法的思路为：</p>
<ul>
<li>从代码尾端开始，设集合 <span class="math inline">\(L\)</span>
为存活变量</li>
<li>在遇到使用到的变量时将其加入 <span
class="math inline">\(L\)</span>，说明从该行代码开始，其存活</li>
<li>在遇到赋值/定义的变量时将其从 <span class="math inline">\(L\)</span>
中删除（若存在），说明从该行代码开始，其死亡</li>
</ul>
<p>形式化定义为： <span class="math display">\[
\quad in\text{-}live(n)=\left(out\text{-}live(n)\setminus
def(n)\right)\cup\text{}ref{(n)}
\]</span> 若遇到分支，则有： <span class="math display">\[
out-live(n)=\bigcup_{s∈succ(n)}in-live(s)
\]</span>
<img src="D:\All Documents\Markdown\MD杂项\MD.IMG\图片1-16769694112951.png" alt="图片1" style="zoom: 67%;" /></p>
<h2 id="taint-analysis">Taint Analysis</h2>
<ul>
<li><p>Make clear how sensitive information flows from source to
sink</p></li>
<li><p>E.g.: when an app reads a photo.</p>
<p>如当一个应用读取了一张照片，这张照片很可能就是敏感数据（隐私），那么这个应用之后的行为就决定了这个应用是否有害</p>
<ul>
<li><p>Does the app store the photo?</p>
<p>存储照片？</p></li>
<li><p>Does the app send the photo to server?</p>
<p>发送到应用的服务器？</p></li>
<li><p>Or just display it.</p>
<p>或者只是在屏幕上展示</p></li>
</ul></li>
<li><p>Step<span class="math inline">\(1\)</span>: mark sensitive
information source tainted.</p>
<p>把敏感信息标记为 tainted</p>
<ul>
<li>e.g.: the return of recv(sockfd), fread(fd)…</li>
</ul></li>
<li><p>Step<span class="math inline">\(2\)</span>: propagate the taint
according to data flow graph.</p>
<p>传播标记</p>
<ul>
<li>```c y = a * x <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - If x is tainted, y should be tainted as well</span><br><span class="line"></span><br><span class="line">- Step$3$: until known sink point (dangerous) found. </span><br><span class="line"></span><br><span class="line">  sink 节点：可能泄露数据的 API</span><br><span class="line"></span><br><span class="line">  - e.g.: send(y)，网络发包</span><br><span class="line"></span><br><span class="line">### How to propagate?</span><br><span class="line"></span><br><span class="line">- Dynamic vs. Static</span><br><span class="line">  - Dynamic has less false positive, but more false negative.</span><br><span class="line"></span><br><span class="line">- Dynamic:</span><br><span class="line"></span><br><span class="line">  - Label address of taint source in memory </span><br><span class="line"></span><br><span class="line">    被标记的单位是内存地址</span><br><span class="line"></span><br><span class="line">  - Run the target program and instrument assignment instructions</span><br><span class="line"></span><br><span class="line">  - When sink is touched, we know leakage potentially happen</span><br><span class="line"></span><br><span class="line">  - Tainted variables may be cleared during execution, when def-ed with clear variable</span><br><span class="line"></span><br><span class="line">- Static:</span><br><span class="line"></span><br><span class="line">  - Rely on static analysis to know the dependency graph to taint </span><br><span class="line"></span><br><span class="line">    被标记的单位是变量</span><br><span class="line"></span><br><span class="line">### Taint Example</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">int main() &#123; </span><br><span class="line">      char dest[512], </span><br><span class="line">      char *src, *tmp; </span><br><span class="line">      src = read_data(); </span><br><span class="line">      tmp = src; </span><br><span class="line">      process_data(dest, tmp); </span><br><span class="line">      strcpy(dest, &quot;processing OK&quot;) ; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">char *read_data() &#123; </span><br><span class="line">       char *buf; </span><br><span class="line">       ReadFile(buf);    // Sensitive Source</span><br><span class="line">       return buf; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void process_data(char *b1, char *b2) &#123; </span><br><span class="line">       strcpy(b1, b2) ; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p>其标记流程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf -&gt; src -&gt; tmp -&gt; b2 -&gt; b1 -&gt; dest</span><br></pre></td></tr></table></figure>
<p>直到当 <code>dest</code> 重新被覆盖之后才结束 taint</p>
<h3 id="taint-analysis-frameworks">Taint analysis frameworks</h3>
<ul>
<li><p>Dynamic Taint: Taintdroid</p></li>
<li><p>Static Taint: Flowdroid</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221206082653924.png" alt="image-20221206082653924" style="zoom:80%;" /></p>
<p>注意在该例中还需要往前找，这是由于内存区域可以由多个指针指向或一个对象可以有多个引用所导致的</p></li>
</ul>
<h3 id="limitations">Limitations</h3>
<ul>
<li><p>Over-taint:</p>
<ul>
<li>when a stack variable is tainted, should the whole stack be
tainted?</li>
<li>when the assignment relationship is weak, should the propagation go
on?</li>
</ul>
<p>如果 <code>x</code> 被 tainted 那么<code>y</code> 是否要
tainted？</p>
<ul>
<li>tainted→overtainted</li>
<li>not tainted→tainted escape（此时将可以一位一位复制）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span></span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y = <span class="number">0</span>; </span><br></pre></td></tr></table></figure></li>
<li><p>Taint Escape</p>
<ul>
<li>Some apps try to exploit the trace loss resulted from avoiding
over-taint</li>
<li>To hide sensitive information delivery</li>
<li>E.g., repeat the loop and right shift <code>x</code> every
time.</li>
</ul></li>
</ul>
<h2 id="dynamic-analysis">Dynamic Analysis</h2>
<p>动态分析需要</p>
<ul>
<li>程序运行</li>
<li>数据输入，而数据输入如果由人工来产生可能会造成大量人力物力的浪费</li>
</ul>
<h3 id="symbolic-execution">Symbolic Execution</h3>
<ul>
<li><p>If we know execution of an instruction may trigger a bug.</p>
<p>假设已知某段代码有可能产生 bug 或存在安全隐患</p>
<ul>
<li><p>What input will trigger the bug?</p>
<p>但我们并不知道哪些输入可能引发 bug 或危险</p></li>
<li><p>Or, the bug will never be triggered?</p>
<p>或者这个 bug 永远也不可能被触发</p></li>
</ul>
<p>Symbolic Execution 就是用来判断程序中的 bug
是否会被触发以及在哪些情况下会被触发</p></li>
<li><p>You may regard input variables as symbols</p>
<p>因此我们可以使用类似数学的方法——假设输入为一个未知量，采用符号来替代，最终根据条件解出方程即可</p>
<ul>
<li>Construct formula of input symbols</li>
<li>Solve the formula to have a root (possible input)</li>
</ul></li>
</ul>
<p>如下例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Void <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z = <span class="number">2</span> * y;</span><br><span class="line">    <span class="keyword">if</span>(z == x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y + <span class="number">10</span>)</span><br><span class="line">         <span class="comment">// ERROR</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = sym_input();</span><br><span class="line">    <span class="keyword">int</span> y = sym_input();</span><br><span class="line">    func(x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时可以得到如下 CFG：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221205231100420.png" alt="image-20221205231100420" style="zoom:80%;" /></p>
<p>最终在可能遇到 bug
的分支处根据条件尝试解方程，若方程有解，则说明该程序能够触发 bug</p>
<p>然而 Symbolic Execution
的缺点在于：当程序中存在循环时会导致无限分支，导致以当前算力不可解。在现实条件下，通常会给循环设一个上限以保证问题可解</p>
<h3 id="fuzz">Fuzz</h3>
<ul>
<li><p>Automatically generate test cases</p>
<ul>
<li>A challenge of traditional testing is how to generate complete test
case set.</li>
<li>Fuzz test apps without needing to manually construct test
cases.</li>
</ul></li>
<li><p>With Fuzz, test cases are randomly generated and fed to apps
automatically.</p></li>
<li><p>Application is monitored for errors</p></li>
<li><p>E.g. Android monkey</p></li>
</ul>
<p>除了 Symbolic Execution
以外，还有一种方式可以解决输入问题：即随机输入</p>
<p>可以编写自动测试程序对被测试程序进行随机生成 samples
来测试，包括文本输入、界面响应等</p>
]]></content>
  </entry>
  <entry>
    <title>Heap Overflow</title>
    <url>/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.2%20Heap%20Overflow/</url>
    <content><![CDATA[<h1 id="heap-overflow">Heap Overflow</h1>
<p><strong>Stack Overflow vs. Heap Overflow</strong></p>
<p>栈溢出：攻击者通过覆盖栈内存的方式取得对计算机的控制</p>
<p>决定程序控制流的指令：</p>
<ul>
<li><code>ret</code> 指令：ROP（Return-oriented Programming）</li>
<li><code>jmp</code> 指令：JOP（Jump-oriented Programming）</li>
</ul>
<p>实际上，堆内存也可以截取控制流</p>
<blockquote>
<p>Why is stack memory size so limited?</p>
<ul>
<li>对于一个程序而言，其所有线程共享一个堆，但同时每个线程都有属于自己的栈，如果栈内存设置过大则程序的线程数将会受到限制</li>
<li>防止糟糕的程序员写出错误的递归（无限递归），小容量的栈可以提前爆栈防止程序永远地运行下去</li>
</ul>
</blockquote>
<h2 id="intro.">Intro.</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *user = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">8</span>);</span><br><span class="line">     <span class="keyword">char</span> *adminuser = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">strcpy</span>(adminuser, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">          <span class="built_in">strcpy</span>(user, argv[<span class="number">1</span>]);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">strcpy</span>(user, <span class="string">&quot;guest&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;User is at %p, contains: %s\n&quot;</span>, user, user);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Admin user is at %p, contains: %s\n&quot;</span>, adminuser, adminuser);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到这个程序使用的strcpy并没有对字符串拷贝的长度进行限制</span></span><br><span class="line"><span class="comment">// 因此，很可能会拷贝超过8个字节长度的字符串造成溢出，并不安全</span></span><br></pre></td></tr></table></figure>
<p>观察输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./<span class="built_in">log</span></span><br><span class="line">User is at 0x560e911ea2a0, contains: guest</span><br><span class="line">Admin user is at 0x560e911ea2c0, contains: root</span><br><span class="line"></span><br><span class="line">./<span class="built_in">log</span></span><br><span class="line">User is at 0x55cc15e362a0, contains: guest</span><br><span class="line">Admin user is at 0x55cc15e362c0, contains: root</span><br><span class="line"></span><br><span class="line">./<span class="built_in">log</span></span><br><span class="line">User is at 0x55d0a401c2a0, contains: guest</span><br><span class="line">Admin user is at 0x55d0a401c2c0, contains: root</span><br></pre></td></tr></table></figure>
<p>假如程序只是通过用户名所存变量来判定权限，如何取得权限？</p>
<ul>
<li><p><code>adminuser</code> 所存的地址更高</p>
<p>堆是从下往上增长的，因此通过向低地址写入可以达到覆盖高地址的目的</p></li>
<li><p>堆内存的地址分配是随机的</p>
<p>无法通过指定地址来达到写入 <code>adminuser</code> 的目的</p></li>
<li><p><code>user</code> 地址与 <code>adminuser</code> 地址间隔不变</p>
<p>通过 <code>user</code> 的写入溢出可以覆盖到 <code>adminuser</code>
地址</p></li>
</ul>
<p>因此，</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./<span class="built_in">log</span> frank123456789012345678901234567david</span><br><span class="line">User is at 0x56542855a2a0, contains: frank123456789012345678901234567david</span><br><span class="line">Admin user is at 0x56542855a2c0, contains: david</span><br></pre></td></tr></table></figure>
<p>此时 david 就变成了管理员用户了，该程序并不安全</p>
<p><strong>为什么两个变量地址是相对固定的？</strong></p>
<p>对于堆内存的分配，一般分以下几个步骤：</p>
<p>当 free list
中存在大小大于请求分配空间的空闲块时即分配给发出请求的变量，否则执行另外两个操作：</p>
<ul>
<li><code>malloc</code> 调用 <code>brk</code> 函数，<code>brk</code>
的实现方式是将 Data Segment 的最高地址指针 <code>_edata</code>
往高地址推（分配的内存小于 <span
class="math inline">\(128\text{k}\)</span>，即 <code>MAP_POPULATE</code>
常量，通常设定为 <span class="math inline">\(\text{128k}\)</span>）</li>
<li><code>malloc</code> 调用 <code>mmap</code> 函数，<code>mmap</code>
的实现方式是在 Memory Mapping Segment
找一块空闲的虚拟内存（分配的内存大于 <span
class="math inline">\(\text{}128\text{k}\)</span>）</li>
</ul>
<p>接下来回答这个问题：此时因为 <code>user</code> 和
<code>adminuser</code> 使用 <code>malloc</code>
申请堆内存时，堆内存还是空的状态，而两个变量申请的内存又小于
<code>MAP_POPULATE</code> 的值，因此使用 <code>brk</code>
函数分配，而其又是连续分配的，故地址是相对固定的</p>
<p><strong>假如在此之前已经存在 <code>malloc, free</code>
操作呢？</strong></p>
<p>显然一般不会是相对固定的，即使程序每次 <code>malloc</code> 和
<code>free</code>
的操作完全相同，但因为程序可能是多线程的，而每个线程共享一个堆内存，此时程序代码的执行顺序（<code>malloc</code>
和 <code>free</code> 的顺序不同）很大可能会影响 <code>user</code> 和
<code>adminuser</code> 地址的相对位置</p>
<h2 id="堆攻击">堆攻击</h2>
<h3 id="heap-overflow-1">Heap Overflow</h3>
<p>注意到堆的每一块，无论是在被使用的还是空闲的，其块的前一段都会存储该段的某些信息（长度等），如下图：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20220926230621934.png" alt="image-20220926230621934" style="zoom:80%;" /></p>
<p>如果此时对 Buffer 这块内存进行写溢出，则很显然会影响到指针 <span
class="math inline">\(p\)</span> 所指向的内存块的头，即 <span
class="math inline">\(p\)</span>
指向内存块的头的数据会被覆盖，然而系统对此是允许的，在 <span
class="math inline">\(p\)</span> 头被覆盖时程序并不会崩溃，但在重新
<code>free</code> 或 <code>malloc</code>
时，就有极大的可能造成程序的崩溃或是影响到其它数据</p>
<h3 id="doubly-linked-free-list">Doubly Linked Free List</h3>
<p>假设 free list 是一个双向链表，即 <code>unlink(p)</code> 操作为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(p)</span></span>&#123;</span><br><span class="line">    p-&gt;prev-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;newx-&gt;prev = p-&gt;prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时汇编伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 假设被删掉的节点地址存在eax中</span><br><span class="line">[[eax+8]+4] &lt;- [eax+4]</span><br><span class="line">[[eax+4]+8] &lt;- [eax+8]</span><br></pre></td></tr></table></figure>
<p>并假设空闲块的头包含如下信息：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Offset</th>
<th style="text-align: center;">Type</th>
<th style="text-align: center;">Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(+0\)</span></td>
<td style="text-align: center;"><code>int</code></td>
<td style="text-align: center;">size</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(+4\)</span></td>
<td style="text-align: center;"><code>p*</code></td>
<td style="text-align: center;">next</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(+8\)</span></td>
<td style="text-align: center;"><code>p*</code></td>
<td style="text-align: center;">prev</td>
</tr>
</tbody>
</table>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20220926232430280.png" alt="image-20220926232430280" style="zoom:80%;" /></p>
<p>而假设该空闲块下方低地址处存在一块可写入数据块，当写溢出时将会覆盖掉
<code>next</code> 以及 <code>prev</code> 的值，导致当要
<code>free</code>
掉这一空闲块时，从汇编指令来看会触发一个任意写操作：</p>
<p>假设覆盖后的值为
<code>next =  0x1234, prev = 0x5678</code>，那么经过上述第一条汇编语句后会出现
<code>[0x567c] &lt;- 0x1234</code>
的情况，也就是说如果攻击者愿意，他可以将任何数据写入任何位置，只需令
<code>prev = address - 4, next = data</code> 即可</p>
<p>当然上述操作会有个副作用：第二条指令同样会写入数据，但很难控制两处数据都是需要的，因此很可能会写乱另一个块</p>
<h3 id="arbitrary-write">Arbitrary Write</h3>
<p>一次任意写即可截获程序控制流：</p>
<ul>
<li>ROP</li>
<li>JOP</li>
<li>修改动态链接中的 GOT 表
<ul>
<li>The next time the function is called, you get control flow</li>
</ul></li>
<li>C++ 虚函数
<ul>
<li>When virtual functions are called</li>
<li>To increase chances, try destructor</li>
</ul></li>
</ul>
<h4 id="got-表">GOT 表</h4>
<p>考虑如下程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_banner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to World of PLT and GOT\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    print_banner();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编得到：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\wps1-16769570299451.png" alt="img" style="zoom:80%;" /></p>
<p>此时 call 并不知道 <code>printf()</code>
函数的位置，由于一个程序往往只要用到动态链接库中的一小部分函数，因此动态链接库并不会整个被映射到进程内存中，而只映射用到的函数</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20230221132647697.png" alt="image-20230221132647697" style="zoom:80%;" /></p>
<p>当程序被运行要调用 <code>printf()</code>
函数时，调用过程会分为以下几个步骤：</p>
<ul>
<li><p><code>call printf@plt</code>，而 PLT 表会存储 GOT 表中存储
<code>printf()</code> 函数指针的位置</p></li>
<li><p><code>jmp *printf@got</code>，当然，一开始时 GOT 表并不会存储
<code>printf()</code>
函数指针，但会存储动态加载器（loader）的地址，在第一个调用
<code>printf()</code> 函数时</p>
<ul>
<li><p>Push RIP.</p></li>
<li><p>Resolve RIP to know which function is called.</p>
<p>loader 会去识别是哪个函数正在被调用</p></li>
<li><p>Loader try to mmap the .so file into memory.</p>
<p>loader 在 .so 文件中找到这个函数并映射到内存</p></li>
<li><p>Then modify the address of the entry to the function address</p>
<p>将 GOT 表中相应位置的值修改为该函数的函数指针</p></li>
</ul></li>
</ul>
<h4 id="c虚函数">C++虚函数</h4>
<p>假设有如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">Base d = <span class="keyword">new</span> Derived();</span><br><span class="line">d.<span class="keyword">do</span>();</span><br></pre></td></tr></table></figure>
<p>那么执行 <code>d.do()</code> 语句时，无论如何实际上执行的都是
<code>Derived::do()</code></p>
<p>然而对 C++ 而言，假设有如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line">Base *d = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">d-&gt;<span class="built_in"><span class="keyword">do</span></span>();</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">Base &amp;d = b; <span class="comment">// b is Derived</span></span><br><span class="line">d.<span class="built_in"><span class="keyword">do</span></span>();</span><br></pre></td></tr></table></figure>
<p>执行 <code>d.do()</code> 时可能执行
<code>Derived::do()</code>，也可能执行 <code>Base::do()</code>，这取决于
<code>do()</code> 这个函数是否是虚函数</p>
<ul>
<li>若 <code>do()</code> 是虚函数，则执行的是
<code>Derived::do()</code></li>
<li>若 <code>do()</code> 不是虚函数（即便重载了），则执行的是
<code>Base::do()</code></li>
</ul>
<p>因此对于虚函数，当调用 <code>Base.do()/Base-&gt;do()</code>
时，具体调用哪个函数取决于引用或指针指向对象本身的类型，只能在运行时确定</p>
<p>因此 C++
中对于有虚函数的类，都包含一个隐藏变量，这个隐藏变量指向了一个虚函数表（vtbl），这个虚函数表上存储了类的各个函数的函数指针</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20230221153419910.png" alt="image-20230221153419910" style="zoom:80%;" /></p>
<p><strong>C++ 类强制转换的坑</strong></p>
<p>假设有如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseA</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fnA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m_nTestA;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseB</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fnB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m_nTestB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span> :</span> <span class="keyword">public</span> IBaseA, <span class="keyword">public</span> IBaseB &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fnA</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;fnA\n&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fnB</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;fnB\n&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    CTest* pTest = <span class="keyword">new</span> CTest;</span><br><span class="line">    <span class="keyword">void</span>* p = (<span class="keyword">void</span>*)pTest;</span><br><span class="line">    IBaseA* pBaseA = (IBaseA*)p;</span><br><span class="line">    pBaseA-&gt;<span class="built_in">fnA</span>();</span><br><span class="line"></span><br><span class="line">    IBaseB* pBaseB = (IBaseB*)p;</span><br><span class="line">    pBaseB-&gt;<span class="built_in">fnB</span>();</span><br><span class="line"></span><br><span class="line">    pBaseB = (IBaseB*)pTest;</span><br><span class="line">    pBaseB-&gt;<span class="built_in">fnB</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>CTest</code> 为多重继承类，其有两个父类</p>
<p>运行后会得到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fnA</span><br><span class="line">fnA</span><br><span class="line">fnB</span><br></pre></td></tr></table></figure>
<p>也就是说第一次 <code>pBaseB-&gt;fnB()</code> 调用的函数实际上是
<code>IBaseA::fnA()</code>，而第二次 <code>pBaseB-&gt;fnB()</code>
调用就正确了</p>
<p>其原因在于对于 <code>CTest</code> 这个类而言，其结构大概如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> +0: pointer to virtual method table of CTest (from IBaseA, but overloaded)</span><br><span class="line"> +4: value of m_nTestA</span><br><span class="line"> +8: pointer to virtual method table of CTest (from IBaseB, but overloaded)</span><br><span class="line">+12: value of m_nTestB</span><br></pre></td></tr></table></figure>
<p>C++
在将多重继承子类强制转换回父类时，会根据父类的先后顺序修改指针的值，但</p>
<ul>
<li>第一次调用前，<code>pBaseB</code> 指针是由 <code>void*</code>
类型强制转换而来的，编译器并不知道 <code>p</code> 是否指向的是一个
<code>IBaseB</code> 的子类</li>
<li>第二次调用前，<code>pBaseB</code> 指针显式地由 <code>CTest*</code>
类型强制转换而来，编译器知道 <code>CTest</code> 是 <code>IBaseB</code>
的子类，且它是一个多重子类，<code>IBaseB</code>
的顺序为第二个被继承的父类，因此此时 <code>pBaseB</code> 的值实际上等于
<code>pTest + 8</code>，而这个 +<span class="math inline">\(8\)</span>
是编译器来添加的</li>
</ul>
<h2 id="fengshui风水">fengshui（风水）</h2>
<p>由于利用堆溢出而发出的攻击需要等到 free list 做 unlink 操作，而 free
list
中的表项非常多，故堆溢出攻击触发的时机没有栈溢出攻击的时机确定（甚至可能不会被触发），因此还需要其他攻击手段作为补充，该手段被国外黑客称之为
<strong>fengshui（即风水）</strong></p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20220926234554886.png" alt="image-20220926234554886" style="zoom:80%;" /></p>
<p>我们假设已知有一个 bug 能让程序跳转到 <code>0x0c0c0c0c</code>
位置执行，在正常情况下触发这个 bug
很大概率是指令转到一个操作系统未分配的页上，此时程序崩溃</p>
<h2 id="other-heap-related-bugs">Other Heap Related Bugs</h2>
<h3 id="use-without-initialization">Use Without Initialization</h3>
<ul>
<li><p>Some developers assume malloced memory is all zero.</p>
<ul>
<li>It seems correct.</li>
</ul>
<p>malloc
从操作系统得到的内存页一定是全零的，因为这些内存页很可能是别的进程刚释放的，若不清零会导致数据跨进程泄露</p>
<p>但 malloc 从 free list 中得到的内存页则不一定是全零的，free list
中是当前进程使用过的内存，而 free
的时候为了效率显然不会去手动清零，这就导致了未初始化使用的问题</p></li>
<li><p>Try to exploit bugs.</p>
<ul>
<li>Feed many memory blocks and then free them.</li>
<li>Wait for codes to use them without initialization.</li>
</ul>
<p>攻击者可以申请大量内存，并在内存中填入需要的数据后再释放这些数据，之后只需等待受害程序员重新申请这些内存块，而一旦该程序员未初始化使用，就很可能会导致一些
bug：如程序员认为该内存块全为 <span
class="math inline">\(0\)</span>，没用填入字符串结束符（<code>\0</code>），此时攻击者的数据很可能就与程序员的数据连接在一起而出现某些风险</p></li>
</ul>
<h3 id="use-after-free-dangling-pointer">Use After Free (Dangling
Pointer)</h3>
<ul>
<li><p>If a piece of code uses a piece of memory somewhere, while the
block may has been freed somewhere else, maybe in another thread.</p>
<p>可能有两个指针指向同一块内存，但 free
了其中一个指针，而另一个指针以及使用它的代码还不知道这块内存已经被 free
了（比如在另一个线程中）</p></li>
<li><p>The attacker can try to legally acquire the memory by a lot of
malloc().</p>
<p>攻击者此时就可以合法地申请到这块内存，从而使其与受害者共用一块内存，当攻击者拿到这块内存，那么受害者使用这块内存的代码的行为很可能会变得不可控</p></li>
<li><p>Then she shares a piece of memory with legal codes.</p></li>
<li><p>She can misinterpret the codes.</p></li>
</ul>
<h3 id="double-free">Double Free</h3>
<ul>
<li><p>Maybe, as a consequence, an object “shared” by two
pointers</p></li>
<li><p>One may be filled by the attacker to cause misinterpreting.</p>
<p>与 Use After Free
类似，攻击者也能够合法地与受害者共享一块内存</p></li>
</ul>
<h2 id="other-overflow">Other Overflow</h2>
<h2 id="memory-corruption-defense">Memory Corruption Defense</h2>
<ul>
<li><p>Detection</p>
<ul>
<li><p>Canary: Put a random number on the headers of memory blocks</p>
<p>类似栈 canary，在 free list 的头前增加一个 canary，每次 malloc
取出时检查，若 canary 被改变则杀死程序</p></li>
<li><p>SAN: Address Sanitization</p></li>
</ul></li>
<li><p>Treat the symptoms</p>
<p>治标</p>
<ul>
<li><p>ASLR: Use a larger heap and make the addresses more
unpredictable</p>
<p>取堆地址时更加随机，如返回的内存块不是第一个满足请求大小的，而是第随机大小的</p></li>
</ul></li>
<li><p>Treat the cause</p>
<p>治本</p>
<ul>
<li>High level programming language</li>
<li>Static analysis to enforce bound check</li>
</ul></li>
</ul>
<h3 id="address-sanitization">Address Sanitization</h3>
<ul>
<li><p>Keep track of the state of each byte of memory in separate memory
(shadow memory)</p>
<p>监控内存中每个 byte 的使用情况（是否处于已被申请/释放状态）</p>
<ul>
<li>When malloc/free, change the state of the memory</li>
</ul></li>
<li><p>Check if legal on each memory access</p>
<ul>
<li>For every memory access instruction</li>
<li>Check the state in shadow memory</li>
</ul></li>
<li><p>Overhead:</p>
<p>开销巨大，因此通常只在测试环境中使用</p>
<ul>
<li>Memory access becomes slower.</li>
<li>Try to optimize check code so o(1) time can be spent.</li>
</ul></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Input Problem</title>
    <url>/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.3.2%20Input%20Problem/</url>
    <content><![CDATA[<h1 id="input-problem">Input Problem</h1>
<h2 id="insecure-input">Insecure Input</h2>
<p>输入验证是重要的，否则：</p>
<ul>
<li>攻击者可以利用应用中的 bugs
<ul>
<li>缓冲区溢出</li>
<li>无效输入导致的 bug</li>
</ul></li>
<li>攻击者可以滥用应用提供的函数：
<ul>
<li>如 SQL 注入</li>
<li>无效输入引发无法预料的行为</li>
</ul></li>
</ul>
<h3 id="sql-注入">SQL 注入</h3>
<p>Web 服务器（PHP）执行 SQL
语句查询数据库时，其语句是用字符串拼接实现的，例如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;SELECT * FROM Account WHERE Username = &quot;</span> + <span class="variable">$username</span> + <span class="string">&quot;AND Password = &quot;</span> + <span class="variable">$password</span>;</span><br></pre></td></tr></table></figure>
<p>通过设计某些输入可以完成任意登录或导致某些 bug：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221024092325841.png" alt="image-20221024092325841" style="zoom:80%;" /></p>
<p>此时若 <code>email</code>
中的信息是某个用户使用的邮箱，那么此时后面的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FALSE AND FALSE OR TRUE</span><br></pre></td></tr></table></figure>
<p>会导致该 <code>select</code>
语句对于所有用户信息都被选出，此时服务器是让攻击者登录还是产生 bug
取决于服务器怎么处理一个用户查询产生多个符合要求的用户</p>
<h2 id="causes-of-input-problems">Causes of input problems</h2>
<ul>
<li><p>Complex input format.</p>
<p>GCC, HTTP, etc…</p></li>
<li><p>Unclear specification.</p>
<p>Unexpected format.</p></li>
<li><p>Expressivity of input language.</p>
<p>SQL injection: Password? No, code</p></li>
<li><p>Nested input</p>
<p>XSS: input by form -&gt; processed by Apache, PHP -&gt; handled by
SQL -&gt; Rendered by Chrome &amp; V8</p></li>
</ul>
<p>很多时候编译器标准和语言标准的更新迭代会导致输入格式发生变化，这是
input problems 的来源之一</p>
<h2 id="who-processes-input">Who processes input?</h2>
<h3 id="parser">Parser</h3>
<ul>
<li><p>Complex input languages make for many parser bugs.</p>
<p>E.g.: Flash. Flash allows union of audio images videos…..</p>
<p>JPG+GIF+PNG+H.<span class="math inline">\(264\)</span>/MPEG<span
class="math inline">\(4\)</span>+VP6+MP<span
class="math inline">\(3\)</span>+AAC+Speex+PCM+ADPCM+Nellymoser….</p></li>
<li><p>Parsers are usually written by memory unsafe languages (e.g.,
C++)</p></li>
<li><p>Bugs can cause vulnerabilities like RCE (remote code
execution)</p></li>
<li><p>Bugs for parser are easy to trigger</p></li>
</ul>
<p>随着处理格式的增加（如
Flash）或语言功能的增加（各种编程语言），Parser
的代码量也在增加，当一个程序的代码量达到十万百万量级时就几乎不可能没有
bug</p>
<h3 id="parser-vulnerability-examples">Parser vulnerability
examples</h3>
<p>Microsoft Security Bulletin MS<span
class="math inline">\(04\)</span>-<span
class="math inline">\(028\)</span>，即微软 JPEG 漏洞：微软的 JPEG
处理程序（GDI+
组件）中的缓冲区溢出可能导致远程代码执行。攻击者将恶意代码内嵌在一个
JEPG 图片中，只要用户打开或预览该图片（注意 Windows
在开启大图标预览模式下只要进入图片所在文件夹就会自动预览，在文件夹中显示一个缩略图），病毒代码就会自动执行</p>
<h2 id="input-with-dos">Input with DoS</h2>
<p>Dos（Denial Of
Service，拒绝服务攻击）：其目的是让服务器实现两种效果：一是迫使服务器的缓冲区满，不接收新的请求；二是使用
IP 欺骗，迫使服务器把非法用户的连接复位，影响合法用户的连接</p>
<p>方法如：</p>
<ul>
<li><p>暴力攻击</p>
<p>给目标服务器发送大量垃圾信息使服务器的缓冲区满，但该方法效率低下，成功的前提是自身存在高于对方服务器处理能力的设备</p></li>
<li><p>zip bomb</p>
<p>一个 <span class="math inline">\(40\)</span>KB 的 zip 解压后可以达到
<span
class="math inline">\(4\)</span>GB，这就是为什么云盘服务商不免费提供在线解压的原因之一</p></li>
<li><p>XML bomb</p>
<p>一个 <span class="math inline">\(1\)</span>KB 的 XML 文件可以被解析到
<span class="math inline">\(3\)</span>GB</p></li>
<li><p><code>printf("%0*d\n", ?, 0);</code></p>
<p>类似这种输入在 <code>?</code>
所表示的数字非常大的情况下将会打印大量数据</p></li>
</ul>
<p>任何处理输入的 CPU 都可能最终导致 DoS</p>
<p>因此为防范 DoS
攻击，不仅需要检查输入的合法性，还要检查输入处理的时间，此时需要开启另一个线程对处理输入的线程进行时间计数，同时设置一个
timeout 作为时间限制</p>
<h2 id="simple-injection-attacks">Simple injection attacks</h2>
<p>直接利用某些语言的表达能力：</p>
<ul>
<li><p>OS 命令：如 <code>ls -fr/</code> 或 <code>rm -fr/</code> 或
<code>ls -fr/*</code> 或 <code>rm -fr/*</code> 等</p>
<p>其中 <code>rm -fr/</code> 将会删除整个根目录，而
<code>rm -fr/*</code> 会删除根目录下所有文件，其中 <code>-f</code>
是强制删除，<code>-r</code>
为递归删除，输入该命令将导致所有数据被清空</p></li>
<li><p>路径表达式：如
<code>../../../etc/passwd</code>，其将导致操纵者访问到某些不应该被访问的文件</p></li>
<li><p>SQL 语句：如 <code>OR '1'='1'</code>；<code>DROP TABLES</code>
等</p></li>
<li><p>HTML 脚本：如
<code>&lt;script&gt;…document.cookie…&lt;/script&gt;</code>
可能导致执行某些恶意代码</p>
<p>并且 HTML<span class="math inline">\(5\)</span> 支持内嵌 JS，DOM，CSS
使得 HTML 文件的表示能力更加强大</p></li>
<li><p>格式化字符串：如 <code>%x%x%x%x%n</code></p></li>
</ul>
<h2 id="how-to-defend">How to defend?</h2>
<h3 id="input-validation">Input Validation</h3>
<p>只允许用户输入合法的输入：</p>
<ul>
<li>黑名单：禁止某些输入</li>
<li>白名单：允许某些输入</li>
</ul>
<h4 id="black-vs.-white">Black vs. White</h4>
<p><strong>Black Lists</strong></p>
<ul>
<li>' or ; to prevent SQL injection</li>
<li>&lt; or &gt; to prevent HTML injection</li>
<li>&lt;script&gt; and &lt;/script&gt; to prevent XSS</li>
<li>; | &lt; &gt; &amp; to prevent OS command injection</li>
</ul>
<p>Warning: these blacklists are very <strong>incomplete</strong>.
Escaping may bypass black list</p>
<p><strong>White Lists</strong></p>
<p>only accept inputs with <code>a-z | A-Z | 0-9</code> to prevent SQL
or HTML injection</p>
<h3 id="validation-patterns">Validation patterns</h3>
<ul>
<li><p>For numbers:</p>
<ul>
<li><p>positive, negative, max. value, possible range?</p></li>
<li><p>Or eg. checksum for credit card numbers</p>
<p>Chinese ID, TCP CRC, Hash. 但很多时候
CRC（循环冗余校验码）只能处理随机情况（传输错误），攻击者可以轻易绕过</p></li>
</ul></li>
<li><p>For strings:</p>
<ul>
<li><p>(dis)allowed characters or words</p></li>
<li><p>More precise checks, e.g. using regular expressions or
context-free grammars</p>
<p>valid email address, URL, …</p></li>
</ul></li>
</ul>
<h2 id="what-to-do-if-illegal-input-found">What to do if illegal input
found?</h2>
<ul>
<li><p>Reject</p>
<p>Throw an error.</p></li>
<li><p>Sanitize</p>
<ul>
<li>Escape</li>
<li>E.g.:replace ″ by ″ to prevent SQL injection</li>
<li>replace &lt; &gt; by &amp;lt &amp;gt to prevent HTML/ XML
injection</li>
<li>replace script by xxxx to prevent XSS</li>
<li>put quotes around dangerous input</li>
</ul></li>
<li><p>Note: re-check after sanitizing.</p></li>
</ul>
<h2 id="canonicalisation">Canonicalisation</h2>
<p>Canonicalisation：即指一种信息可以有多种表达方式，如：</p>
<ul>
<li><p>大小写无关：</p>
<p><code>s123456</code> 和 <code>S123456</code>
的表示的信息就是一样的</p></li>
<li><p>忽略字符或子字符串</p>
<p>na.me@gmail.com Google chooses to ignore dots in usernames</p></li>
<li><p>.. . ~ in path names</p></li>
<li><p>file URLs <code>file://127.0.0.1/c|WINDOWS/clock.avi</code></p>
<ul>
<li>using either <code>/</code> or <code>\</code> in a URL on
Windows：URL encoding eg <code>/</code> encoded as
<code>%2f</code>；Unicode encoding eg <code>/</code> encoded as
<code>\u002f</code></li>
</ul></li>
</ul>
<p>而 Canonicalisation 很可能能够帮助攻击者绕过 Validation</p>
<h3 id="javascript-example">JavaScript example</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span><span class="javascript"> alert(<span class="string">&#x27;Hi&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>can also be written as:</p>
<ul>
<li><p>```html</p>
<body onload=alert('Hi')>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  &lt;b onmouseover=alert(&#x27;Hi&#x27;)&gt;Click here!&lt;/b&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>```html
<img src=http://some.url.that/does/not/exist onerror=alert('Hi');>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  &lt;img src=j&amp;#X41vascript:alert(&#x27;Hi&#x27;)&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>```html</p>
<META HTTP-EQUIV="refresh" 
CONTENT="0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## Double Encoding</span><br><span class="line"></span><br><span class="line">双重编码可能让攻击者绕过输入验证</span><br><span class="line"></span><br><span class="line">如果输入验证只解码一次，但应用程序更深层次的接口执行第二次解码</span><br><span class="line"></span><br><span class="line">E.g. Google Chrome crashed on URL `http://%%30%30`</span><br><span class="line"></span><br><span class="line">- `%30` is `0%`</span><br><span class="line">- `%30%30 -&gt; %00%00` is `null`</span><br><span class="line">- `%00` is `null`</span><br><span class="line"></span><br><span class="line">## Where to validate?</span><br><span class="line"></span><br><span class="line">Client side or sever side? Both!</span><br><span class="line"></span><br><span class="line">- Server Side:</span><br><span class="line"></span><br><span class="line">  对于后端而言，为了安全性应该假设用户都是恶意的，是必须要检查的</span><br><span class="line"></span><br><span class="line">- Client Side: </span><br><span class="line"></span><br><span class="line">  对于前端而言，假设用户是受害者，为了</span><br><span class="line"></span><br><span class="line">  - 防止错误的输入</span><br><span class="line">  - 用户被攻击者欺骗</span><br><span class="line">  - 通信效率</span><br><span class="line">  - 用户体验</span><br><span class="line"></span><br><span class="line">  都有需要进行输入验证。当然前端由于运行在客户机上，攻击者可以很轻易地将其关闭，因此其对安全的意义不大，但对用户体验很重要</span><br><span class="line"></span><br><span class="line">## input validation vs. output sanitization</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221024105103909.png&quot; alt=&quot;image-20221024105103909&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">**History of input sanitisation in PHP**</span><br><span class="line"></span><br><span class="line">- PHP $2,3,4$</span><br><span class="line"></span><br><span class="line">  Magic quotes，即 PHP 的自动转义功能，对一切输入中的单引号（&#x27;）、双引号（&quot;）、反斜线（\）、NUL（null 字符） 自动转义</span><br><span class="line"></span><br><span class="line">  all user parameters automatically escaped by calling addslashes</span><br><span class="line"></span><br><span class="line">- PHP$5$ and later:</span><br><span class="line"></span><br><span class="line">  No more magic quotes</span><br><span class="line"></span><br><span class="line">  Dedicated escaping for outsource</span><br><span class="line"></span><br><span class="line">  - my_sql_real_escape_string for MySQL</span><br><span class="line">  - pg_escape_string for PostgreSQL</span><br><span class="line"></span><br><span class="line">- Magic quotes give a sense of secure. But eventually bad security.</span><br><span class="line"></span><br><span class="line">## Reducing expressive power</span><br><span class="line"></span><br><span class="line">控制用户输入的根本方法之一是降低用户输入语句的表达能力，如 SQL：</span><br><span class="line"></span><br><span class="line">在用户登录过程中：</span><br><span class="line"></span><br><span class="line">- SQL 本身能干什么？</span><br><span class="line"></span><br><span class="line">  查询数据库。但是不能让用户自己写 SQL 来进行登录操作</span><br><span class="line"></span><br><span class="line">- 开发者限制 SQL</span><br><span class="line"></span><br><span class="line">  ```php</span><br><span class="line">  &quot;SELECT * FROM Account WHERE Username = &quot; + $username + &quot;AND Password = &quot; + $password;</span><br></pre></td></tr></table></figure>
<p>使用字符串拼接让用户只输入用户名和密码</p></li>
</ul>
<p>显然在这里用户输入本质上产生了一条 SQL 语句，但 PHP 对这条 SQL
语句的表达能力做了限制。然而，从之前的例子来看，仅仅是这样的话仍然可以被攻击者利用，因此我们需要继续对其表达能力增加限制（如黑名单、白名单等）</p>
]]></content>
  </entry>
  <entry>
    <title>Sandboxing</title>
    <url>/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.5%20Sandboxing/</url>
    <content><![CDATA[<h1 id="sandboxing">Sandboxing</h1>
<h2 id="compartmentalization">Compartmentalization</h2>
<ul>
<li><p>Divide systems into components. 代码分块</p>
<ul>
<li>Different components for different tasks. 增强代码可读性</li>
</ul></li>
<li><p>Minimal access rights to each component.</p>
<p>如类的成员保护机制</p>
<ul>
<li>Least privilege</li>
</ul></li>
<li><p>Strong isolation between components</p>
<ul>
<li>Clear and simple interfaces between components.</li>
<li>Different modules interoperate though the interfaces only.</li>
</ul></li>
<li><p>Benefits:</p>
<ul>
<li><p>Reduced TCB （Trusted Computing Base，可信赖计算库）</p>
<ul>
<li>Only the runtime is in the TCB.</li>
<li>TCB:a small amount of software and hardware that security depends
on. and that we distinguish from a much larger amount that can misbehave
without affecting security.</li>
</ul>
<p>TCB 的要求是</p>
<ul>
<li>独立的（independent）</li>
<li>具有抗篡改性（tempering proof）</li>
<li>不可旁路（无法窃听）</li>
<li>最小化以便于分析和测试</li>
</ul></li>
<li><p>Reduced impact of security flaws</p>
<ul>
<li>When one module hacked, other modules unaffected.</li>
</ul></li>
</ul></li>
</ul>
<h3 id="sandboxing-1">Sandboxing</h3>
<p><strong>Sandboxing: the standard way to provide
compartmentalisation.</strong></p>
<p>沙箱机制包括：</p>
<ul>
<li><p>permissions, resources</p>
<p>规定权限以及相应的资源</p></li>
<li><p>parties (eg. users, processes, components)</p>
<p>对象分类：用户，进程，模块（java）</p></li>
<li><p>policies that give permissions or resources to parties</p>
<p>规定什么对象拥有什么权限，可以访问什么资源</p>
<ul>
<li>specifying who is allowed to do what</li>
</ul></li>
<li><p>runtime monitoring to enforce policies</p></li>
</ul>
<h4 id="os-based-sandboxing">OS-based sandboxing</h4>
<p>操作系统的隔离单位：进程</p>
<ul>
<li><p>Scheduling</p>
<ul>
<li>Resource is assumed unlimited、</li>
<li>But should be allocated fairly</li>
<li>E.g.: Linux CFS (Completely Fair Scheduler) to assign time slot to
threads.</li>
<li>E.g.: TCP flow control. Balances bandwidth consumption of different
processes.</li>
</ul></li>
<li><p>Resource Limit</p>
<ul>
<li><p>Limit the resource a process can use, even if physical resource
is unlimited</p></li>
<li><p>E.g.: Linux cgroupscpuset, memory, devices, blkio, net_prio,
hugetlb etc..</p>
<p>cgroups 是 Linux
内核提供的一种可以限制单个进程或者多个进程所使用资源的机制，可以对
cpu，内存等资源实现精细化的控制</p>
<p>具体详见：<a
href="https://tech.meituan.com/2015/03/31/cgroups.html">Linux资源管理之cgroups简介
- 美团技术团队 (meituan.com)</a></p></li>
</ul></li>
</ul>
<p>Problem with OS sandboxing</p>
<ul>
<li><p>Size of the TCB for OS access control is HUGE</p>
<ul>
<li>So there will be security flaws in the code.</li>
<li>Remember how many lines of code linux kernel has?</li>
</ul>
<p>操作系统作为 TCB 是可靠的，但它太大了，导致几乎不可能不出现
bug</p></li>
<li><p>Too much complexity</p>
<p>过于复杂，导致使用者出现错误的可能性大大增加</p>
<ul>
<li>The languages to express access control policy are very complex</li>
<li>so people will make mistakes
<ul>
<li>E.g., set wrong permissions.</li>
</ul></li>
</ul></li>
<li><p>Not enough granularity</p>
<ul>
<li>Eg. the OS cannot do access control within processes</li>
</ul>
<p>粒度过大，OS
无法控制进程内的行为（如进程内调用不受信的动态链接库威胁进程和系统安全）</p></li>
<li><p>Limitation of classic OS access control</p>
<ul>
<li><p>Fixed set of permissions. Usually, all permissions of the user
who started it</p></li>
<li><p>Reduced permission may be needed temporarily when executing
untrusted or less trusted code.</p></li>
</ul>
<p>Remedies/improvements</p>
<ul>
<li>Allowing users to drop rights when they start a process
<ul>
<li>e.g.: drop setuid 这种是不可逆的，除非重启进程</li>
</ul></li>
<li>Asking user approval for additional permissions at run-time
<ul>
<li>IOS, Android …</li>
</ul></li>
<li>Using different user accounts for different applications
<ul>
<li>as Android does</li>
</ul></li>
<li>Split a process into multiple processes with different access rights
<ul>
<li>Chrome tabs，Chrome 的标签页都是不同的进程</li>
</ul></li>
</ul></li>
</ul>
<h2 id="sandbox-example">Sandbox Example</h2>
<h3 id="online-judge-system">Online Judge System</h3>
<p>假如有用户在 OJ 中提交如下代码：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20230220210355780.png" alt="image-20230220210355780" style="zoom:80%;" /></p>
<p>如何保证 OJ 所在服务器的安全？</p>
<p>利用 <code>ptrace()</code> 函数：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\图片1-16768983042221.png" alt="图片1" style="zoom:80%;" /></p>
<p>在父进程 <code>fork</code> 出子进程，子进程调用 <code>ptrace</code>
设置第一个参数为
<code>PTRACE_TRACEME</code>，之后子进程收到的所有信号（不包括
SIGKILL）都会被父进程捕获，此时父进程就可以去观察子进程的内存、寄存器状态甚至修改它们</p>
<p>当 OJ
运行用户提交代码时，服务器就会去跟踪执行该代码的子进程，若子进程行为合法则继续运行，否则杀死该子进程</p>
<h3 id="compartementalisation-in-chrome">compartementalisation in
Chrome</h3>
<p>The Chrome browser process is split into multiple OS processes</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\图片2-16768986950313.png" alt="图片2" style="zoom:80%;" /></p>
<ul>
<li>One rendering engine per tab</li>
<li>One browser kernel with full user privileges</li>
</ul>
<p>在 Chrome 中，Tab 对于某些信息（如 TLS
证书，用户保存的密码等）都是碰不到到的（需要时调用 API），某个 Tab
读取某个 password 时，Chrome 也会检查是否是这个 Tab 对应的 password</p>
<p>安全性保证：当一个 Tab 被攻陷时，这个 Tab 什么也干不了</p>
<h2 id="sand-boxing-with-code-based-access-control">Sand-boxing with
code-based access control</h2>
<p>针对 package/namespace/class 等细粒度的控制</p>
<p>举例：<strong>Java 包</strong></p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\图片5-16769092699939.png" alt="图片5" style="zoom:80%;" /></p>
<p>JVM 在调用敏感系统调用（delete）时检查包是否受信</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\图片6-167690927739411.png" alt="图片6" style="zoom:80%;" /></p>
<p>显然不能只检查一次，否则上述情况很容易就绕开了这种机制</p>
<p><strong>stack walking</strong></p>
<p>JVM
曾经提出一种检查方式：将整个调用栈检查一遍，当所有包都是受信的时，才允许敏感调用</p>
<h2 id="sandboxing-with-low-overhead">Sandboxing with low overhead</h2>
<ul>
<li><p>Language based sandboxing introduces obvious overhead.</p>
<ul>
<li><p>E.g., Javascript V8 engine is slow compared with c.</p>
<p>JS V8 这类运行时系统的开销（overhead）过大，至少比直接运行 C
语言要慢上 <span class="math inline">\(50\%\)</span></p></li>
<li><p>Additional checks waste CPU cycles.</p></li>
</ul></li>
<li><p>Chrome does not compromise performance for security.</p>
<p>但浏览器的沙箱需求非常高，Chrome 不可能为了性能去放弃安全</p></li>
<li><p>Chrome provides native plugin for developers via NaCl</p>
<p>为此，Google 开发出了 NaCl（Native Client）插件，其可以直接运行 Web
所提供的二进制文件（插件），以令 Web
应用以接近桌面程序的性能运行</p></li>
</ul>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\图片3-16769005055575.png" alt="图片3" style="zoom:80%;" /></p>
<h3 id="nacl">NaCl</h3>
<p>NaCl statically verifies（静态地检验，而非像 runtime 在运行时检测）
codes before running the codes, to avoid illegal instructions and
illegal access.</p>
<p>NaCl 要求 Web 提供的 binary 可以唯一地反汇编，否则就不运行</p>
<p>How to verify?</p>
<ul>
<li><p>How to guarantee correct disassembly?</p>
<p>如何保证正确反汇编？</p>
<ul>
<li>fixed entry point and no normal indirect jump.</li>
<li>Align instructions to <span class="math inline">\(32\)</span>
bytes.</li>
<li>pseudo jump to aligned instructions.</li>
</ul></li>
<li><p>How to guarantee memory access safety?</p>
<p>如何保证内存访问指令只访问分配给它的空间？</p>
<ul>
<li>X86 segment</li>
</ul></li>
</ul>
<p>Rules：保证一定能被反汇编</p>
<ul>
<li><p>C<span class="math inline">\(1\)</span>：Once loaded into the
memory, the binary is not writable, enforced by OS-level protection
mechanisms during execution.</p>
<p>一旦加载到内存中，二进制文件是不可写的，在执行过程中由操作系统级保护机制强制执行</p>
<p>程序的 text 段是只读且可执行的：保证代码在运行时不会
self-modified</p></li>
<li><p>C<span class="math inline">\(2\)</span>​：The binary is statically
linked at a start address of zero, with the first byte of text at <span
class="math inline">\(64\)</span>K.</p>
<p>二进制文件被静态链接到起始地址为 <span
class="math inline">\(0\)</span>
处（链接到固定未知），代码段的第一个字节从 <span
class="math inline">\(64\)</span>K 开始</p></li>
<li><p>C<span class="math inline">\(3\)</span>：All indirect control
transfers use a <code>nacljmp</code> pseudo-instruction (defined
below).</p>
<p>所有间接跳转都会使用 <code>nacljmp</code> 伪指令</p>
<p><code>nacljmp</code> 伪指令相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and %eax, 0xfffffffe0 # 假设存储间接跳转地址的寄存器是eax</span><br><span class="line">jmp *%eax</span><br></pre></td></tr></table></figure>
<p>C<span class="math inline">\(3\)</span> + C<span
class="math inline">\(5\)</span>
保证了所有跳转都会跳转到完整指令的开头（例如一条指令 <span
class="math inline">\(7\)</span>
Byte，那么此时跳转不可能跳转到该指令的低 <span
class="math inline">\(3\)</span> 个 Byte 上）</p></li>
<li><p>C<span class="math inline">\(4\)</span>：The binary is padded up
to the nearest page with at least one <code>hlt</code> instruction
(<span class="math inline">\(0\)</span>xf<span
class="math inline">\(4\)</span>).</p>
<p>该二进制文件至少用一条 <code>hlt</code> 指令填充到最近的页</p></li>
<li><p>C<span class="math inline">\(5\)</span>：The binary contains no
instructions or pseudo-instructions overlapping a <span
class="math inline">\(32\)</span>-byte boundary.</p>
<p>二进制文件中的所有指令都是 <span class="math inline">\(32\)</span>
Byte 对齐</p></li>
<li><p>C<span class="math inline">\(6\)</span>：All valid instruction
addresses are reachable by a fall-through disassembly that starts at the
load (base)address.</p>
<p>要求每条指令都能被递归下降反汇编，此时的所有指令都按照 <span
class="math inline">\(32\)</span> Byte
对齐，因此是一定能被反汇编的</p></li>
<li><p>C<span class="math inline">\(7\)</span>：All direct control
transfers target valid instructions.</p>
<p>所有的直接跳转都跳转到指令的开头（即 <span
class="math inline">\(32\)</span> Byte 对齐）</p></li>
</ul>
<h2 id="other-sandbox">Other Sandbox</h2>
<h3 id="ebpf-sandbox-inside-kernel">eBPF: sandbox inside kernel</h3>
<ul>
<li><p>Allow developers insert codes into kernel</p>
<ul>
<li><p>Unlike LKM (Linux Kernel Module), where developers may ruin
kernel</p>
<p>LKM 与 Linux 内核共享内存空间，如果这个 Kernel Module
出错，就可能导致内核崩溃</p></li>
<li><p>eBPF won’t crash kernel.</p></li>
</ul></li>
<li><p>Allow developers to add codes to some places of kernel</p>
<ul>
<li>Kernel has pre-defined tracing point.</li>
<li>When registered point reached, kernel run VM to invoke the eBPF
code</li>
</ul>
<p>保证不会破坏内核空间</p></li>
<li><p>Can be used to build packet filter</p></li>
</ul>
<h3 id="browser">Browser</h3>
<ul>
<li>V8: sandbox of Javascript</li>
<li>Web Assembly: sandbox to replace Nacl.</li>
</ul>
<p>两者都基于 JIT（Just in
Time）技术。对于需要运行时系统（runtime）的语言而言，如
Javascript，其运行需要 runtime
中的解析器解析生成字节码后使用解释器执行。这种边解析边执行的方式导致代码运行效率低下，而
JIT
技术将会通过监视器对代码进行监视，若发现重复执行的代码，这段代码将会被编译为二进制形式，将来再次执行这段代码时的效率就打打提高了（代码运行效率通常取决于重复代码运行的部分）</p>
<h3 id="android">Android</h3>
<ul>
<li><p>Dalvik: Sandbox Android apps</p>
<p>Dalvik 是基于寄存器的类 JVM 虚拟机，而 JVM 则是基于栈的</p></li>
</ul>
<h3 id="vm">VM</h3>
<ul>
<li><p>VMware (workstaion, esxi)</p></li>
<li><p>KVM</p></li>
<li><p>VT-x, VT-d</p>
<p>Intel硬件辅助虚拟化技术（Vanderpool Technology，VT）</p></li>
</ul>
<h2 id="sandboxing-our-self">Sandboxing our self</h2>
<p>沙箱技术不仅包括将多个对象隔离，同时也包括自我隔离的机制，如</p>
<p>处理密码的代码，其中可能包括各自 secret
值等，此时要求这段代码能够自我隔离，其它代码无法访问这段代码或查看这段代码的状态（代码中变量）等</p>
<p>通常该代码会放在一个独立的文件中，如
<code>secret.c</code>，自行编译为 <code>secret.o</code> 文件再与其它 ELF
文件链接</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\图片4-16769073807307.png" alt="图片4" style="zoom:80%;" /></p>
<h3 id="enclave">Enclave</h3>
<p>要想实现上述功能，需要利用到 Enclave 沙箱机制</p>
<ul>
<li><p>Enclaves isolates part of the code together with its data</p>
<ul>
<li><p>Code outside the enclave cannot access the enclave's data</p>
<p>enclave 中的数据只有 enclave 中的代码可以读取</p></li>
<li><p>Code outside the enclave can only jump to valid entry points for
code inside the enclave</p>
<p>enclave 提供 entry points 以供外部代码访问内部代码</p></li>
</ul></li>
<li><p>Less flexible than stack walking:</p>
<ul>
<li>Binary status (i.e., either inside or outside enclave)</li>
</ul></li>
<li><p>More secure, because</p>
<ul>
<li><p>Rely on hardware based isolation</p>
<p>enclave 机制是硬件提供的</p></li>
<li><p>OS &amp; Java VM (Virtual Machine) are not in the TCB</p>
<p>即使是操作系统或是虚拟机也无法访问运行在其之上的 enclave
中的代码</p></li>
<li><p>Also some protection against physical attacks is possible</p>
<p>当然还是有某些物理方面的攻击可以绕过（如侧信道攻击等）</p></li>
</ul></li>
</ul>
<h3 id="enclaves-using-intel-sgx">Enclaves using Intel SGX</h3>
<ul>
<li><p>Intel SGX provides hardware support for enclaves</p>
<ul>
<li>protecting confidentiality &amp; integrity of enclave’s code &amp;
data</li>
<li>providing a form of Trusted Execution Environment (TEE)</li>
</ul></li>
<li><p>This not only protects the enclave from the rest of the program,
but also from the underlying Operating System and VMM(e.g., VMware)!</p>
<ul>
<li><p>Hence example use cases include</p>
<ul>
<li><p>Running your code on cloud service you don’t fully trust: cloud
provider cannot read your data or reverse-engineer your code</p>
<p>如租用云服务器时，云服务商可以随时获得服务器中的所有数据，那么可以将数据存储到
Intel SGX 中</p></li>
<li><p>DRM (Digital Rights Management): decrypting video content on
user’s device without user getting access to keys</p>
<p>版权保护：将发送来的流媒体数据在 SGX 中解密后经由 trusted I/O
技术呈现给用户，用户就无法进行盗版</p></li>
</ul></li>
</ul></li>
<li><p>Some concerns about Intel’s security model:</p>
<ul>
<li>We must trust Intel before we can verify codes indeed run in
enclave.</li>
</ul></li>
</ul>
<h3 id="sgx-integrity-verification">SGX Integrity Verification</h3>
<p>怎么知道我们的程序运行在真正的 Intel CPU 上（或许是模拟的）？</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20230220235037679.png" alt="image-20230220235037679" style="zoom:80%;" /></p>
<p>Intel CPU 中自带唯一的 Attestation Key，运行在 SGX 中的应用可以要求
CPU 进行一次 “见证”，其过程类似于数字签名：CPU
对数据进行哈希计算后用隐藏的 Key（类似私钥）加密发送回开发者，开发者通过
Intel 提供的公钥来验证是否确实是是 Intel 的 CPU</p>
<p>当然，Intel Key 可能被泄露，大多数厂商也不信任
Intel，因而这项技术还没有被大规模地应用</p>
<p><strong>参考资料：</strong><a
href="https://blog.csdn.net/u010545480/article/details/122090733">iOS
Secure Enclave_ios的可信执行环境是什么_长沙火山的博客-CSDN博客</a></p>
]]></content>
  </entry>
  <entry>
    <title>High Level Programming</title>
    <url>/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.7%20High%20Level%20Programming/</url>
    <content><![CDATA[<h1 id="high-level-programming">High Level Programming</h1>
<h2 id="motivation">Motivation</h2>
<p>Why do programmers prefer high level language?</p>
<ul>
<li><p>+No need to care memory.</p>
<p>Java: GC</p>
<p>C++: Smart Pointer</p></li>
<li><p>+Built-in Advanced Data Structure</p>
<p>Python: Dict, List, Set</p>
<p>Java, C++: String</p></li>
<li><p>-Less static check</p>
<p>Python syntax check at runtime</p></li>
<li><p>~More Syntax Candy</p>
<p>:?, lambda</p>
<p>Exception</p></li>
</ul>
<p><strong>==扩展==</strong>：C++ 中的 vector 实现</p>
<p>C++ 中 vector 的实现为 vector
的数据量（size）大于其已申请的内存容量（capacity）时，其会再申请当前空间的一倍，这个申请的开销很大不可忽略，因此分析
vector 的复杂度时需要使用摊还分析（Amortized Analysis，均摊分析）</p>
<p>vector 的 <code>push_back()</code> 操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;data[size++] = data</span><br></pre></td></tr></table></figure>
<p>复杂度为 <span class="math inline">\(O(1)\)</span></p>
<p>当 <code>size = capacity</code> 时扩容操作会申请
<code>2 * capacity * sizeof(Type)</code> 大小的空间，并将此时 vector
内的所有数据复制过去，复杂度为 <span
class="math inline">\(O(n)\)</span>（设 capacity 为 <span
class="math inline">\(n\)</span>），那么从 <span
class="math inline">\(n/2\)</span> 到 <span
class="math inline">\(n\)</span> 的插入操作的复杂度就是 <span
class="math display">\[
O(1) +O(\frac{n}{n-n/2})=O(3)=O(1)
\]</span> 显然除了刚创建 vector 后的第一个操作 <code>push_back()</code>
为 <span class="math inline">\(O(2)\)</span> 以外其余复杂度都为 <span
class="math inline">\(O(3)\)</span>。即所有复杂度均为 <span
class="math inline">\(O(1)\)</span> 常数级别</p>
<p>vector 的 <code>pop_back()</code> 操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;data[size--] = data</span><br></pre></td></tr></table></figure>
<p>复杂度为 <span class="math inline">\(O(1)\)</span></p>
<p>然而对于 vector 的缩容操作就不能当 <code>size = capacity/2</code>
时进行了，否则可能导致复杂度震荡的问题：</p>
<p>在此情况下释放空间（复杂度 <span
class="math inline">\(O(n)\)</span>）后会出现
<code>size = capacity</code> 的情况。若 vector 的下个操作是
<code>push_back()</code> 则显然 vector
的容量再次不足，又需要扩容（复杂度为 <span
class="math inline">\(O(n)\)</span>）。这会导致若程序在此阈值附近进行大量
<code>push_back(), pop_back()</code> 操作，则每次操作的复杂度都为 <span
class="math inline">\(O(n)\)</span>，效率低下</p>
<p>因此 vector 的缩容操作应该等到 <code>size = capacity/4</code>
时再进行（此时申请 <span class="math inline">\(n/2\)</span> 的空间，并将
vector 中的数据复制过去）</p>
<h2 id="memory-safety">Memory Safety</h2>
<h3 id="c-c-memory-management-philosophy">C, C++ Memory Management
Philosophy</h3>
<ul>
<li>Developers explicitly invoke malloc/free new/delete</li>
<li>Very little overhead
<ul>
<li>free list</li>
<li><span class="math inline">\(O(1)\)</span> service time</li>
<li>No background activity</li>
<li>No runtime overhead</li>
</ul></li>
<li>Prone to bugs
<ul>
<li>use after free, double free, overflow…</li>
<li>Because the difficulty of handling memory for developers</li>
</ul></li>
</ul>
<h3 id="java-mm-philosophy">Java MM Philosophy</h3>
<ul>
<li><p>Developers do not need to take care of object lifetime</p>
<ul>
<li><p>Only explicitly new objects, no need to delete</p>
<p>只需显式申请，无需显式释放</p></li>
<li><p>No need to care about boundaries（Java
进行内存访问操作时会自动做边界检查）</p></li>
</ul></li>
<li><p>Background thread recycles memory for developers</p>
<p>Java 程序在运行时需要 runtime（运行时系统），即 JVM，而 JVM
本身也有自己的背景线程来执行内存管理（Memory
Management）。因此即使程序员编写的 Java
程序是一个单线程程序，在运行时也会是多线程运行的</p>
<p>JVM 的内存管理帮助程序员进行内存回收，但同时也存在以下缺点：</p>
<ul>
<li><p>Introduces overhead</p>
<p>内存管理本身需要需要执行更多代码并且加入更多的数据结构，因此引入更大的开销</p></li>
<li><p>Uneven request latency</p>
<p>不均匀请求延时。如对于一个服务器程序，假设一次响应请求的过程为收包（receive）、处理（process）、发包（send），那么这段时间通常是较为固定的。但使用
Java 编写的程序运行在 JVM 上，而 JVM
有时会打断程序开始执行内存回收，如果该行为发生在响应请求的过程中，则会导致该响应请求的延迟远高于正常的响应请求的过程</p></li>
</ul></li>
<li><p>Runtime VM checks boundaries for developers</p>
<ul>
<li><p>Slow down memory access</p>
<p>边界检查有时是不必要的</p></li>
</ul></li>
<li><p>Trade performance for safety</p>
<p>Java 的策略本质上是以效率换取安全的做法</p></li>
</ul>
<h2 id="java-garbage-collection">Java Garbage Collection</h2>
<ul>
<li><p>Memory should be recycled automatically</p>
<ul>
<li><p>To save memory</p></li>
<li><p>To avoid fragmentation</p></li>
</ul></li>
<li><p>Constraint</p>
<ul>
<li><p>JVM does not know which objects can be recycled.</p></li>
<li><p>For C/C++, developers invoke free/delete</p>
<p>对于 C/C++
而言，其堆管理器不会通过移动正在使用内存块的方式来优化内存碎片；并且在如下情况下：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221031184026748.png" alt="image-20221031184026748" style="zoom:80%;" /></p>
<p>即使堆顶处只有 <span class="math inline">\(1\)</span> 个 Byte
的内存块在使用，而其下的所有空间都是空闲的，C/C++
也不会移动该内存块到堆底以调用 <code>brk()</code>
释放堆顶的内存。这是因为 C/C++ 的地址是可以被显式使用的，但 C/C++
并不提供主动去修改它的功能，因此若移动内存块会导致指向该内存的指针的值变为错误的，从而可能导致很多内存错误</p></li>
</ul></li>
<li><p>How?</p>
<ul>
<li>Discovery of unreachable objects（发现不可达的对象）</li>
<li>Regard unreachable objects as free-able（裁定它们是可以被 free
的）</li>
<li>Stop the world to tidy memory（将 Java
程序所有线程停下后开始整理内存）</li>
</ul></li>
</ul>
<h3 id="high-level-idea-of-ref-count-based-gc">High level idea of ref
count based GC</h3>
<ul>
<li><p>Maintain reference counter of objects.</p>
<ul>
<li><p>Object can only be possibly recycled when no pointer
references.</p></li>
<li><p>So, instrumenting reference change, and maintain a reference
counter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A(); <span class="comment">// &lt;-ref_cnt0, ref_cnt0++</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Nulling a reference (--)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = <span class="keyword">null</span>; <span class="comment">// ref_cnt0--</span></span><br></pre></td></tr></table></figure></li>
<li><p>Reassigning a reference variable (--, ++)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A b = <span class="keyword">new</span> A(); <span class="comment">// &lt;-ref_cnt1++</span></span><br><span class="line">a = b          <span class="comment">// ref_cnt0--, ref_cnt1++</span></span><br></pre></td></tr></table></figure></li>
<li><p>Reference leaves its scope (--)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unknown</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A c = <span class="keyword">new</span> A() <span class="comment">// ref_cnt2++</span></span><br><span class="line">    g.b = a       <span class="comment">// ref_cnt2++</span></span><br><span class="line">&#125;                 <span class="comment">// ref_cnt2--</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>Stop the world to recycle zero-ref objects</p>
<p>Why stop the world (all threads)?</p></li>
<li><p>How about object array?</p></li>
</ul>
<p>注意：</p>
<ul>
<li><p>当某个对象的 <code>ref_cnt = 0</code>
时，它并不马上被删除，而是等待 JVM 在某个时间节点下开启 GC
后才对其进行处理</p></li>
<li><p>对于对象数组，其每个对象都会产生一个引用计数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A[<span class="number">10</span>] <span class="comment">// &lt;-ref_cnt0-9，ref_cnt0-9++</span></span><br><span class="line">b=a[<span class="number">5</span>]          <span class="comment">// ref_cnt5++</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="reference-count-based-gc">Reference Count based GC</h3>
<ul>
<li><p>Does zero reference equal to unreachable?</p>
<ul>
<li>If <span class="math inline">\(0\)</span> ref, the object must be
unreachable.</li>
<li>But not all unreachable objects have zero ref-count.</li>
</ul></li>
<li><p>Isolation Island Issue</p>
<ul>
<li>A pair of objects refence each other</li>
<li>So the reference count is not zero, but not reachable.</li>
<li>Reference count alone cannot recognize all free objects</li>
</ul>
<p>例如循环链表：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221031185648166.png" alt="image-20221031185648166" style="zoom:80%;" /></p>
<p>因此 Java 实际上并不使用引用计数的方法来进行内存回收</p></li>
</ul>
<h3 id="reachability-test-based-gc">Reachability Test based GC</h3>
<ul>
<li><p>Stop the world</p>
<p>So reference relationship does not change during GC</p></li>
<li><p>Test if an object is still reachable</p>
<ul>
<li><p>An object is reachable if only it is reachable from the GC
root</p></li>
<li><p>What is GC root?</p>
<p>GC root 是程序一定可达的内存部分，以下几种内存是一定可达的：</p>
<ul>
<li><p>Local objects of functions in call stack</p>
<p>调用栈中的局部变量</p></li>
<li><p>Static variables</p>
<p>静态变量的生命周期一定是贯穿整个程序运行时间的</p></li>
<li><p>Constants</p></li>
<li><p>JNI（Java Native Interface）</p>
<p>Java 调用 C/C++ 等语言写的程序的入口</p></li>
</ul></li>
</ul>
<p>其检测方法实质使用的是深搜（DFS）的方法：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221031190507507.png" alt="image-20221031190507507" style="zoom:80%;" /></p></li>
</ul>
<h2 id="gc-implementation">GC implementation</h2>
<ul>
<li><p>Mark &amp; Free：Just free the unreachable objects</p>
<p>解决内存回收：将所有不可达对象的内存清除</p></li>
<li><p>Copy：Copy all reachable objects to new heap</p>
<p>解决内存回收以及碎片化问题：将所有存活对象复制到新的内存块，原内存块全部释放</p></li>
<li><p>Mark &amp; Tidy：Free unreachable objects and defragmentation</p>
<p>解决内存回收以及碎片化问题：释放所有不可达的的对象，并将存活对象向堆底移动</p></li>
</ul>
<h3 id="java-heap-zones">Java Heap Zones</h3>
<ul>
<li><p>Eden</p>
<ul>
<li>New objects, i.e., created after last GC</li>
<li>Over 98% objects are ephemeral (will be recycled in the next GC), so
GC can recycle most of the objects in Eden zone.</li>
<li>Young GC: directly clear the zone and move remained objects to
survivor.</li>
</ul>
<p>概率模型表示通常在上一次 GC 和本次 GC
之间被创建的对象（称之为新生代）有 <span
class="math inline">\(98\)</span>% 的概率不可达从而被回收，因此 JVM
会将这 <span class="math inline">\(98\)</span>% 的内存回收，并将剩余
<span class="math inline">\(2\)</span>% 的存活对象移动到
Survivor（称之为中生代）区域</p></li>
<li><p>Survivor</p>
<ul>
<li>Objects survived from a young GC, i.e., the <span
class="math inline">\(2\)</span>% objects.</li>
<li>Split to “From” and “To” zones, to avoid fragmentation</li>
</ul>
<p>中生代区域的对象不会在每次 GC 中都被检查和清理，而是 <span
class="math inline">\(n\)</span> 次 GC
才会有一次同时对中生代对象进行检查和清理，若未被清理则拷贝至老生代区域</p></li>
<li><p>Old</p>
<ul>
<li>Moved from survivor, when the objects experienced many GC.</li>
</ul>
<p>同上，老生代区域被检查和清理的频率更加低，它们有很大的概率永远存活下去（直至进程结束）</p></li>
</ul>
<h2 id="java-gc-pros-cons">Java GC Pros &amp; Cons</h2>
<ul>
<li><p>Pros</p>
<ul>
<li><p>Totally transparent to developers</p></li>
<li><p>Strong memory safety guarantee</p>
<p>JVM developers are less prone to forget memory recycle</p></li>
<li><p>==Sometimes better performance==</p>
<p>==Objects are not recycled immediately, and may be delayed to spare
time for GC.==</p></li>
</ul></li>
<li><p>Cons</p>
<ul>
<li><p>Object copy overhead</p></li>
<li><p>Larger memory usage</p>
<p>extra data structure for counter. Delayed object recycle etc.</p>
<p>JVM（使用 C/C++ 编写）管理内存时，由于 Java 只有引用没有指针，并且
JVM
要实现拷贝内存来解决碎片化问题就要求为每个对象建立一个引用到指针的映射，即
<code>map&lt;ref, pointer&gt;</code>。那么 JVM 在进行内存整理时只需要将
<code>pointer</code>
修改即可保证程序线程重启之后引用访问内存的正确性了</p></li>
<li><p>Stop the world increases tail latency</p>
<ul>
<li><p>如何不 stop world 也能执行 GC？</p>
<p>对 <code>map&lt;&gt;</code> 加锁即可，但开销会比 GC
来得大，因此只在不能 stop world 的业务要求下使用</p></li>
<li><p>什么时候不能 stop world？</p>
<p>即对延时敏感的情况，如某个业务要求延迟不能超过 <span
class="math inline">\(10\)</span>ms，那么此时可能就不能使用 stop
world，因此 stop world
检查和清理所有内存空间的时间会比对一个内存块加锁检查的时间多得多</p></li>
</ul></li>
</ul></li>
</ul>
<h3 id="gc-misc">GC misc</h3>
<ul>
<li><p>Implicitly notify JVM to GC</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">S = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>将引用置为 <code>null</code> 可以显式通知 JVM 其所引用的对象需要被
GC。当然，此时不会马上开启 GC，但能够降低 GC 搜索难度</p></li>
<li><p>Explicitly Notification to JVMSystem.gc()</p>
<p>调用该函数能够立刻发起 JVM 执行 GC，适用于</p>
<ul>
<li>负载不均衡的场景以利用空闲时间 GC</li>
<li>在大块内存使用完毕后调用以减少内存的占用</li>
</ul></li>
<li><p>When to call destructor?</p>
<ul>
<li><p>On C++, when an object leaves its scope, or when it is
deleted</p>
<p>C++ 调用析构函数：</p>
<ul>
<li>delete（使用 <code>new</code>
在堆上开辟空间的对象：<code>A a = new A()</code>）</li>
<li>退出作用域（在栈上的对象：<code>A a = A()</code>）</li>
</ul></li>
<li><p>How about Java?</p>
<p>Java 只有在 GC
时才会调用析构函数，但有可能永远不调用析构函数（直到退出程序时），因此
Java 析构函数的调用无法预测</p></li>
</ul></li>
</ul>
<h2 id="raii-resource-acquisition-is-initialization">RAII (Resource
Acquisition Is Initialization)</h2>
<ul>
<li>Resource Acquisition Is Initialization
<ul>
<li><p>Compiler automatically recycles local variables.</p>
<p>编译器自动回收局部变量</p></li>
<li><p>So let the lifetime of objects tied with local variables</p>
<p>对象的生命期与局部变量绑定</p></li>
<li><p>Resources are released when local variables leaves it scope.</p>
<p>当局部变量离开作用域时，其资源将被释放</p></li>
</ul></li>
<li>C++ philosophy of automatic memory recycle
<ul>
<li>Basic C++ provide freedom for developers to maintain memory</li>
<li>But it is buggy prone</li>
<li>Smart pointer (RAII) helps developers automatically free
objects</li>
</ul></li>
</ul>
<h3 id="raii-naive-usage">RAII Naive Usage</h3>
<ul>
<li><p>Use local variables Only</p>
<p>So all objects can be recycled automatically</p>
<p>When adding RSP.</p></li>
<li><p>How to deal with returning object pointer (dangling pointer)?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">P* <span class="title">func</span><span class="params">()</span></span>&#123;P* p = <span class="keyword">new</span> P; <span class="keyword">return</span> p;&#125;</span><br></pre></td></tr></table></figure>
<p>Maybe caller should prepare the memory and deliver the pointer via
args.</p>
<p>因此可能会写出这种程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">P* <span class="title">func</span><span class="params">()</span></span>&#123;P p = P; <span class="keyword">return</span> &amp;p;&#125;</span><br></pre></td></tr></table></figure>
<p>但当 <code>func()</code> 函数结束后，<code>p</code>
在栈上的空间将会被释放，<code>&amp;p</code> 就是一个悬空指针（dangling
pointer）</p></li>
<li><p>How to deal with multi-thread?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P* p = <span class="keyword">new</span> P; </span><br><span class="line">    Thread* t = <span class="keyword">new</span> Thread(p);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>编译器是不感知多线程的，多线程使用库实现，但编译器不会认为调用一个
<code>pthread</code> 函数和调用其它函数有什么区别</p></li>
</ul>
<h3 id="raii-smart-pointer">RAII –Smart Pointer</h3>
<ul>
<li><p>Encapsulate a pointer in an local object.</p>
<p>将指针封装在局部对象中</p>
<ul>
<li><p>Developers no longer use normal pointers</p>
<p>开发者不再使用普通指针</p></li>
</ul></li>
<li><p>The lifetime of the local object is managed by compilers.</p>
<p>因此该局部对象就由编译器来管理</p>
<ul>
<li>The constructor and destructor of local object is automatically
called when the object leaves its scope.</li>
</ul></li>
<li><p>Use destructor to recycle memory for developers</p>
<ul>
<li>Only the smart pointer developers need to remember to release
memory</li>
<li>Normal developers do not need to care memory recycle</li>
</ul></li>
</ul>
<p>该方法的本质是利用类局部变量在退出作用域时会自动调用析构函数来自动实现管理堆上对象的生命周期</p>
<h3 id="c-smart-pointer">C++ Smart Pointer</h3>
<p>An example of self made smart pointer:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *ptr; <span class="comment">// Actual pointer</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(<span class="keyword">int</span> *p = <span class="literal">NULL</span>)</span></span>&#123; ptr = p;&#125;</span><br><span class="line">     <span class="comment">// Destructor</span></span><br><span class="line">    ~Smartptr() &#123; <span class="keyword">delete</span> (ptr); &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Overloading dereferencing operator</span></span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *ptr;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">SmartPtr <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>())</span></span>;</span><br><span class="line">    *ptr = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ptr is automatically released by destructor</li>
<li>main developers do not need to care about delete</li>
</ul>
<p>可以使用模板类方法将该智能指针类应用到所有数据类型上</p>
<p>STD 标准库提供了 Smart Pointer 类：</p>
<ul>
<li><p>unique_ptr</p>
<ul>
<li>If a unique pointer P1 is pointing to an object, only one pointer
can point this object at one time.</li>
<li>So we can’t share the object with another pointer, but we can
transfer the control to P2 by moving from P1.</li>
</ul></li>
<li><p>shared_ptr</p>
<ul>
<li>If you are using shared_ptr, then more than one pointer can point to
one object at a time</li>
<li>For each object, it maintains a Reference Counter</li>
<li>Recycle memory only when the counter is zero.</li>
</ul>
<p>然而 <code>shared_ptr</code> 无法解决循环岛问题</p></li>
<li><p>weak_ptr</p>
<ul>
<li><p>It’s much more similar to shared_ptr except it’ll not maintain a
Reference Counter.</p></li>
<li><p>So a weak_ptr may be dangling. Developers can check the validity
of a pointer by calling expired()</p>
<p>但 <code>expired()</code> 会存在线程不安全的问题，存在 TOUTTOC
问题</p></li>
</ul></li>
</ul>
<p>智能指针举例：</p>
<ul>
<li><p>unique_ptr：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;Rectangle&gt; <span class="title">P1</span><span class="params">(<span class="keyword">new</span> Rectangle(<span class="number">10</span>,<span class="number">5</span>))</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; P1-&gt;area() &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//This&#x27;ll print 50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr&lt;Rectangle&gt;P2(P1);</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Rectangle&gt; P2; </span><br><span class="line">    P2 = move(P1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This&#x27;ll print 50</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; P2-&gt;area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout&lt;&lt;P1-&gt;area()&lt;&lt;end1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>move</code> 即为将 <code>P1</code> 所指对象交给
<code>P2</code>，并销毁 <code>P1</code></p></li>
<li><p>shared_ptr：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Rectangle&gt; <span class="title">P1</span><span class="params">(<span class="keyword">new</span> Rectangle(<span class="number">10</span>,<span class="number">5</span>))</span></span>;</span><br><span class="line">    <span class="comment">//This&#x27;11 print 50</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; P1-&gt;area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    shared ptr&lt;Rectangle&gt; P2;</span><br><span class="line">    P2=P1; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// This&#x27;ll print 50</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;P2-&gt;area()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This&#x27;ll now not give an error,</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; P1-&gt;area() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// This&#x27;1l also print 50 now</span></span><br><span class="line">    <span class="comment">// This&#x27;ll print 2 as Reference Counter is 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; P1.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 <code>shared_ptr</code> 重载了 <code>=</code> 运算符，可以将
<code>P1</code> 指向的对象赋给 <code>P2</code></p></li>
</ul>
<h2 id="raii-based-memory-management-by-default">RAII based memory
management by default</h2>
<ul>
<li><p>RUST</p>
<p>Rust achieves memory safety without garbage collection.</p>
<p>rust 语言实现的实质就是使用智能指针</p></li>
<li><p>Ownership</p>
<ul>
<li>Each heap object in Rust has a variable that’s called its
owner.</li>
<li><strong>There can only be one owner at a time.</strong></li>
<li>When the owner goes out of scope, the value will be dropped
(deleted).</li>
</ul></li>
<li><p>Ownership Borrowing</p>
<ul>
<li>Borrow checker</li>
<li>You can have only one mutable reference to a particular piece of
data in a particular scope, i.e., no shared pointer.</li>
<li>Whenever a mutable borrow is active, no other borrows of the object
are active</li>
</ul>
<p>mutable 是可写的借用；而 inmutable 是只读的借用，正如 C/C++
<code>strcpy()</code> 函数的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcpy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> src)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中 <code>const char* const</code> 前一个 const
表示指针的值只读；后一个 const 表示指针指向内存的数据只读</p></li>
</ul>
<p>具体例子：</p>
<ul>
<li><p>A reference cannot be moved to another, once it loses
ownership:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br></pre></td></tr></table></figure>
<p>此时会报错，因为在执行 <code>let s2 = s1</code> 后 <code>s1</code>
的对象的所有权已经被转移给 <code>s2</code></p>
<p>以下为正确的写法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.clone();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br></pre></td></tr></table></figure>
<p>此时程序将会在内存中克隆一个完全一样的 <code>s1</code> 将其赋值给
<code>s2</code></p></li>
<li><p>Callee can borrow the ownership, by using &amp;</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> len = calculate_lenth(&amp;s1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.!&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_lenth</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>s: &amp;String</code> 中 &amp; 表示借用；若不加 &amp; 则表示
<code>move</code></p>
<p>Return ownership when calls return</p></li>
<li><p>When mutable borrowing is active, no other borrow can be
active</p>
<p>==Single mutable reference==，如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">push_all</span></span>(from: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;, to: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;)&#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> from.iter()&#123;</span><br><span class="line">        to.push(*i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    push_all(&amp;vec, &amp;<span class="keyword">mut</span> vec);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中，<code>&amp;</code> 为 immutable 的借用；<code>&amp;mut</code>
为 mutable 的借用</p>
<p>由于一个作用域中存在 mutable
的借用时就只能存在一个借用，因此上述代码会报错</p>
<p>由于该机制导致共享内存（共享内存必须可读可写）在 rust
中实现不了，因此 rust 引入了 unsafe
的机制来关闭以上特性以实现内存共享</p></li>
</ul>
<h2 id="language-based-access-control">Language Based access
control</h2>
<ul>
<li><p>Restrict developers from accessing variables or
functions</p></li>
<li><p>Private/Public /Protected C++ inheritance.</p>
<ul>
<li>Only public variables and functions are exposed to class users.</li>
<li>Only functions inside a class can access the private variables.</li>
<li>Protected inheritance</li>
</ul>
<p>成员访问权限：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Same class</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr class="even">
<td>Derived classes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr class="odd">
<td>Outside classes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>继承方式：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>公有继承</td>
<td>public</td>
<td>protected</td>
<td>不可见</td>
</tr>
<tr class="even">
<td>私有继承</td>
<td>private</td>
<td>private</td>
<td>不可见</td>
</tr>
<tr class="odd">
<td>保护继承</td>
<td>protected</td>
<td>protected</td>
<td>不可见</td>
</tr>
</tbody>
</table></li>
</ul>
<p>其中继承方式详解为：</p>
<p>公有继承（public）、私有继承（private）、保护继承（protected）是常用的三种继承方式。　　</p>
<ul>
<li><p>公有继承（public）</p>
<p>公有继承的特点是<a
href="https://so.csdn.net/so/search?q=基类&amp;spm=1001.2101.3001.7020">基类</a>的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。　　</p></li>
<li><p>私有继承（private）：默认的继承方式（如果缺省，默认为 private
继承）</p>
<p>私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。子类也不能转换成相应的基类，如果转换，会报错：“不允许对不可访问的基类进行转换”</p></li>
<li><p>保护继承（protected）</p>
<p>保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的</p></li>
</ul>
<h3 id="bypass-language-based-access-control">Bypass language based
access control</h3>
<ul>
<li><p>For C++</p>
<ul>
<li><p>Use pointer to access the private variables and function.</p>
<p>即将类指针强制类型转换为 <code>void*</code>
类型即可通过指针加减法访问类的所有成员</p></li>
<li><p>Notice the this argument of member functions</p>
<p>通过某种方法得到 <code>this</code>
指针也可以访问类的所有成员</p></li>
</ul></li>
<li><p>For Java</p>
<ul>
<li>Use reflection to access（反射技术）</li>
</ul></li>
</ul>
<h2 id="dimensions-levels-of-safety">Dimensions &amp; levels of
safety</h2>
<ul>
<li><p>There are many dimensions of safety</p>
<p>memory-safety, type-safety, thread-safety, arithmetic safety,
guarantees about (non)nullness, about immutability, about the absence of
aliasing,...</p>
<p>thread-safety：如 Javascript，为了实现线程安全，其 runtime
是单线程的</p>
<p>absence of aliasing：禁止别名对程序分析有好处</p></li>
<li><p>For some dimensions, there can be many levels of safety</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221031202422291.png" alt="image-20221031202422291" style="zoom:80%;" /></p></li>
</ul>
<p><strong>扩展：</strong>eBPF</p>
<p>eBPF（extended Berkeley Packet Filter）是一种可以在 Linux
内核中运行用户编写的程序，而不需要修改内核代码或加载内核模块的技术，其让
Linux 内核变得可编程化了。eBPF 程序采用 C 语言编写，并可以通过 clang
编译成目标文件 —— eBPF 字节码。对于程序而言 eBPF
相当于虚拟机，其会通过验证器验证要嵌入内核的程序，确保其不会导致内核崩溃或无限执行下去等</p>
<p>例如 wireshark 应用的编写就利用了 eBPF。wireshark
可以抓取所有网络中的包，但一个非特权程序显然是不允许抓取所有的包的，而只能开一个
socket 进行收发包的操作</p>
]]></content>
  </entry>
  <entry>
    <title>Race Condition</title>
    <url>/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.3.1%20Race%20Conditions/</url>
    <content><![CDATA[<h1 id="race-condition">Race Condition</h1>
<p><strong>数字电路中的竞争与冒险</strong></p>
<p><strong>竞争：</strong></p>
<p>竞争（Competition）定义为：在组合逻辑电路中，某个输入变量通过两条或两条以上的途径传到输出端，由于每条途径的延迟时间不同，到达输出门的时间就有先有后，这种现象称为竞争。把不会产生错误输出的竞争的现象称为非临界竞争。把产生暂时性的或永久性错误输出的竞争现象称为临界竞争</p>
<p>一个竞争的例子如图所示。图中的输入信号经过了两个不同的路径，因为处理及布线延时的缘故，不同路径的有效输出信号（对应路径
<span class="math inline">\(1\)</span> 命名为输出 <span
class="math inline">\(1\)</span>，对应路径 <span
class="math inline">\(2\)</span> 命名为输出 <span
class="math inline">\(2\)</span>。图中假设两个输出的理论输出都是从
“<span class="math inline">\(0\)</span>” 到 “<span
class="math inline">\(1\)</span>” 的变化）的时间可能是不同的</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\2e5f815c7b504cf69353e089b5b8d7d6-16659979117643.png" alt="2e5f815c7b504cf69353e089b5b8d7d6" style="zoom:80%;" /></p>
<p><strong>冒险：</strong></p>
<p>冒险（Risk）定义为：信号在器件内部通过连线和逻辑单元时，都有一定的延时，延时的大小与连线的长短和逻辑单元的数目有关，同时还受器件的制造工艺、工作电压、温度等条件的影响。信号的高低电平转换也需要一定的过渡时间。由于存在这两方面因素，多路信号的电平值发生变化时，在信号变化的瞬间，组合逻辑的输出有先后顺序，并不是同时变化，往往会出现一些不正确的尖峰信号，这些尖峰信号称为<strong>毛刺</strong>。如果个组合逻辑电路中有‘毛刺’出现，就说明该电路存在冒险</p>
<p>图中的两个输入信号，经过了两个不同的路径，因为处理及布线延时的缘故，对于器件的有效输入信号的时间可能是不同的。器件进行处理获得的输出（假设理论上的输出应该保持
“<span class="math inline">\(0\)</span>”
不变）产生了预料之外的、急风暴雨般的 “<span
class="math inline">\(1\)</span>”。这个短时的高电平就是所谓的毛刺</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\868220a1f57d4e2a8fb83b65e023c6ab.png" alt="868220a1f57d4e2a8fb83b65e023c6ab" style="zoom:80%;" /></p>
<h2 id="parallel-computing">Parallel Computing</h2>
<h3 id="并行计算">并行计算</h3>
<p>比数字电路更高层的竞争：并行计算</p>
<ul>
<li><p>多任务处理</p>
<p>现代操作系统多支持多任务处理（无论 CPU 是单核还是多核；无论是多个 CPU
还是单个 CPU）</p></li>
<li><p>多线程</p>
<ul>
<li><p>一个任务可以被拆分成多个小任务并行地处理</p></li>
<li><p>与多进程区别：</p>
<p>资源共享：内存（每个线程有自己的栈，但堆是共享的）、文件描述符等，因此能比多进程有更小的开销</p></li>
<li><p>单核 CPU 还有必要使用多线程吗？</p>
<p>取决于业务需求，如在线听歌软件至少有两个任务：下载和播放，若使用单线程则必须等待下载完才能播放，此时用户体验很差</p></li>
</ul></li>
<li><p>SIMT (Single Instruction Multiple Thread)</p>
<p>GPU 使用的并行计算方式</p></li>
</ul>
<h3 id="调度">调度</h3>
<p><strong>抢占式</strong></p>
<ul>
<li>优点：
<ul>
<li>低延迟（任务第一次被执行时间短）</li>
<li>公平</li>
</ul></li>
<li>缺点：
<ul>
<li>高开销（时钟中断时的处理）</li>
<li>复杂的调度逻辑</li>
</ul></li>
</ul>
<p><strong>协作式</strong></p>
<h2 id="race-condition-1">Race Condition</h2>
<h3 id="java-case">Java Case</h3>
<p>当 <code>balance</code> 值为 <span class="math inline">\(0\)</span>
时，存在两个线程同时运行 <code>adjustBalance()</code>
函数时会发生什么情况？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BankAccount</span><span class="params">(<span class="keyword">int</span> initialBalance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(initialBalance &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span></span><br><span class="line">                    IllegalArgumentException(<span class="string">&quot;initial balance must be &gt;= 0&quot;</span>);</span><br><span class="line">        balance = initialBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjustBalance</span><span class="params">(<span class="keyword">int</span> adjustment)</span></span>&#123;</span><br><span class="line">        balance = balance + adjustment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JVM 为基于堆栈实现，对于 Java
语句：<code>balance = balance + adjustment</code>，Java 字节码（byte
code）如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjustBalance</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  Code:</span><br><span class="line">     <span class="number">0</span>: aload_0        <span class="comment">// push address of this object</span></span><br><span class="line">     <span class="number">1</span>: aload_0        <span class="comment">// and again</span></span><br><span class="line">     <span class="number">2</span>: getfield  #<span class="number">14</span>  <span class="comment">// fetch field balance</span></span><br><span class="line">     <span class="number">5</span>: iload_1        <span class="comment">// first argument:adjustment</span></span><br><span class="line">     <span class="number">6</span>: iadd           <span class="comment">// top of stack this.balance adjustment</span></span><br><span class="line">     <span class="number">7</span>: putfield  #<span class="number">14</span>  <span class="comment">// store in field balance</span></span><br><span class="line">    <span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>其中使用到的字节码功能如下：</p>
<ul>
<li><code>aload_n</code>：将局部变量表中下标为 <span
class="math inline">\(n\)</span> 的引用数据类型变量压入操作数栈中</li>
<li><code>getfiled #n</code>：将栈顶的对象引用出栈，并取出该对象的字段（或成员变量，此处为
<code>balance</code>）送入栈中，<span class="math inline">\(n\)</span>
表示该字段名称在 <code>.class</code> 常量池中的位置</li>
<li><code>iload_n</code>：从局部变量表中取出编号为 <span
class="math inline">\(n\)</span> 的局部变量送入栈中</li>
<li><code>iadd</code>：取出栈顶的两个数据相加后送回栈中</li>
<li><code>putfield #n</code>：先后将栈顶的数据，对象引用出栈，将数据存储给对象的某个字段，<span
class="math inline">\(n\)</span> 表示该字段名称在 <code>.class</code>
常量池中的位置</li>
<li><code>return</code>：返回</li>
</ul>
<p>用一段伪代码表示就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">temp = balance;</span><br><span class="line">temp = temp + adjustment;</span><br><span class="line">balance = temp</span><br></pre></td></tr></table></figure>
<p>假设 <code>balance</code> 初始值为 <span
class="math inline">\(3\)</span>，并且有两个线程会分别执行
<code>adjustBalance(5), adjustBalance(6)</code>，那么显然执行完毕后
<code>balance</code> 的值可能是：<span class="math inline">\(8, 9,
14\)</span></p>
<p><strong>但是，会有可能存在无中生有吗？</strong></p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221017200837328.png" alt="image-20221017200837328" style="zoom:80%;" /></p>
<p>假设初始值为 <span class="math inline">\(0\)</span>，那么
<code>x</code> 的值可能为 <span class="math inline">\(42\)</span></p>
<p>问题是，为什么编译器会添加一个 <span
class="math inline">\(42\)</span> 的值到代码中呢？</p>
<p>假设源代码为如下情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">y = stat1(...);</span><br><span class="line">z = stat2(y);</span><br></pre></td></tr></table></figure>
<p>假如编译器认为 <code>stat1(...)</code>
的执行时间将很长，那么编译器可能对其进行优化：先行预测
<code>stat1(...)</code> 的值，如预测为 <span
class="math inline">\(42\)</span>。此时将打破 <code>y, z</code>
变量之间的数据依赖，这就为 CPU 并行执行
<code>stat1(...), stat2(y)</code> 创造了可能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">y = <span class="number">42</span>;</span><br><span class="line">r1 = stat1(…);</span><br><span class="line"><span class="keyword">if</span> r1 != <span class="number">42</span>    <span class="comment">// Given high chances are stat1() = 42</span></span><br><span class="line">    y = r1;</span><br><span class="line">r2 = stat2(y);</span><br></pre></td></tr></table></figure>
<p>假设在多次执行后 CPU 认为如上 <code>if</code> 分支大概率不执行，则
CPU 就会对 <code>stat1(...), stat2(y)</code>
进行并行执行，因此可能导致无中生有的出现</p>
<h4 id="defense---adding-locks">Defense - Adding Locks</h4>
<h3 id="consequence-of-race">Consequence of Race</h3>
<p><strong>竞争冒险经常发生吗？</strong></p>
<ul>
<li>通常而言，竞争很少会发生（因为一般而言会导致竞争的代码很短，CPU
很快就能执行完毕，因此概率很小）。并且即使它发生了，通常也只是导致数据错误</li>
<li>但对于攻击者，攻击者可以利用 fengshui
等手段使一个小概率事件以较大概率发生，并且导致一个不局限于数据错误的结果</li>
</ul>
<p><strong>可能的结果</strong></p>
<ul>
<li>TOCTTOU</li>
<li>Dirty COW</li>
</ul>
<h4 id="tocttou">TOCTTOU</h4>
<p>TOCTTOU（time of check and the time of
use）：即代码先检查某个前置条件（例如认证），然后基于这个前置条件进行某项操作，但是在检查和操作的时间间隔内条件却可能被改变，如果代码的操作与安全相关，那么就很可能产生漏洞。这种安全问题就被称做
TOCTTOU</p>
<p>lpr -r</p>
<p>在以前的 Unix 系统中</p>
<p>mkdir</p>
<p><strong>参考资料：</strong><a
href="https://blog.csdn.net/u013178472/article/details/112302791">关于TOCTTOU攻击的简介_hututu_404的博客-CSDN博客_toc
tou</a></p>
<h4 id="defense">Defense</h4>
<ul>
<li><p>Using fd instead of pathname</p>
<p>使用路径名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stat(<span class="string">&quot;/tmp/bob&quot;</span>, &amp;sb);</span><br><span class="line">...</span><br><span class="line">stat(<span class="string">&quot;/tmp/bob&quot;</span>, &amp;sb);</span><br></pre></td></tr></table></figure>
<p>使用文件描述符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/tmp/bob&quot;</span>, O_RDWR);</span><br><span class="line">fstat(fd, &amp;sb);</span><br><span class="line">...</span><br><span class="line">fstat(fd, &amp;sb);</span><br></pre></td></tr></table></figure>
<p>可知用文件名来表示文件是会存在多义性的，每次用相同文件名处理的文件不一定相同；而一个进程持有的文件描述符能够唯一地指向一个文件，该进程对这个文件的处理都会执行到文件描述符所指向的文件</p></li>
<li><p>Using APIs that combine <strong>test-and-get</strong></p></li>
<li><p>Using Locks</p>
<ul>
<li><p>在 Java 中，锁是通过 <code>synchronized</code>
语句来实现的，设有如下一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String myName <span class="string">&quot;Jimoer&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (myName)&#123;</span><br><span class="line">            System.out.println(myName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *synchronized使川在静态方法上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System,out.println(<span class="string">&quot;I am testl method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其 Bytecode 为：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\图片1-16770680558921.png" alt="图片1" style="zoom: 33%;" /></p>
<p>其中 <code>monitorenter</code> 和 <code>moniterexit</code>
可以看作是申请锁和释放锁，但注意到在该段 Bytecode 中只有一个
<code>monitorenter</code>，却有两个 <code>moniterexit</code>。并且第
<span class="math inline">\(17\)</span> 行的 <code>goto</code>
好像保证了第二个 <code>moniterexit</code> 永远不会被触发。实际上这是为了
Java 的 catch error 机制所增加的</p>
<p>注意到该段 Bytecode 下方的 Exception table，其表示从 from 行到 to
行如果出现错误，就跳转到 target 行去处理。因此可以注意到 Exception table
的第一行：从第 <span class="math inline">\(6\)</span> 行到第 <span
class="math inline">\(17\)</span> 行出现的错误都会跳转到第 <span
class="math inline">\(20\)</span> 行去执行，这恰好是在
<code>goto 25</code> 的后一句 Bytecode。故第二个
<code>moniterexit</code> 实际上是为了保证 Java
在进行错误处理时能够把申请的锁释放掉，保证其它线程不因为一个线程的错误而永远拿不到锁导致了无法执行下去</p></li>
<li><p>在 C/C++ 中锁的实现：</p>
<p>Lock variable</p>
<p>Bool type: <span class="math inline">\(0\)</span> for unlocked, <span
class="math inline">\(1\)</span> for locked</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock:</span><br><span class="line">mov eax, 1</span><br><span class="line">Loop:</span><br><span class="line">xchg eax [locked]                       # xchg: atomic exchange</span><br><span class="line">test eax eax</span><br><span class="line">jnz Loop</span><br></pre></td></tr></table></figure>
<p>在 C/C++ 中锁的实现依赖于原子的指令 <code>xchg</code></p></li>
</ul></li>
</ul>
<h2 id="instruction-atomicity">Instruction Atomicity</h2>
<ul>
<li>How CPU makes sure the instruction is atomic?
<ul>
<li>CPU cores run coherence protocol. E.g., MESI 缓存一致性协议</li>
<li>To make sure that all core keep the same value for the same cache
line.</li>
<li>At one time, only one core (M or E state) can modify a cache
line.</li>
</ul></li>
<li>All cores maintain a state machine</li>
</ul>
<p>Cacheline Lock 就是通过 MESI 协议实现的，而 <code>xchg</code>
等原子指令则依赖于 Cacheline Lock，因此 MESI 对于原子指令十分重要</p>
<p>MESI 分别表示 Cacheline 的四种状态：</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 45%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">状态</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">监听任务</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">M：Modified</td>
<td
style="text-align: center;">该缓存行有效，数据被修改了，和内存中的数据不一致，数据只存在于本缓存行中</td>
<td
style="text-align: center;">缓存行必须时刻监听所有试图读该缓存行相对应的内存的操作，其他缓存须在本缓存行写回内存并将状态置为
E 之后才能操作该缓存行对应的内存数据</td>
</tr>
<tr class="even">
<td style="text-align: center;">E：Exclusive</td>
<td
style="text-align: center;">该缓存行有效，数据和内存中的数据一致，数据只存在于本缓存行中</td>
<td
style="text-align: center;">缓存行必须监听其他缓存读主内存中该缓存行相对应的内存的操作，一旦有这种操作，该缓存行需要变成
S 状态</td>
</tr>
<tr class="odd">
<td style="text-align: center;">S：Shared</td>
<td
style="text-align: center;">该缓存行有效，数据和内存中的数据一致，数据同时存在于其他缓存中</td>
<td
style="text-align: center;">缓存行必须监听其他处理器修改该缓存行相对应的本地缓存行的操作，一旦有这种操作，该缓存行需要变成
I 状态</td>
</tr>
<tr class="even">
<td style="text-align: center;">I：Invalid</td>
<td style="text-align: center;">该缓存行数据无效</td>
<td style="text-align: center;">无</td>
</tr>
</tbody>
</table>
<p><strong>参考资料：</strong><a
href="https://blog.csdn.net/denglin12315/article/details/122639341">缓存一致性协议(MESI)——缓存加锁协议_denglin12315的博客-CSDN博客</a></p>
<h2 id="intel-tsx">Intel TSX</h2>
<ul>
<li>CPU may not honestly get the lock.</li>
<li>You may ask CPU to use speculative execution.</li>
</ul>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\图片3-16770735254545.png" alt="图片3" style="zoom: 67%;" /></p>
<p>即 CPU 在遇到无法拿到锁的情况时可能继续执行临界区代码，但可能中途
abort：</p>
<ul>
<li>数据冲突，即内存等发生了更新</li>
<li>硬件（hardware，HW）资源受限，此时必然将硬件资源让给合法进行的指令</li>
<li>出现 bug 或执行错误</li>
</ul>
<p>此时，</p>
<ul>
<li>一旦 aborted 就返回重新尝试执行</li>
<li>若执行完后锁还是被占用则重新执行</li>
<li>若多次尝试不成功则全力竞争锁</li>
</ul>
<h2 id="linux">Linux</h2>
<h3 id="setuid">setuid</h3>
<h4 id="ruid-和-euid">ruid 和 euid</h4>
<ul>
<li>ruid（real user ID）：即当前执行该文件/程序的用户</li>
<li>euid（effective user ID）：当进程执行时，操作系统会对 euid
进行识别，以此来判断到底用什么权限来执行这个进程。即操作系统实际上是通过判断进程的
euid 而非 ruid 来给予权限的</li>
</ul>
<p>而 setuid 就是类 Unix
系统提供的一个标志位，其实际意义为设置一个进程的 euid
为这个可执行文件或程序的拥有者（如 root）的 uid。即当 setuid
位被设置之后，当文件或程序被执行时，操作系统会赋予进程<strong>文件所有者的权限</strong></p>
<p><strong>注意：</strong>ruid，euid，setuid
都是对文件的可执行权限而言的。即 setuid
并不会对读写权限生效，即使将某文件的 euid
设置为所有者权限也不会改变其它用户在为获取权限的情况下对其的读写权限</p>
<h4 id="文件权限">文件权限</h4>
<p>在命令行窗口下输入 <code>ls -l</code>
命令可以看到文件夹下文件的各种信息，如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x 2 root      root      4096 10月 18 09:14 assd</span><br></pre></td></tr></table></figure>
<p>其中前十个字符表示的是文件类型和权限：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221018094610035.png" alt="image-20221018094610035" style="zoom:80%;" /></p>
<p>其中，</p>
<ul>
<li>文件类型：<code>d</code> 表示文件夹（directory）；<code>l</code>
表示软链接文件（symlink）；<code>-</code> 表示普通文件</li>
<li>权限：<code>r</code> 表示读权限；<code>w</code>
表示写权限；<code>x</code> 表示执行权限。除此之外还可能存在
<code>s, S</code> 标志，其与 setuid 位有关</li>
</ul>
<h4 id="setuid-与-chmod">setuid 与 chmod</h4>
<p>setuid 的方法是使用 Linux 的 <code>chmod</code>
指令，我们都习惯给予一个文件类似 “<span
class="math inline">\(0750\)</span>” “<span
class="math inline">\(0644\)</span>” 之类的权限，它们的最高位 <span
class="math inline">\(0\)</span> 就是 setuid 的位置,
我们可以通过将其设为 <span class="math inline">\(4\)</span> 来设置
setuid 位（设置为 <span class="math inline">\(2\)</span> 为 setgid，同
setuid 类似，即赋予文件所在组的权限）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ chmod 4750 filename</span><br></pre></td></tr></table></figure>
<p>这个命令执行之后再次通过 <code>ls -l</code>
命令查看文件可以发现文件的所属者权限的 <code>x</code> 位变为了
<code>s</code>，这就说明 setuid 权限已经被设置， 之后任何 user
执行这个文件时（user 需要有文件的执行权限）， 都会以 root
的权限运行（假设此文件的所属者为 root）。 所以，针对一个需要被很多 user
以 root 权限执行的文件， 我们可以通过 setuid 来进行操作，
这样就不必为所有 user 都添加 <code>sudo</code> 命令</p>
<p>而 <code>S</code>
标志是当所属者权限无可执行权限时出现的，即当所属者可执行权限为
<code>-</code> 时，再使用 setuid 方法就会使 <code>-</code> 变为
<code>S</code>， 这说明setuid位没有被设置成功</p>
]]></content>
  </entry>
  <entry>
    <title>Transient Execution</title>
    <url>/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.8%20Transient%20Execution/</url>
    <content><![CDATA[<h1 id="transient-execution">Transient Execution</h1>
<h2 id="cpu">CPU</h2>
<h3 id="out-of-order">Out-of-Order</h3>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221121183641564.png" alt="image-20221121183641564" style="zoom:80%;" /></p>
<p>现代 CPU 在执行指令时可以乱序执行以增加执行效率，其意义在于：</p>
<p>现代 CPU 都采用流水线模式，这就会出现</p>
<ul>
<li><p>数据冒险，其造成了指令间的依赖关系。如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov %rax, 0(%rbx)</span><br><span class="line">add %rax, %rcx</span><br></pre></td></tr></table></figure>
<p>其中在执行 <code>add %rax, %rcx</code> 时 <code>%rax</code>
的值依赖于前一条 <code>mov</code> 指令将内存中的数据存储到
<code>%rax</code> 中。因此 <code>add</code> 指令在执行到 ALU
部分时至少要等到 <code>mov</code> 指令取出的数据加载到 <code>%rax</code>
中才能继续执行 <code>add</code> 指令。在等待时会插入 <code>nop</code>
指令什么也不做，因此效率就降低了</p>
<ul>
<li>处理数据冒险可采用转发提早将数据送回依赖的元件</li>
</ul></li>
<li><p>控制冒险</p>
<p>不仅包括分支的选择执行，还包括了一些内存访问操作的权限延迟检查</p>
<ul>
<li>通常采用预测执行的方法</li>
<li>对于权限检查而言，CPU 总是假设检查能够通过</li>
</ul></li>
<li><p>元件冒险</p>
<p>现代 CPU
中由于存在并行执行的操作，因此可能存在两条指令在同一时刻需要使用同一元件，因此会产生该问题，但通常解决方式很简单：</p>
<ul>
<li>增加元件数量</li>
</ul></li>
</ul>
<p>因此 CPU 对将要执行的指令进行合理的乱序执行可以令</p>
<ul>
<li>某些不存在依赖关系的指令并行执行</li>
<li>某些存在依赖关系的指令中的被依赖指令执行依赖指令依赖的数据后再去执行依赖指令</li>
<li>资源利用率更高（元件冒险）</li>
</ul>
<p>来减少插入的 <code>nop</code> 指令的数量，以此提高性能</p>
<h3 id="skylake-block-diagram">Skylake Block Diagram</h3>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\skylake_block_diagram.png" alt="skylake_block_diagram" style="zoom:80%;" /></p>
<p>Intel Skylake 是 Intel 第六代微处理器架构</p>
<h4 id="front-end">1. Front End</h4>
<p>注意前端（Front End）架构</p>
<ul>
<li><p>Instruction Fetch &amp; Predecode：</p>
<ul>
<li>该元件将汇编代码进行 (Pre-)Decode，并且可以同时 (Pre-)Decode
多条汇编指令</li>
<li>在 Decode 之后其可以同时输出 <span class="math inline">\(6\)</span>
条汇编指令</li>
</ul></li>
<li><p><span class="math inline">\(4\)</span>-Way Decode：</p>
<ul>
<li><p>从 Instruction Queue 中取出之前 Predecode 的指令再 Decode
一次，这一次是将 CISC 的复杂指令 Decode
为了一系列的微指令，例如假设有这么一条指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, [ebx + ecx * 4 + 8] </span><br></pre></td></tr></table></figure>
<p>其作用为将地址为 <code>ebx + ecx * 4 + 8</code> 的内存中的数据送入
<code>eax</code>，那么该指令在 CPU
具体执行时肯定不是按一条指令执行的，而是拆分为多条微指令来执行的。但是这条指令却可以由汇编给出</p></li>
</ul></li>
</ul>
<p>因此，CISC 的概念只是指汇编指令架构，CPU 在真正执行之前需要 Decode
两次：</p>
<ul>
<li>对上层：提供 CISC 的汇编指令（考虑兼容性，只增不减，因此只要使用
<code>x86</code> 架构指令集编写的程序到今天还可以运行），Decode CISC
指令</li>
<li>对下层：将 Decode 之后的指令再次 Decode 为微指令</li>
</ul>
<p>这样做的好处在于：底层的微指令可以根据 CPU
架构的变化而变化从而来压榨出硬件的最大性能，同时还能够保证对上层程序的兼容性</p>
<p>并且，多一次 Decode
的开销并不会很大，因为影响性能的关键是一个程序中的循环体里的代码（或递归部分代码，即重复执行的代码），而这些代码只需要完整地
Decode 一次（此处指 Predecode + Decode）就可以一直执行</p>
<h4 id="execution-engine">2. Execution Engine</h4>
<p>执行引擎中，</p>
<ul>
<li><p>Scheduler：</p>
<p>图中说明 Scheduler 共有 <span class="math inline">\(97\)</span> 个
Entries，这说明其最多可以同时处理 <span
class="math inline">\(97\)</span> 条指令，可见现代 CPU
并行处理能力之强</p></li>
<li><p>Physical Register：</p>
<p>x<span class="math inline">\(86\)</span>-<span
class="math inline">\(64\)</span> 架构的 CPU 一共只有 <span
class="math inline">\(16\)</span> 个通用寄存器，但物理寄存器共有 <span
class="math inline">\(180\)</span> 个</p></li>
<li><p>EUs：</p>
<p>注意到其中的每个 Port
中都有大量的处理元件，这是指令并行执行的关键</p></li>
<li><p>Rename/ Allocate/ Retirement：</p>
<p>其中 Rename 表示寄存器重命名</p></li>
<li><p>Register Alias Table（RAT）：</p>
<p>RAT 中记录了物理寄存器与逻辑寄存器之间的映射</p></li>
</ul>
<h3 id="speculative-execution">Speculative Execution</h3>
<p>How to be even more out of order?</p>
<ul>
<li><p>Multiple-Issue</p>
<ul>
<li><p>Decode multiple instructions at one clock (Super Scalar),</p>
<p>尽可能在一个时钟内增加 Decode 量，这样调度可以更好地执行</p></li>
<li><p>when there is no conflict, they can be dispatched to different
back-end</p></li>
</ul></li>
<li><p>Resolve all kinds of conflict</p>
<p>解决冲突</p>
<ul>
<li><p>Register conflict: RAW, WAR, WAW, RAR √. (Register Renaming)</p>
<ul>
<li><p>RAW：Read After Write</p>
<p>显然 RAW 中 Read 不能和 Write
乱序，因此只需解决数据冒险即可，若会发生数据冒险则采用广播（转发）的方法</p></li>
<li><p>WAR：Write After Read</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read R1</span><br><span class="line">...</span><br><span class="line">write R1</span><br></pre></td></tr></table></figure>
<p>注意一个要点，当某个寄存器 reg
被写入数据时（不包括运算指令，单纯指类似 <code>mov</code>
的指令），说明此时该寄存器的数据是全新的，它并不对前面的任何关于 reg
的指令有任何依赖</p>
<p>也就是说，<code>write R1</code> 本质上可以和 <code>read R1</code>
并行执行甚至乱序执行，但要解决 <code>read R1</code> 的结果不受
<code>write R1</code> 影响这一问题。注意到上图 Skylake 寄存器提供了
<span class="math inline">\(180\)</span>
个物理通用寄存器，假设这些物理寄存器编号分别为
<code>F0, F1, ...</code>，那么我们只需要将两个 <code>R1</code>
替换为不同的物理寄存器即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read R1 -&gt; F3</span><br><span class="line">...</span><br><span class="line">write R1 -&gt; F4</span><br></pre></td></tr></table></figure>
<p>此时读写就可以打破依赖从而乱序执行了</p></li>
<li><p>WAW：Write After Write</p>
<p>与 RAW 相同，两次 <code>write</code>
之间是不存在依赖关系的，因此可以使用寄存器重命名</p></li>
<li><p>RAR：Read After Read</p></li>
</ul></li>
<li><p>ALU conflict: add more ALUs</p></li>
</ul>
<p>这些情况都将在 CPU Decode
时进行处理，根据指令间的依赖关系绘制出控制流图（Control Flow
Graph，CFG），之后调度器根据 CFG 进行指令间的调度</p></li>
<li><p>Branch Prediction</p>
<ul>
<li>Predict if a conditional jump really jumps</li>
<li>Predict the destination of indirect jump</li>
</ul></li>
<li><p>Cache pre-fetch</p>
<p>预取高速缓存。当内存访问指令的地址已经被计算出来且将要被访问时，如
<code>0x500</code>，那么 CPU 会把 <code>0x500</code> 先读取到 Cache
里，之后的访问速度就很快了</p>
<ul>
<li>Predict what memory will be accessed</li>
</ul></li>
</ul>
<p>然而这些方案都会导致某些安全问题</p>
<h2 id="meltdown">Meltdown</h2>
<h3 id="bypass-page-property-check">Bypass page property check</h3>
<ul>
<li><p>Every time an address is accessed, CPU MMU maps virtual address
to physical address</p>
<p>当有内存访问指令时，CPU 会先对已经计算出的地址进行翻译并将页表项 load
到 TLB 中，但这个过程不会对其进行安全性检查</p></li>
<li><p>MMU uses TLB to cache page table entries (mappings)</p></li>
<li><p>Security Check was done later</p>
<p>安全性检查在真正执行到该条指令时才会进行</p>
<ul>
<li><p>To make it more out-of-order</p>
<p>为什么能使乱序执行更加<strong>乱</strong>？</p></li>
</ul></li>
<li><p>If later check fails, roll back</p>
<ul>
<li>Not all components needs roll back</li>
<li>E.g., cache</li>
</ul>
<p>当进行安全性检查时，若不通过则 CPU
会回滚，但不是所有数据都能回滚，事实上大部分数据没办法回滚，例如
Cache、Heap、(Sometimes) Stack</p>
<p>对于 Stack：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221121233914046.png" alt="image-20221121233914046" style="zoom:80%;" /></p>
<p>显然此时回滚后只需把 <code>Callee</code> 的数据丢弃即可，Stack
可以回滚到原状态。但是若是出现修改了 <code>rsp</code>
之前的数据的行为：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221121234139048.png" alt="image-20221121234139048" style="zoom:80%;" /></p>
<p>那此时也和 Heap 一样无法回滚了</p>
<p>这是因为在修改覆盖这些数据时没有备份，同时也没有回滚的操作；而对于寄存器来说是有相应的备份和操作的</p></li>
</ul>
<h3 id="meltdown-1">Meltdown</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Try&#123;</span><br><span class="line">    xor eax, eax </span><br><span class="line">    movb al, [x]</span><br><span class="line">    mov ecx, [ebx + 4 * eax] # ebx: int a[256];</span><br><span class="line">&#125;catch(e)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>令 <code>x</code> 为内核地址，如 <code>0xf0000000</code></li>
<li>假设 <code>[0xf0000000] = 84</code>，并且是用户不可访问的</li>
<li><code>a[84]</code> 会被暂时性地存入
<code>ecx</code>，但在此之后会被回滚</li>
</ul>
<p>注意，这个时候</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movb al, [x]</span><br><span class="line">mov ecx, [ebx + 4 * eax] # ebx: int a[256];</span><br></pre></td></tr></table></figure>
<p>两条指令是会发生乱序执行的，这就是安全性检查推迟带来的结果，其中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movb al, [x]</span><br></pre></td></tr></table></figure>
<p>这条指令存在 <span class="math inline">\(2\)</span> 个过程：</p>
<ul>
<li><p>将 <code>[x]</code> 数据对应的页表项 load 到 TLB 中；将
<code>[x]</code> 数据 load 到 Cache 中（注意 Cache
很小，其单位不是页，通常 L<span class="math inline">\(1\)</span> Cache
一个单位只有 <span class="math inline">\(64\)</span> Bytes）。同时 CPU
假设权限检查能够通过，因此会将 <code>[x]</code> 指向的数据先转发给</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ecx, [ebx + 4 * eax] </span><br></pre></td></tr></table></figure>
<p>这条指令相应需要 <code>eax</code> 数据的过程中（如 ALU）</p></li>
<li><p>真正执行将 <code>[x]</code> 内容 load 到 <code>al</code>
中的过程，此时才会进行安全性检查</p></li>
</ul>
<p>此时只需要 <code>ebx + 4 * eax</code> 的值计算出来后将
<code>[ebx + 4 * eax]</code> 的数据相应页表项 load 到 Cache 和 TLB
中，无论</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ecx, [ebx + 4 * eax] </span><br></pre></td></tr></table></figure>
<p>是否真的把数据 load 到 <code>ecx</code> 中都无所谓了</p>
<p>也就是说可以视为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ecx, [ebx + 4 * eax] </span><br></pre></td></tr></table></figure>
<p>有 <span class="math inline">\(3\)</span> 个过程：</p>
<ul>
<li>计算 <code>ebx + 4 * eax</code></li>
<li>第二、三过程与 <code>movb al, [x]</code> 指令相同</li>
</ul>
<p>只需要 <code>mov ecx, [ebx + 4 * eax]</code> 这条指令的第一、二过程在
<code>movb al, [x]</code>
的安全性检查执行完毕之前执行完，攻击即为成功。这个时候
<code>a[84]</code> 已经在 Cache 中了</p>
<h4 id="another-thread">Another Thread</h4>
<p>此时攻击者只需再开另外一个线程执行下列代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    s = time();</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">    e = time();</span><br><span class="line">    <span class="built_in">printf</span>(e-s);</span><br></pre></td></tr></table></figure>
<p>就可以得到访存指令所需时间：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221121233409918.png" alt="image-20221121233409918" style="zoom:80%;" /></p>
<p>很显然可以发现对于 <code>a[84]</code> 来说访问速度格外地快，说明
<code>a[84]</code> 就是在之前我们利用访存乱序执行 load 到 Cache
中的内存数据。因此根据访问速度异常快的数组的下标我们就可以很容易地知道
<code>0xf0000000</code> 中存储的数据是什么了</p>
<p>该攻击方式相当于一次任意读，只需将内核中存储的用户密码读取出来即可实现提权</p>
<h4 id="memory-access-granularity">Memory Access Granularity</h4>
<p>当然该攻击可能还存在一些问题：</p>
<p>if <code>a[84]</code> is accessed, <code>a[85], a[86], …</code> are
all faster</p>
<p>Because:</p>
<ul>
<li>CPU cache not only a dword, but a cache line
<ul>
<li>a cache line may contain <span class="math inline">\(64\)</span>
bytes for most recent Intel processors.</li>
</ul></li>
<li>CPU may prefetch multiple lines
<ul>
<li>If <code>a[x]</code> is accessed, there are chances that
<code>a[x+1] … a[x+16]</code> will be accessed later</li>
<li>If prediction is correct, later access can be faster.</li>
<li>If prediction is wrong, only cache &amp; memory bandwidth is
wasted.</li>
</ul></li>
</ul>
<p>为了解决该问题，可以开一个很大的数组，如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[<span class="number">256</span> &lt;&lt; <span class="number">12</span>]; <span class="comment">// 2^12 Bytes = 4 KB</span></span><br></pre></td></tr></table></figure>
<p>并且在访问时使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[i + (<span class="number">1</span> &lt;&lt; <span class="number">12</span>)];</span><br></pre></td></tr></table></figure>
<p>而 Cache 的一个单位的大小（Cache Line）是永远不可能达到 4K
的，因此可以解决上述问题</p>
<h3 id="defense-meltdown">Defense-Meltdown</h3>
<h4 id="kernel-page-table-isolation">Kernel page-table isolation</h4>
<ul>
<li><p>Kernel and user mode do not share page table</p>
<p>在用户态下，内核页只保留必要的信息，而不再保留所有信息（如用户密码等这些信息是用户程序不必知道的）。因此每次切换用户态和内核态时就需要切换页表</p></li>
<li><p>TLB is flushed when page table changes</p>
<p>这样会导致 TLB
在每次页面切换时都需要刷新（其实若有检查进程和页表对应关系就不需要反复刷新）</p></li>
<li><p>So TLB is flushed on returning to user/kernel mode</p></li>
<li><p>Changing page table is serialized, so speculation cannot
bypass.</p>
<p>切换页表时使用的指令为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov cr3, rax</span><br></pre></td></tr></table></figure>
<p><code>cr3</code> 为存储页表的控制寄存器，由于在由页表 <span
class="math inline">\(1\)</span> 切换到页表 <span
class="math inline">\(2\)</span> 的指令之后的指令的地址在页表 <span
class="math inline">\(1\)</span>
上肯定是无效的，因此之后的指令不会乱序到切换页表指令之前去执行。也就是说，在遇到切换页表指令时，CPU
会在该指令处停下推测执行（乱序指令），直到切换页表完成后继续</p></li>
<li><p>MMU does not have the PTE, so it does not know the physical
address, so the cache line cannot be pre-fetched.</p></li>
</ul>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\1024px-Kernel_page-table_isolation.svg.png" alt="1024px-Kernel_page-table_isolation.svg" style="zoom:80%;" /></p>
<p><strong>注意：</strong>Cache
实质上并不需要刷新，因为程序根本无法访问页表上没有的页</p>
<h4 id="consequence">Consequence</h4>
<p>当然</p>
<ul>
<li><p>When mode changes, memory access triggers a lot of TLB miss, as
TLB has been flushed</p>
<ul>
<li>When mode changes, all TLB entries are wiped out</li>
<li>MMU stall CPU to get mappings (walk page table)</li>
<li>Page table walking is costly: <span
class="math inline">\(3\)</span>-<span class="math inline">\(5\)</span>
layers</li>
</ul>
<p>增加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov cr3, rax</span><br></pre></td></tr></table></figure>
<p>这条指令导致的切换页表的开销实质上最多只会导致 <span
class="math inline">\(\%1\sim\%3\)</span>
的额外开销。使得开销剧增的是每次切换页表时 TLB
的刷新。这会使得每次发生中断时，处理中断和返回的前几次操作都会导致 TLB
miss，因此要增加多次的访存寻页操作，这个开销会非常大</p></li>
<li><p>Protection causes negative optimization in some cases</p>
<ul>
<li><p>When there are a lot of syscalls</p>
<p>Database, web</p>
<p>当然这些增加的开销对于某些应用的性能影响不大，但对于数据库、Web
应用等影响就很大：</p>
<ul>
<li>数据库：频繁地读写内存和发起 I/O
读写，导致其调用系统调用的行为非常频繁，所以内核要经常处理中断</li>
<li>Web 应用：频繁地收发包（同样需要系统调用）以及读写内存</li>
</ul></li>
<li><p>When there are a lot of interrupts</p>
<p>Servers have huge incoming NIC traffics</p>
<p>对于服务器而言，同样需要接发大量数据流，同样会导致极大的开销</p></li>
</ul></li>
</ul>
<h4 id="defense-from-intel-linux">Defense from Intel, Linux</h4>
<ul>
<li><p>PCID</p>
<ul>
<li><p>Add to each page table entry a process ID</p>
<p>在每个 TLB 上的 PTE 中增加一个 PCID 项，表示进程的 ID</p></li>
<li><p>When mode changes, only flush the TLBs of current ID</p></li>
<li><p>Problem: only <span class="math inline">\(12\)</span> bit, i.e.,
up to <span class="math inline">\(4096/2\)</span> processes</p></li>
</ul>
<p>PCID 的增加可以不必在每次切换页表时 flush TLB，这能极大地提升</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A -&gt; B -&gt; A -&gt; B -&gt; ...</span><br></pre></td></tr></table></figure>
<p>这类需要频繁在两个进程间切换的工作负载的效率</p></li>
<li><p>Linux</p>
<ul>
<li><p>By default turn on page table isolation</p></li>
<li><p>And also PCID</p></li>
<li><p>Transparent Huge Page</p>
<p>Less page table entries, less TLB miss.</p>
<p>随着计算机内存的增大以及算力需求的增加，某些科学计算可能需要开辟一块很大的内存，如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> SIZE = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> a[SIZE][SIZE];</span><br></pre></td></tr></table></figure>
<p>开辟一个 <span class="math inline">\(4×10^{10}\)</span>
字节的大矩阵，那么此时 <span class="math inline">\(4\)</span>KB
的页就显得没有必要了。不妨直接分配一个大内存页，这可以帮助减少页表项数目（以减少内存开销）、减少
TLB miss（减少寻页时间开销）等</p></li>
</ul></li>
</ul>
<h2 id="spectre">Spectre</h2>
<h3 id="branch-prediction">Branch Prediction</h3>
<ul>
<li><p>Source Code:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x != <span class="number">0</span></span><br><span class="line">    y = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y = <span class="number">6</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>Compiled to</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test eax, eax    # eax for x; test set the ZF bit of flag register</span><br><span class="line">jnz 0x123        # jnz check ZF to know if jump or not</span><br></pre></td></tr></table></figure>
<p>其中，<code>test</code> 指令只保存与（and）运算的计算 Flags
而不保存计算结果</p></li>
<li><p>Branch stalls the entire CPU</p>
<ul>
<li>Because CPUs do not know which path to execute</li>
<li>CPU uses speculative execution to executes beyond jump</li>
</ul>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221122092312922.png" alt="image-20221122092312922" style="zoom:80%;" /></p>
<p>上图为一张 CPU 逆向图，注意到 CPU 中的 Branch Prediction 实际上占据了
CPU 很大的一块空间。这说明了 Branch Prediction
的复杂性和重要性，同时注意：通常而言，</p>
<ul>
<li>存储部分是整齐的，即图中看起来具有一个个 cell
的部分。这是因为对于存储而言，其每个单元电路排布都是相同的</li>
<li>逻辑部分是不规则的，因为每个元件的逻辑处理通常不同</li>
</ul>
<p>可以看出 Branch Prediction
部分有很大一部分空间用于存储，这说明分支预测需要记录非常多的信息</p></li>
<li><p>How does CPU know if <code>jnz</code> jumps or not?</p>
<ul>
<li><p>the flag register is not ready now, but could be predicted
according to history</p></li>
<li><p>Branch Predictor 分支预测器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YYYYYNYYY -&gt; Y (Choose Y because of 8/9 chances)</span><br><span class="line">YYYYYYNNN -&gt; N (Choose N because recent three consecutive N witnessed)</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="what-if-indirect-branch">What if Indirect Branch?</h3>
<ul>
<li>How CPU know the destination address if the jump is indirect
<ul>
<li><code>jmp [eax]</code></li>
<li>Wait for eax? eax may not be ready but CPU will not stall</li>
</ul></li>
<li>Branch Target Buffer
<ul>
<li>History of jmp destination address, i.e., eax</li>
<li>To predict the destination</li>
<li><code>0x123 0x123 0x123 -&gt; jump to 0x123</code></li>
</ul>
分支预测器中为每个间接跳转有一个 branch target
buffer，里面会存储历史值使得 CPU 猜中的概率较高</li>
</ul>
<h3 id="spectre-1">Spectre</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> s_len = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> s[s_len];</span><br><span class="line"><span class="keyword">char</span> secret[<span class="number">10</span>]; <span class="comment">//secret follows s</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; s_len</span><br><span class="line">    <span class="keyword">return</span> s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_len; i++) <span class="comment">// training, let CPU believe i always &lt; s_len</span></span><br><span class="line">	tmp = access(i); </span><br><span class="line">tmp = a[access(<span class="number">105</span>)]; <span class="comment">// secret[5] is leaked</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Train the CPU branch predictor</p>
<ul>
<li>Make a lot of conditional jumps, and really jump</li>
<li>CPU will believe the jump always jump</li>
</ul>
<p>训练 CPU 认为 <code>if i &lt; s_len</code> 总是能通过，那么在 CPU
执行完 <code>if i &lt; s_len</code> 之前就会开始执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tmp = a[access(<span class="number">105</span>)]; <span class="comment">// secret[5] is leaked</span></span><br></pre></td></tr></table></figure>
<p>那么与 Meltdown 攻击类似，此时 <code>a[access(105)]</code> 就会被载入
Cache 中，之后再根据数组 <code>a</code> 各元素的访问时间即可推测出
<code>secret[5]</code> 的值</p></li>
<li><p>Then do bad things in the branch</p>
<ul>
<li>Like access a memory of malicious address</li>
<li>To cause cache differences</li>
</ul></li>
<li><p>But eventually, it will not jump</p>
<ul>
<li>So, CPU will roll back</li>
</ul></li>
<li><p>At last, measure cache status</p></li>
</ul>
<p><strong>注意 Meltdown 和 Spectre 攻击的区别：</strong></p>
<ul>
<li>Meltdown 用于绕过进程的沙箱保护机制去访问内核数据</li>
<li>Spectre
用于绕过进程内程序员设置的保护去访问程序员不想让其他人访问的数据，但它无法越过进程</li>
</ul>
<h4 id="fengshui---delay-execution">Fengshui - Delay execution</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> i &lt; s_len <span class="comment">// 1    </span></span><br><span class="line">        <span class="keyword">return</span> s[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp = a[access(<span class="number">105</span>)]; <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>但是如果不采取其它措施会发现该攻击的成功率不高，因为
<code>i &lt; s_len</code> 这个比较的速度非常快，而 <code>s[i]</code>
如果还需要访存，很可能会非常慢，因此难以在 <code>if</code>
语句检查完之前开始执行 <code>a[access(105)]</code></p>
<ul>
<li><p>Prerequisite 先决条件</p>
<ul>
<li>Compares(1) is still ongoing, but assignment(2) has finished.</li>
<li>Let’s slow down 1, but accelerate 2.</li>
</ul></li>
<li><p>How to slow down 1?</p>
<ul>
<li><p>clear cache of s_len. s_len</p>
<p>令 <code>s_len</code> 不在 Cache 中，那么此时就需要重新载入
<code>s_len</code></p></li>
<li><p>x &lt; s_len costs hundreds times of cycles</p></li>
</ul></li>
<li><p>How to accelerate 2?</p>
<ul>
<li><p>make s in cache</p>
<p>让 <code>s</code> 在 Cache 里面，很快 <code>s[i]</code>
就可以返回</p></li>
</ul></li>
</ul>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221122100827067.png" alt="image-20221122100827067" style="zoom:80%;" /></p>
<p>注意从最高的 L<span class="math inline">\(1\)</span> Cache 到最低的
Disk Drive 的访问速度差距起码在 <span
class="math inline">\(10^6\)</span> 量级，而系统通常会提供 flush Cache
的 API，使得我们可以很好地操控 Cache 中的数据</p>
<h4 id="isolate-cache-lines">Isolate cache lines</h4>
<ul>
<li><p>```c tmp = a[access(105)];<br />
tmp = a[access(105) * 4096];<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- The cache line size is $64$ bytes for Core i$7$</span><br><span class="line"></span><br><span class="line">  - if `access(105)` returns `10`</span><br><span class="line">  - `10` to `74` will all be cached.</span><br><span class="line">  - So we can separate away them in a, for each returned number.</span><br><span class="line"></span><br><span class="line">- CPU pre-fetches some data.</span><br><span class="line"></span><br><span class="line">  - CPU assumes next some bytes will also be accessed.</span><br><span class="line">  - So maybe $2$ or more cache lines will be cached.</span><br><span class="line">  - `10` to `10 + 64 * 3` may be all cached.</span><br><span class="line"></span><br><span class="line">### Defense Spectre</span><br><span class="line"></span><br><span class="line">#### Defense-Disable speculative execution</span><br><span class="line"></span><br><span class="line">- Disaster to performance. </span><br><span class="line"></span><br><span class="line">  - AMD Ryzen can hold $192$ micro ops (micro instruction) in flight</span><br><span class="line">  - if disabled, one instruction can be executed at one time.</span><br><span class="line"></span><br><span class="line">  关闭预测执行会导致 CPU 性能大幅下降，因此 CPU 也不存在 API 能够开关 Speculative Execution，因此预测执行总是开启的</span><br><span class="line"></span><br><span class="line">- lfence instruction</span><br><span class="line"></span><br><span class="line">  该指令为针对访存指令的乱序执行可能造成的问题设计的，其保证 `lfence` 前的访存指令都被执行完毕后才允许 CPU 执行之后的访存指令</span><br><span class="line"></span><br><span class="line">  - Originally used to do memory barrier</span><br><span class="line"></span><br><span class="line">  - Tell CPU do not run after this instruction before commit.</span><br><span class="line"></span><br><span class="line">    例如当出现</span><br><span class="line"></span><br><span class="line">    ```c</span><br><span class="line">    a = 1;</span><br><span class="line">    lfence;</span><br><span class="line">    b = 2;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>a = 1</code> 命令被执行完毕被 commit 之前，CPU 不会去执行
<code>b = 2</code></p>
<ul>
<li><p>Add at the end of each loop?</p>
<p>设置这种 barrier 的开销很大，它会阻塞后面的指令，不能在 loop
结尾去加</p></li>
</ul></li>
<li><p>Speculative execution fence</p>
<ul>
<li><p>SERIALIZE in Intel <span class="math inline">\(12\)</span>th
Core</p>
<p>该指令不影响内存乱序，但阻止预测执行</p></li>
</ul></li>
</ul>
<h4 id="defense-process-based-isolation">Defense-Process Based
Isolation</h4>
<ul>
<li><p>Processes have independent memory space.</p></li>
<li><p>Split important data into a separate process.</p>
<p>可以将不同的代码写在不同进程上，进程之间无法通过 Spectre
访问之间的（不允许访问的）数据</p>
<ul>
<li><p>Chrome assign to each web tab a process.</p>
<p>Chrome 的每个 tab 就是一个进程，因此每个 tab
之间无法互相访问到之间的数据，这也是为什么浏览器本身吃内存的原因</p></li>
<li><p>So one web tab cannot spectre other tabs, as they use different
set of page tables.</p></li>
</ul></li>
<li><p>How to bypass?</p>
<ul>
<li>CPU also guess TLB sometimes, as many processes share page
table.</li>
</ul></li>
</ul>
<h4 id="defense-blur-timming">Defense-Blur Timming</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s = time();</span><br><span class="line"><span class="keyword">int</span> tmp = a[i];</span><br><span class="line">e = time();</span><br><span class="line"><span class="built_in">printf</span>(e-s);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>what if time() is not accurate?</p>
<p>Meltdown 和 Spectre 都需要精确的时间（ns 级别）来判断载入 Cache
的数据</p>
<ul>
<li>API can blur time</li>
<li>This makes sense for high-level programming languages e.g.,
javascript</li>
</ul></li>
<li><p>Attackers may count by themselves in another thread</p>
<p>但该方法可以很容易地被破解：攻击者独立开启一个线程，执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) cnt++;</span><br></pre></td></tr></table></figure>
<p>即可根据 <code>cnt</code>
的计数来估算时间，并且这个方法估算的时间精确度很高，足够用于执行
Meltdown 和 Spectre 攻击</p></li>
</ul>
<h3 id="spectre-variant">Spectre Variant</h3>
<ul>
<li>Not rely on cache status, but port contention
<ul>
<li>When an instruction is in execution, a port will be occupied</li>
<li>Other instructions using the port will queue</li>
<li>So the completion time indicates if an instruction executes</li>
</ul></li>
<li>Not measure cache status, measure bus contention
<ul>
<li>Interconnect bus is shared across cores</li>
<li>Memory access causes cache elevation/eviction</li>
<li>So the memory access time indicates if there is concurrent memory
access.</li>
</ul></li>
</ul>
<h2 id="extend">Extend</h2>
<h3 id="volatile">Volatile</h3>
<h4 id="volatile-的含义">volatile 的含义</h4>
<p>在谈及 C/C++ 中的 <code>volatile</code> 关键字时，总有人会拿 volatile
这个英文单词的中文解释说事。他们把 volatile
翻译作「易变的」。但事实上，对于翻译来说，很多时候目标语言很难找到一个词能够反映源语言中单词的全部含义和细节。此处「易变的」就无法做到这一点。</p>
<p>Volatile
的意思，若要详细理解，还是应该查阅权威的英英字典。在柯林斯高阶学习词典中，volatile
是这样解释的：</p>
<blockquote>
<p>A situation that is volatile is likely to change suddenly and
unexpectedly.</p>
</blockquote>
<p>这里对 volatile 的解释有三个精髓的形容词和副词，体现了 volatile
的含义。</p>
<ul>
<li>likely：可能的。这意味着被 volatile
形容的对象「有可能也有可能不」发生改变，因此我们不能对这样的对象的状态做出任何假设。</li>
<li>suddenly：突然地。这意味着被 volatile
形容的对象可能发生瞬时改变。</li>
<li>unexpectedly：不可预期地。这与 likely 相互呼应，意味着被 volatile
形容的对象可能以各种不可预期的方式和时间发生更改。</li>
</ul>
<p>因此，volatile
其实就是告诉我们，被它修饰的对象出现任何情况都不要奇怪，我们不能对它们做任何假设。</p>
<h4 id="程序中的-volatile">程序中的 volatile</h4>
<p>对于程序员来说，程序本身的任何行为都必须是可预期的。那么，在程序当中，什么才叫
volatile
呢？这个问题的答案也很简单：程序可能受到程序之外的因素影响。</p>
<p>考虑以下 C/C++ 代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> *p = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">a = *p;</span><br><span class="line">b = *p;</span><br></pre></td></tr></table></figure>
<p>若忽略 <code>volatile</code>，那么 <code>p</code> 就只是一个「指向
<code>int</code> 类型的指针」。这样一来，<code>a = *p;</code> 和
<code>b = *p;</code>
两句，就只需要从内存中读取一次就够了。因为从内存中读取一次之后，CPU
的寄存器中就已经有了这个值；把这个值直接复用就可以了。这样一来，编译器就会做优化，把两次访存的操作优化成一次。这样做是基于一个假设：我们在代码里没有改变
<code>p</code> 指向内存地址的值，那么这个值就一定不会发生改变。</p>
<blockquote>
<p>此处说的「读取内存」，包括了读取 CPU 缓存和读取计算机主存。</p>
</blockquote>
<p>然而，由于 MMIP（Memory mapped
I/O）的存在，这个假设不一定是真的。例如说，假设 <code>p</code>
指向的内存是一个硬件设备。这样一来，从 <code>p</code>
指向的内存读取数据可能伴随着<strong>可观测的副作用</strong>：硬件状态的修改。此时，代码的原意可能是将硬件设备返回的连续两个
<code>int</code> 分别保存在 <code>a</code> 和 <code>b</code>
当中。这种情况下，编译器的优化就会导致程序行为不符合预期了。</p>
<p>总结来说，被 <code>volatile</code>
修饰的变量，在对其进行读写操作时，会引发一些<strong>可观测的副作用</strong>。而这些可观测的副作用，是由<strong>程序之外的因素决定的</strong>。</p>
<h4 id="关键字-volatile-的含义">关键字 volatile 的含义</h4>
<p><a
href="https://link.zhihu.com/?target=http%3A//en.cppreference.com/w/Cppreference%3AFAQ">CPP
reference 网站</a>是对 C 和 C++
语言标准的整理。因此，绝大多数时候，我们可以通过这个网站对语言标准进行查询。关于
<code>volatile</code> 关键字，有 <a
href="https://link.zhihu.com/?target=http%3A//en.cppreference.com/w/c/language/volatile">C
语言标准</a>和 <a
href="https://link.zhihu.com/?target=http%3A//en.cppreference.com/w/cpp/language/cv">C++
语言标准</a>可查。这里摘录两份标准对 <code>volatile</code>
访问的描述。</p>
<blockquote>
<p>C 语言：Every access (both read and write) made through an lvalue
expression of volatile-qualified type is considered an observable side
effect for the purpose of optimization and is evaluated strictly
according to the rules of the abstract machine (that is, all writes are
completed at some time before the next sequence point). This means that
within a single thread of execution, a volatile access cannot be
optimized out or reordered relative to another visible side effect that
is separated by a sequence point from the volatile access. C++
语言：Every access (read or write operation, member function call, etc.)
made through a glvalue expression of volatile-qualified type is treated
as a visible side-effect for the purposes of optimization (that is,
within a single thread of execution, volatile accesses cannot be
optimized out or reordered with another visible side effect that is
sequenced-before or sequenced-after the volatile access. This makes
volatile objects suitable for communication with a signal handler, but
not with another thread of execution, see std::memory_order). Any
attempt to refer to a volatile object through a non-volatile glvalue
(e.g. through a reference or pointer to non-volatile type) results in
undefined behavior.</p>
</blockquote>
<p>这里首先解释两组概念：值类型和序列点（执行序列）。</p>
<p>值类型指的是左值（lvalue）右值（rvalue）这些概念。关于左值和右值，<a
href="https://link.zhihu.com/?target=https%3A//liam0205.me/2016/12/11/rvalue-reference-in-Cpp/">前作</a>有过介绍。简单的理解，左值可以出现在赋值等号的左边，使用时取的是作为对象的身份；右值不可以出现在赋值等号的左边，使用时取的是对象的值。除了
lvalue 和 rvalue，C++ 还定义了其他的值类型。其中，xvalue
大体可以理解为返回右值引用的函数调用或表达式，而 glvalue 则是 lvalue 和
xvalue 之和。</p>
<p>序列点则是 C/C++ 中讨论执行顺序时会提到的概念。对于 C/C++
的表达式来说，执行表达式有两种类型的动作：(1) 计算某个值、(2)
副作用（例如访问 <code>volatile</code>
对象，原子同步，修改文件等）。因此，如果在两个表达式 <code>E1</code> 和
<code>E2</code> 中间有一个序列点，或者在 C++ 中 <code>E1</code>
于序列中在 <code>E2</code> 之前，则 <code>E1</code>
的求值动作和副作用都会在
<code>E2</code>的求值动作和副作用之前。关于序列点和序列顺序规则，可以参考：<a
href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Sequence_point">这里</a>和<a
href="https://link.zhihu.com/?target=http%3A//en.cppreference.com/w/cpp/language/eval_order%23Rules">这里</a>。</p>
<p>因此我们讲，在 C/C++ 中，对 <code>volatile</code>
对象的访问，有编译器优化上的副作用：</p>
<ul>
<li>不允许被优化消失（optimized out）；</li>
<li>于序列上在另一个对 <code>volatile</code> 对象的访问之前。</li>
</ul>
<p>这里提及的「不允许被优化」表示对 <code>volatile</code>
变量的访问，编译器不能做任何假设和推理，都必须按部就班地与「内存」进行交互。因此，上述例中「复用寄存器中的值」就是不允许的。</p>
<p>需要注意的是，无论是 C 还是 C++ 的标准，对于 <code>volatile</code>
访问的序列性，都有单线程执行的前提。其中 C++
标准特别提及，这个顺序性在多线程环境里不一定成立。</p>
<h4 id="volatile-与多线程">volatile 与多线程</h4>
<p><code>volatile</code>
可以解决多线程中的某些问题，这一错误认识荼毒多年。例如，在<a
href="https://link.zhihu.com/?target=https%3A//web.archive.org/save/https%3A//www.zhihu.com/topic/20034193/hot">知乎「volatile」话题下的介绍</a>就是「多线程开发中保持可见性的关键字」。为了拨乱反正，这里先给出结论（注意这些结论都基于本文第一节提出的约定之上）：</p>
<ul>
<li><p><code>volatile</code> 不能解决多线程中的问题。</p></li>
<li><p>按照 <a
href="https://link.zhihu.com/?target=http%3A//web.archive.org/web/20180120044239/http%3A//www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html">Hans
Boehm &amp; Nick Maclaren 的总结</a>，<code>volatile</code>
只在三种场合下是合适的。</p></li>
<li><ul>
<li>和信号处理（signal handler）相关的场合；</li>
<li>和内存映射硬件（memory mapped hardware）相关的场合；</li>
<li>和非本地跳转（<code>setjmp</code> 和
<code>longjmp</code>）相关的场合。</li>
</ul></li>
</ul>
<p>以下我们尝试来用 <code>volatile</code>
关键字解决多线程同步的一个基本问题：happens-before。</p>
<h4 id="case">Case</h4>
<h5 id="naïve-case">1. naïve case</h5>
<p>首先我们考虑这样一段（伪）代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// global shared data</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread1</span>() &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    Type* value = <span class="keyword">new</span> <span class="built_in">Type</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    <span class="built_in">thread2</span>(value);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> != value) &#123; <span class="keyword">delete</span> value; &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread2</span>(Type* value) &#123;</span><br><span class="line">    <span class="comment">// do some evaluations</span></span><br><span class="line">    value-&gt;<span class="built_in">update</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码将 thread1 作为主线程，等待 thread2 准备好
value。因此，thread2 在更新 value 之后将 flag 置为真，而 thread1
死循环地检测 flag。简单来说，这段代码的意图希望实现 thread2 在 thread1
使用 value 之前执行完毕这样的语义。</p>
<p>对多线程编程稍有了解的人应该知道，这段代码是有问题的。问题主要出在两个方面。其一，在
thread1 中，flag = false 到 while 死循环里，没有任何机会对 flag
的值做修改，因此编译器可能会将 if (flag == true)
的内容全部优化掉。其二，在 thread2 中，尽管逻辑上 update 需要发生在 flag
= true 之前，但编译器和 CPU 并不知道；因此 flag = true 可能发生在 update
完成之前，因此 thread1 执行 apply(value) 时可能 value 还未准备好。</p>
<h5 id="加一个-volatile-试试">2. 加一个 volatile 试试？</h5>
<p>在错误的理解中，此时就到了 <code>volatile</code> 登场的时候了。</p>
<p>首先我们考虑这样一段（伪）代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// global shared data</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// 1.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">thread1</span>() &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    Type* value = <span class="keyword">new</span> <span class="built_in">Type</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    <span class="built_in">thread2</span>(value);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;  <span class="comment">// 2.</span></span><br><span class="line">            <span class="built_in">apply</span>(value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> != value) &#123; <span class="keyword">delete</span> value; &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread2</span>(Type* value) &#123;</span><br><span class="line">    <span class="comment">// do some evaluations</span></span><br><span class="line">    value-&gt;<span class="built_in">update</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，在 (1) 处，我们将 <code>flag</code> 声明为
<code>volatile</code>-qualified。因此，在 (2) 处，由于
<code>flag == true</code> 是对 <code>volatile</code> 变量的访问，故而
<code>if</code>-block 不会被优化消失。然而，尽管 <code>flag</code> 是
<code>volatile</code>-qualified，但
<code>value</code>并不是。因此，编译器仍有可能在优化时将
<code>thread2</code> 中的 <code>update</code> 和对 <code>flag</code>
的赋值交换顺序。此外，由于 <code>volatile</code> 禁止了编译器对
<code>flag</code> 的优化，这样使用 <code>volatile</code>
不仅无法达成目的，反而会导致性能下降。</p>
<h5 id="再加一个-volatile-呢">3. 再加一个 volatile 呢？</h5>
<p>在错误的理解中，可能会对 <code>value</code> 也加以
<code>volatile</code> 关键字修饰；颇有些「没有什么是一个
<code>volatile</code> 解决不了的；如果不行，那就两个」的意思。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// global shared data</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread1</span>() &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">volatile</span> Type* value = <span class="keyword">new</span> <span class="built_in">Type</span>(<span class="comment">/* parameters */</span>);   <span class="comment">// 1.</span></span><br><span class="line">    <span class="built_in">thread2</span>(value);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> != value) &#123; <span class="keyword">delete</span> value; &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread2</span>(<span class="keyword">volatile</span> Type* value) &#123;</span><br><span class="line">    <span class="comment">// do some evaluations</span></span><br><span class="line">    value-&gt;<span class="built_in">update</span>(<span class="comment">/* parameters */</span>);                    <span class="comment">// 2.</span></span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上一节代码的基础上，(1) 将 <code>value</code> 声明为
<code>volatile</code>-qualified。因此 (2) 处对两个
<code>volatile</code>-qualified
变量进行访问时，编译器不会交换他们的顺序。看起来就万事大吉了。</p>
<p>然而，<code>volatile</code>
只作用在编译器上，但我们的代码最终是要运行在 CPU 上的。尽管编译器不会将
(2) 处换序，但 CPU 的乱序执行（out-of-order
execution）已是几十年的老技术了；在 CPU 执行时，<code>value</code> 和
<code>flag</code> 的赋值仍有可能是被换序了的（store-store）。此外，(2)
处的 <code>value = new Type()</code>
一行代码并不如想象中那么简单。它实际上大概做了三件事情</p>
<ul>
<li>分配一块 <code>sizeof(Type)</code> 大小的内存；</li>
<li>在这块内存上，执行 <code>Type</code> 类型的初始化；</li>
<li>将这块内存的首地址赋值给 <code>value</code>。</li>
</ul>
<p>对于编译器来说，这些工作都是改表达式语句的求值和副作用，因此不会与
<code>flag</code> 赋值语句换序。但是，在 CPU
乱序执行之下，甚至有可能发生 <code>value</code> 和 <code>flag</code>
已赋值完毕，但内存里尚未完成 <code>Type</code> 初始化的情况。此时若
<code>thread1</code> 中使用 <code>value</code>，则程序可能崩溃。</p>
<blockquote>
<p>也许有人会说，x86 和 AMD64 架构的
CPU（大多数个人机器和服务器使用这两种架构的 CPU）只允许 sotre-load
乱序，而不会发生 store-store 乱序；或者在诸如 IA64 架构的处理器上，对
<code>volatile</code>-qualified
变量的访问采用了专门的指令。因而，在这些条件下，这段代码是安全的。尽管如此，使用
<code>volatile</code>
会禁止编译器优化相关变量，从而降低性能，所以也不建议依赖
<code>volatile</code>
在这种情况下做线程同步。另一方面，这严重依赖具体的硬件规范，超出了本文的约定讨论范围。</p>
</blockquote>
<h5 id="到底应该怎么做">4. 到底应该怎么做？</h5>
<p>回顾一下，我们最初遇到的问题其实需要解决两件事情。一是
<code>flag</code> 相关的代码块不能被轻易优化消失，二是要保证线程同步的
happens-before 语义。但本质上，设计使用 <code>flag</code>
本身也就是为了构建 happens-before
语义。这也就是说，两个问题，后者才是核心；如有其他不用 <code>flag</code>
的办法解决问题，那么 <code>flag</code> 就不重要。</p>
<p>对于当前问题，最简单的办法是使用原子操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// global shared data</span></span><br><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; flag = <span class="literal">false</span>;  <span class="comment">// #include &lt;atomic&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">thread1</span>() &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    Type* value = <span class="keyword">new</span> <span class="built_in">Type</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    <span class="built_in">thread2</span>(value);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> != value) &#123; <span class="keyword">delete</span> value; &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread2</span>(Type* value) &#123;</span><br><span class="line">    <span class="comment">// do some evaluations</span></span><br><span class="line">    value-&gt;<span class="built_in">update</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于对 <code>std::atomic&lt;bool&gt;</code>
的操作是原子的，同时构建了良好的内存屏障，因此整个代码的行为在标准下是良定义的。</p>
<p>除此之外，还可以结合使用互斥量和条件变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// global shared data</span></span><br><span class="line">std::mutex m;                   <span class="comment">// #include &lt;mutex&gt;</span></span><br><span class="line">std::condition_variable cv;     <span class="comment">// #include &lt;condition_variable&gt;</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread1</span>() &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    Type* value = <span class="keyword">new</span> <span class="built_in">Type</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    <span class="built_in">thread2</span>(value);</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lk, []()&#123; <span class="keyword">return</span> flag; &#125;);</span><br><span class="line">    <span class="built_in">apply</span>(value);</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> != value) &#123; <span class="keyword">delete</span> value; &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread2</span>(Type* value) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="comment">// do some evaluations</span></span><br><span class="line">    value-&gt;<span class="built_in">update</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，由线程之间的同步由互斥量和条件变量来保证，同时也避免了
<code>while (true)</code> 死循环空耗 CPU 的情况。</p>
<h4 id="参考资料">参考资料</h4>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/33074506">谈谈 C/C++ 中的
volatile - 知乎 (zhihu.com)</a></li>
<li><a href="https://en.cppreference.com/w/">cppreference.com</a></li>
</ul>
<h3 id="try-catch">try … catch</h3>
<p>对于 <code>try ... catch</code>
异常处理而言，其好处在于可以让程序员减少</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(...)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n × if()&#123;&#125;;else&#123;&#125;;</span></span><br></pre></td></tr></table></figure>
<p>这种大量 <code>if ... else</code> 的检查判断，而将业务代码都写到
<code>try&#123;...&#125;</code> 中，错误处理代码都写到 <code>catch&#123;...&#125;</code>
中，使代码更简洁</p>
<h4 id="try-catch-in-c">1. try … catch in C</h4>
<ul>
<li><p>C has no exception handling</p>
<p>C 语言程序中不存在 exception handling 程序</p>
<ul>
<li>But exception is very useful</li>
<li>It make codes more readable</li>
</ul></li>
<li><p>Developers may implement it</p>
<ul>
<li>To hook faults, including segfault</li>
</ul></li>
<li><p>setjump stores stack pointer into a buffer</p></li>
<li><p>long jump restore the buffer to stack pointer</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">catch_segv</span><span class="params">()</span></span>&#123;</span><br><span class="line">    siglongjmp(jbuf, <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(SIGSEGV, catch_segv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigsetjmp(jbuf, <span class="number">1</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="comment">/* as try*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* as catch*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C 中，可以利用 <code>sigsetjmp()</code> 和
<code>siglongjmp()</code> 函数来进行错误处理，达到
<code>try ... catch</code> 的效果，其中</p>
<ul>
<li><p>```c sighandler_t signal(int signum, sighandler_t handler);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">该函数作用为注册一个信号处理函数，其中</span><br><span class="line"></span><br><span class="line">- 第一个参数 `signum` 指明了信号类型，它可以取除了 `SIGKILL` 和 `SIGSTOP` 之外的任何一种信号</span><br><span class="line"></span><br><span class="line">- 第二个参数 `handler` 描述当信号发生时相应的处理方式：</span><br><span class="line"></span><br><span class="line">  - `SIG_IGN` 表示忽略该信号</span><br><span class="line"></span><br><span class="line">    ```c</span><br><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    #include &lt;signal.h&gt;</span><br><span class="line">    int main(int argc, char *argv[]) &#123;</span><br><span class="line">        signal(SIGINT, SIG_DFL);</span><br><span class="line">        while(1);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>`SIGINT` 信号代表由 `nterruptKey` 产生，通常是 `CTRL +C` 或者是 `DELETE` 。执行上述代码时，按下 `CTRL + C` 程序没有反应。这就对了，如果我们想结束该程序可以按下 `CTRL +\` 来结束，当我们按下 `CTRL +\` 组合键时，产生了 `SIGQUIT` 信号，此信号并没有被忽略</code></pre>
<ul>
<li><p><code>SIG_DFL</code> 表示恢复对信号的系统默认处理</p></li>
<li><p><code>sighandler_t</code> 类型的函数指针</p>
<p>此函数必须在 <code>signal()</code> 被调用前申明，<code>handler</code>
中为这个函数的名字。当接收到一个类型为 <code>sig</code> 的信号时，就执行
<code>handler</code> 所指定的函数。<code>(int)signum</code>
是传递给它的唯一参数。执行了 <code>signal()</code>
调用后，进程只要接收到类型为 <code>sig</code>
的信号，不管其正在执行程序的哪一部分，就立即执行 <code>func()</code>
函数。当 <code>func()</code>
函数执行结束后，控制权返回进程被中断的那一点继续执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*signal_handler)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_handler_fun</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;catch signal %d\n&quot;</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    signal(SIGINT, signal_hander_fun);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当我们按下 <code>CTRL +C</code>
键时会打印该信号值。可以看出该信号的值为 <span
class="math inline">\(2\)</span>。要想退出可以按下 <code>CTRL +\</code>
打印结果为最后一行</p>
<pre><font color="#4E9A06"><b>fuckyou@ubuntu</b></font>:<font color="#3465A4"><b>~/Desktop</b></font>$ ./c
^Ccatch signal 2
^Ccatch signal 2
^Ccatch signal 2
^Ccatch signal 2
^Ccatch signal 2
^\Quit (core dumped)
</pre></li>
</ul></li>
<li><p>```c int sigsetjmp(sigjmp_buf env, int savesigs); void
siglongjmp(sigjmp_buf env, int val); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   其中，对于 `sigsetjmp()` 函数：</span><br><span class="line"></span><br><span class="line">  - 参数 `env` 用来保存目前堆栈环境，一般声明为全局变量 </span><br><span class="line">  - 参数 `savesigs` 若为非 $0$ 则代表搁置的信号集合也会一块保存 </span><br><span class="line"></span><br><span class="line">  若成功执行 `sigsetjmp()` 函数，则返回值为 $0$ </span><br><span class="line"></span><br><span class="line">  对于 `siglongjmp()` 函数：</span><br><span class="line"></span><br><span class="line">  `siglongjmp()` 函数被调用时会跳转回最近执行的 `sigsetjmp()` 处并设置其返回值</span><br><span class="line"></span><br><span class="line">  - 参数 `env` 表示存储要用来恢复当前堆栈环境的变量</span><br><span class="line">  - 参数 `val` 为返回 `sigsetjmp()` 处 `sigsetjmp()` 的返回值</span><br><span class="line"></span><br><span class="line">因此上述代码的逻辑如下：</span><br><span class="line"></span><br><span class="line">- 调用 `signal()` 函数为 Segmentation Fault 注册一个处理函数</span><br><span class="line">- 在处理可能发生 Segmentation Fault 的代码段前调用 `sigsetjmp()` 函数保存现场</span><br><span class="line">  - 若调用 `sigsetjmp()` 保存现场成功则返回 $0$，`if(True)`，因此执行 `/* as try */` 部分</span><br><span class="line">  - 若不成功直接执行 `/* as catch */` 部分</span><br><span class="line">- 在执行 `/* as try */` 时若出现 Segmentation Fault，则跳转到 `catch_segv()` 函数执行，其会调用 `siglongjmp()` 函数回到 `if()` 处重新进行判断，此时的相等判断左侧的值被置为 `int val`，因此 `if(False)` 跳转至 `/* as catch */` 中执行</span><br><span class="line"></span><br><span class="line">综上即为 C 中实现 `try ... catch` 的逻辑实现</span><br><span class="line"></span><br><span class="line">**Linux 信号**</span><br><span class="line"></span><br><span class="line">-  `SIGHUP`：当用户退出 `Shell` 时，由该 `Shell` 启的发所有进程都退接收到这个信号，默认动作为终止进程</span><br><span class="line">-  `SIGINT`：用户按下 `Ctrl  +  C` 组合键时，用户端时向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程</span><br><span class="line">-  `SIGQUIT`：当用户按下 `Ctrl  + /` 组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程并产生 core 文件</span><br><span class="line">-  `SIGILL`： CPU 检测到某进程执行了非法指令。默认动作为终止进程并产生 core 文件</span><br><span class="line">-  `SIGTRAP`：该信号由断点指令或其他 trap 指令产生。默认动作为终止进程并产生 core 文件。</span><br><span class="line">-  `SIGABRT`：调用 `abort` 函数时产生该信号。默认动作为终止进程并产生 core 文件。</span><br><span class="line">-  `SIGBUS`：非法访问内存地址，包括内存地址对齐（alignment）出错，默认动作为终止进程并产生 core 文件。</span><br><span class="line">-  `SIGFPE`：在发生致命的算术错误时产生。不仅包括浮点运行错误，还包括溢出及除数为 $0$ 等所有的算术错误。默认动作为终止进程并产生 core 文件</span><br><span class="line">-  `SIGKILL`：无条件终止进程。本信号不能被忽略、处理和阻塞。默认动作为终止进程。它向系统管理员提供了一种可以杀死任何进程的方法</span><br><span class="line">-  `SIGUSR1`：用户定义的信号，即程序可以在程序中定义并使用该信号。默认动作为终止进程</span><br><span class="line">-  `SIGSEGV`：指示进程进行了无效的内存访问。默认动作为终止进程并使用该信号。默认动作为终止进程</span><br><span class="line">-  `SIGUSR2`：这是另外一个用户定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程</span><br><span class="line">-  `SIGPIPE`： Broken pipe ：向一个没有读端的管道写数据。默认动作为终止进程</span><br><span class="line">-  `SIGALRM`：定时器超时，超时的时间由系统调用 `alarm` 设置。默认动作为终止进程</span><br><span class="line">-  `SIGTERM`：程序结束信号，与 `SIGKILL` 不同的是，该信号可以被阻塞和处理。通常用来要求程序正常退出。执行 `Shell` 命令 `kill` 时，缺少产生这个信号。默认动作为终止进程</span><br><span class="line">-  `SIGCHLD`：子程序结束时，父进程会收到这个信号。默认动作为忽略该信号</span><br><span class="line">-  `SIGCONT`：让一个暂停的进程继续执行</span><br><span class="line">-  `SIGSTOP`：停止进程的执行。注意它和 `SIGTERM` 以及 `SIGINT` 的区别：该进程还未结束，只是暂停执行。本信号不能被忽略、处理和阻塞。默认作为暂停进程</span><br><span class="line">-  `SIGTSTP`：停止进程的动作，但该信号可以被处理和忽略。按下 `Ctrl  +  Z` 组合键时发出该信号。默认动作为暂停进程</span><br><span class="line">-  `SIGTTIN`：当后台进程要从用户终端读数据时，该终端中的所有进程会收到 `SIGTTIN` 信号。默认动作为暂停进程</span><br><span class="line">-  `SIGTTOU`：该信号类似于 `SIGTIN` ，在后台进程要向终端输出数据时产生。默认动作为暂停进程</span><br><span class="line">-  `SIGURG`：套接字（socket）上有紧急数据时，向当前正在运行的进程发出此信号，报告有紧急数据到达。默认动作为忽略该信号</span><br><span class="line">-  `SIGXCPU`：进程执行时间超过了分配给该进程的 CPU 时间，系统产生该信号并发送给该进程。默认动作为终止进程</span><br><span class="line">-  `SIGXFSZ`：超过文件最大长度的限制。默认动作为 `yl` 终止进程并产生 core 文件</span><br><span class="line">-  `SIGVTALRM`：虚拟时钟超时时产生该信号。类似于 `SIGALRM` ，但是它只计算该进程占有用的 CPU 时间。默认动作为终止进程</span><br><span class="line">-  `SIGPROF`：类似于 `SIGVTALRM` ，它不仅包括该进程占用的 CPU 时间还抱括执行系统调用的时间。默认动作为终止进程</span><br><span class="line">-  `SIGWINCH`：窗口大小改变时发出。默认动作为忽略该信号</span><br><span class="line">-  `SIGIO`：此信号向进程指示发出一个异步 IO 事件。默认动作为忽略</span><br><span class="line">-  `SIGPWR`：关机。默认动作为终止进程</span><br><span class="line">-  `SIGRTMIN ~ SIGRTMAX` ： Linux 的实时信号，它没有固定的含义（或者说可以由用户自由使用）。注意， Linux 线程机制使用了前 $3$ 个实时信号。所有的实时信号的默认动作都是终止进程</span><br><span class="line"></span><br><span class="line">参考资料：[LinuxC信号及信号处理（1）\_YinJianxiang的博客-CSDN博客_c信号表](https://blog.csdn.net/YinJianxiang/article/details/78448390) </span><br><span class="line"></span><br><span class="line">#### 2. try … catch in Java</span><br><span class="line"></span><br><span class="line">`try ... catch` 语句在 Java 中有一个特点：</span><br><span class="line"></span><br><span class="line">- 当 `try&#123;...&#125;` 语句中出现错误时，若后面没跟 `catch` 则会将错误 throw 到它的 caller 中的 `catch` 去处理</span><br><span class="line">- 若其 caller 中也没有 `catch` 则往更上层 throw</span><br><span class="line">- 这样递归地 throw 错误，若直到最高层 caller 中还是不存在 `catch` 处理错误则进程会被杀死</span><br><span class="line"></span><br><span class="line">### Memory Model</span><br><span class="line"></span><br><span class="line">- 松散内存模型（Relaxed Memory Model，RMM）：</span><br><span class="line"></span><br><span class="line">  ARM 架构使用的内存模型就是 RMM，其特点在于：不对访存指令的顺序做任何保证</span><br><span class="line"></span><br><span class="line">- 完全存储定序（Total Store Order，TSO）：</span><br><span class="line"></span><br><span class="line">  x$86$ 与 AMD$64$ 架构的采用的内存模型，其保证了 RR（读读），WW（写写），RW（读写）的次序不变，而仅对于 WR（写读）次序不保证。即只有读内存指令可以乱序至写内存指令之前，而写内存指令不能乱序到读内存指令之前</span><br><span class="line"></span><br><span class="line">  对于 x$86$ 与 AMD$64$ 架构，其本身在 CPU 与 Cache 之间带有读写队列，能够保证读读写写有序，而读写之间顺序的实现需要增加其它硬件或软硬件方法来实现</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221122154247872.png&quot; alt=&quot;image-20221122154247872&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">#### Error Caused by RMM</span><br><span class="line"></span><br><span class="line">对于 RMM，其本身可能导致某些问题，考虑如下一段代码：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">atomic&lt;int&gt; a&#123;0&#125;;</span><br><span class="line">atomic&lt;int&gt; b&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int ValueSet(int) &#123;</span><br><span class="line">    int t = 1;</span><br><span class="line">    a = 1;</span><br><span class="line">    b = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Observer(int) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;)&quot; &lt;&lt; endl; // 可能有多种输出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    thread t1(ValueSet, 0);</span><br><span class="line">    thread t2(Observer, 0);</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    cout &lt;&lt; &quot;Got (&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;)&quot; &lt;&lt; endl; // 输出 Got(1, 2)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// build command: g++ -std=c++11 main.cpp -lpthread</span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>我们依据代码，画出如下线程示意图：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\741401-20220928192356218-1753396915.png" alt="img" style="zoom:80%;" /></p>
<p>可以看出，Observer 线程可能打印 <span
class="math inline">\(3\)</span> 种 <code>(a, b)</code>
的组合。是否能打印除 <code>(0, 2)</code>
这种组合？按代码顺序看，是不可能的，而实际上完全可能的。因为编译器或处理器，可能会对指令重排序（reorder），以提高性能。</p>
<p>上面程序代码，对于 <code>a</code>、<code>b</code>
赋值语句执行先后顺序，并没有严格要求；而下面的代码，如果对其执行优化，导致顺序颠倒，可能发生严重错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; a&#123;<span class="number">0</span>&#125;;</span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; b&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Thread1</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    a = t;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Thread2</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">2</span>)</span><br><span class="line">        ; <span class="comment">// 自旋等待</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 总是期待a值为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(Thread1, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(Thread2, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Thread<span class="math inline">\(2\)</span> 中，我们期待
<code>b</code> 值为 <span class="math inline">\(2\)</span>
时，<code>a</code> 值已经为 <span class="math inline">\(1\)</span>（根据
Thread<span class="math inline">\(1\)</span>
中，<code>a</code>、<code>b</code>
赋值顺序）。然而，由于指令重排的影响，<code>a</code>、<code>b</code>
赋值顺序可能颠倒，那么程序可能就会发生问题。</p>
<h4 id="参考资料-1">参考资料</h4>
<ul>
<li><a
href="https://www.cnblogs.com/fortunely/p/16739327.html#c内存顺序memory_order">C++
内存模型与顺序一致性 - 明明1109 - 博客园 (cnblogs.com)</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Dinial of Service Attacks</title>
    <url>/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.9%20Denial%20of%20Service/</url>
    <content><![CDATA[<h1 id="dinial-of-service-attacks">Dinial of Service Attacks</h1>
<h2 id="dos-attacks">DoS Attacks</h2>
<p>两种方式：</p>
<ul>
<li>DoS bug：利用服务器本身的 bug 使其中断服务</li>
<li>DoS flood：利用僵尸网络产生大量请求使服务器无法响应外来合法请求</li>
</ul>
<p>核心：以较少的计算资源来攻击较多计算资源的服务器使其瘫痪，本质是<strong>放大</strong></p>
<p>网络模型中的每一层都可以用来发动 DoS 攻击</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\图片1-16702376524701.png" alt="图片1" style="zoom:80%;" /></p>
<h2 id="ntp-amplification-attack">NTP Amplification attack</h2>
<p>网络时间协议（Network Time
Protocol，NTP）协议是最早的互联网协议之一，主要为使互联网中的各种设备的时间保持同步</p>
<p>在互联网上通常会存在一些公共的 NTP 服务器供客户机进行访问和使用，如
Apple 公司的 <code>time.apple.com</code> 等，而 NTP
攻击就是利用这些公共服务器的资源进行的</p>
<h3 id="ntp-攻击原理">NTP 攻击原理</h3>
<p>NTP 协议是基于 UDP 协议的 C-S 服务模型，由于 <strong>UDP
协议的无连接性</strong>（不像 TCP
具有三次握手过程）具有天然的不安全性，NTP DDoS（Distributed Denial of
Service）攻击就是利用 NTP 服务器的不安全性漏洞来发起的</p>
<p>其过程如下：</p>
<ul>
<li><p>寻找目标：被攻击对象，以及公共 NTP 服务器资源</p></li>
<li><p>伪造被攻击对象的 IP 地址（即把 IP 头部中的 src addr
更换为被攻击对象的 IP 地址，<strong>基于 UDP</strong>）向 NTP
服务器发送请求实种同步报文，其中将包含 <code>monlist</code> 命令</p>
<p><code>monlist</code> 命令将会令 NTP
服务器返回最近与其进行过同分布的最后 <span
class="math inline">\(600\)</span> 个 client 的
IP。也就是说，只需要发送几百个 Bytes 的 query 就可以令服务器发送上万个
Bytes 的 response。实测放大倍数通常能达到上百倍</p></li>
<li><p>此时 NTP 服务器就会向被攻击对象的 IP 地址发送 NTP response
数据包</p></li>
<li><p>由于公共 NTP 服务器的数量众多，攻击者可以根据每个 NTP
服务器的响应时间来选择发送 query
的顺序，以令被攻击对象接收流量在一瞬间达到最大。攻击者若有 <span
class="math inline">\(1\)</span> Gbps
的带宽，那么很可能能够利用该漏洞令被攻击对象在瞬间承受上百 Gbps
的流量</p></li>
</ul>
<p><strong>服务器恢复</strong></p>
<p>对于服务器而言，其在一瞬间承受流量的大小与其恢复时间并非线性关系，随着其承受流量的增大，其恢复时间的增加得快得多</p>
<p>当服务器在一瞬间承受流量过多情况下，除了服务器本身会出现崩溃的情况以外，链路带宽也无法承受。当一条链路的丢包率很高时（如
<span
class="math inline">\(80\%\)</span>），交换机将会将这条链路断掉，其原因在于：</p>
<ul>
<li><p>不断开链路有时会导致链路仍然存在于路由表中，而若路由器采用 RIP
协议，则其算法的路径开销为跳数。若不断开，则该链路仍然是最短跳数的链路，所有发送的数据包仍然经由这条链路进行传输</p></li>
<li><p>但此时使用 <span class="math inline">\(80\%\)</span>
丢包率链路维持传输是没有意义的，client 和 server
反而要花费更多的资源来处理丢包</p></li>
<li><p>若断开则路由器会重新寻找次短路链路作为传输数据的途径，尽管删除链路会导致带宽降低，但至少能令数据包正常地被转发</p></li>
</ul>
<h3 id="mitigation">Mitigation</h3>
<ul>
<li>禁用 <code>monlist</code> 命令</li>
<li>源 IP 验证：需要 Internet
服务提供商（ISP）拒绝发送存在欺骗性的数据包：即从源地址与发送地址不同的数据包</li>
</ul>
<h2 id="syn-flood">SYN Flood</h2>
<p>TCP 三次握手：</p>
<ul>
<li>client 生成随机数作为初始顺序号 <span
class="math inline">\(\text{SN}_\mathrm C\)</span>（Seq Number），置
<span class="math inline">\(\text{AN}_\mathrm C\)</span>（ACK Number）为
<span class="math inline">\(0\)</span>，flag 为 SYN，发送给 server</li>
<li>server 接收到 client 发送来的连接建立请求，也随机生成一个初始顺序号
<span class="math inline">\(\text{SN}_\mathrm S\)</span> 并令 <span
class="math inline">\(\text{AN}_\mathrm S=\text{SN}_{\mathrm
C}+1\)</span>，flag 为 SYN/ACK，发送给 client</li>
<li>client 最后令 <span
class="math inline">\(\text{AN}_\text{C}=\text{SN}_\text{S}+1\)</span>，
<span class="math inline">\(\text{SN}_\mathrm C=\text{SN}_\mathrm
C+1\)</span>，flag 为 ACK，并捎带数据发送给 server</li>
</ul>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221205195816327.png" alt="image-20221205195816327" style="zoom:80%;" /></p>
<p>当 server 接收到 SYN 包时，其会提前在内存中开辟一个 window
作为数据接收缓冲区，而攻击者可以利用这一点，不断对 server 发送虚假源 IP
的 SYN 包请求建立 TCP 连接但不对 server 发来的 SYN/ACK
包进行回复，这样就会导致 server
不断开辟内存，直到内存不足导致服务器崩溃（杀死进程）</p>
<p>而对于作为 window 的内存则需要等到 TCP timeout 之后才会回收，但等待
timeout 的时间足以使得服务器内存被占满</p>
<h3 id="mitigation-1">Mitigation</h3>
<ul>
<li>缩短 timeout：不合适，这将会导致网络不好的用户无法连接到服务器</li>
<li>增大内存：不合适，内存增长相比于发包速度是杯水车薪</li>
<li>不保存状态：不保存 <span
class="math inline">\(\text{SN}_\text{C},\text{SN}_\text{S}\)</span>，并且等待至建立连接时才开辟内存</li>
</ul>
<p>但 <span
class="math inline">\(\text{SN}_\text{C},\text{SN}_\text{S}\)</span>
对于建立连接是必须的，因此需要将 <span
class="math inline">\(\text{SN}_\text{C},\text{SN}_\text{S}\)</span>
保存到网络之中</p>
<h3 id="syn-cookies">SYN COOKIES</h3>
<p>SYN Cookies 为将 <span
class="math inline">\(\text{SN}_\text{C},\text{SN}_\text{S}\)</span>
保存到网络中的常用方法：</p>
<p>server 从 client 发送来的 SYN 包提取出以下信息：</p>
<ul>
<li>SAddr（Source Address）</li>
<li>SPort（Source Port）</li>
<li>DAddr（Destination Address）</li>
<li>DPort（Destination Port）</li>
<li><span class="math inline">\(\text{SN}_\text{C}\)</span>（Sequence
Number of Client）</li>
<li>T（Time）</li>
</ul>
<p>服务器中存储一个密钥 key，结合该密钥对其进行哈希计算： <span
class="math display">\[
\text{L = MACkey (SAddr, SPort, DAddr, DPort, SNC, T)  [24 bits]}
\]</span> 最终得到计算出来而非随机得到的 <span
class="math inline">\(\text{SN}_\text{S}\)</span>： <span
class="math display">\[
\text{SN}_\text{S}\text{ = (T | mss | L)    ( |L| = 24 bits )}
\]</span> 并将其发送给 client</p>
<p>当 client 使用该 <span
class="math inline">\(\text{SN}_\text{S}\)</span>
发送最后一次握手消息时： <span class="math display">\[
\text{ACK ( AN = SN}_\text{S}+1,\text{ SN = SN}_\text{C}+1\ )
\]</span> 可以倒推出计算 <span
class="math inline">\(\text{SN}_\text{S}\)</span> 时使用的信息，包括源
IP 地址、源端口、目的 IP 地址、目的端口（存于 IP 头部中）以及 <span
class="math inline">\(\text{SN}_\text{C}\)</span> 和 Time（包含在 <span
class="math inline">\(\text{SN}_\text{S}\)</span> 中）</p>
<p>利用这些信息计算哈希值进行比对，若正确则说明该服务器之前确实从该
client 接收到 SYN 包（<span
class="math inline">\(\text{SN}_\text{C}\)</span> 正确），并且确实向该
client 发出过 SYN/ACK 包（<span
class="math inline">\(\text{SN}_\text{S}\)</span> 正确）</p>
<p>在这种情况下，攻击者发送的是虚假的源 IP，因此无法与 server 完成 <span
class="math inline">\(3\)</span> 次握手，所以就无法令 server
开辟内存空间了。至于攻击者必须采用虚假源 IP 的原因在于若采用攻击者自身的
IP，由于服务器资源通常与攻击者资源不在一个数量级，攻击者无法承受过多的
SYN/ACK 数据包</p>
<p><strong>Random Initial Seq Num</strong></p>
<p>SYN Cookies 技术本身除了能够解决 SYN Flood
攻击以外，其本身还能够防范一些服务器本身可能存在的
bug，如服务器若采用时间产生随机数种子的防范来生成初始顺序号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">srand(timenow());</span><br><span class="line">seq = rand()</span><br></pre></td></tr></table></figure>
<p>那么此时 <code>seq</code> 将会很容易被猜到，假设此时 server 不采用
SYN Cookies 技术，而仅仅只是令开闭 Window 的阶段转移到 TCP
连接建立，那么该 server 仍然会收到 SYN Flood 的攻击：</p>
<ul>
<li>attacker 向 server 发送 srcIP = victim 的 TCP SYN 数据包</li>
<li>server 向 victim 发送 SYN/ACK 包进行确认</li>
<li>由于 server 的 SN 为由时间产生的随机数种子生成，attacker
只需同步时间即可猜出 server 的 SN，因此 attacker 继续假冒 victim 向
server 发送 ACK 包</li>
<li>server 收到正确的 ACK 包，连接建立，开闭 Window 接收缓冲区</li>
</ul>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221205204308332.png" alt="image-20221205204308332" style="zoom: 67%;" /></p>
<h1 id="dinial-of-service-mitigation">Dinial of Service Mitigation</h1>
<h2 id="client-puzzles">Client Puzzles</h2>
<p>寻找一个难解易验证的问题要求 client 连接时必须给出答案，该方法</p>
<ul>
<li>目的：减慢攻击者的速度</li>
<li>核心：验证答案很容易</li>
</ul>
<p>这种问题可以在 NP 问题（存在 verifier
能在多项式时间内验证答案）中寻找，如： <span class="math display">\[
\text{LSB}_n\text{ ( SHA-1( C || X ) ) = 0}^n
\]</span> 即给出字符串 C，要求 client 给出一个字符串 X 使得 C concat X
的哈希值的前 <span class="math inline">\(n\)</span> 位为 <span
class="math inline">\(0\)</span>，该问题具有 <span
class="math inline">\(2^n\)</span> 指数级的时间复杂度</p>
<p>当 <span class="math inline">\(n=16\)</span> 时，对于一个 <span
class="math inline">\(1\)</span>GHz 的机器需要 <span
class="math inline">\(0.3\)</span> sec 才能解决</p>
<p>因此该方式还有一个好处：可以根据服务器负载动态调节 <span
class="math inline">\(n\)</span> 的大小来进行负载均衡</p>
<ul>
<li><p>同时该问题是随机给出的，对于正常用户而言，并不会频繁发起连接，因此遇到的几率较小；而对于攻击者而言，其需要大量发起连接，因此更加容易遇到
client puzzles</p></li>
<li><p>又或者是当未发生攻击时，不启用 client puzzle；当检测出可能存在
DoS 攻击时，要求每个 client 都要解决 client puzzle</p></li>
</ul>
<p><strong>限制</strong></p>
<ul>
<li>client 与 server 上的程序都需要进行修改</li>
<li>将阻止低算力的合法用户访问（如使用手机或平板电脑的用户，其机器算力不足以支撑它们解决该问题）</li>
</ul>
<h3 id="better-puzzles-captcha">Better Puzzles: CAPTCHA</h3>
<p>Completely Automated Public Turing test to tell Computers and Humans
Apart，即我们通常遇到的验证码</p>
]]></content>
  </entry>
</search>
