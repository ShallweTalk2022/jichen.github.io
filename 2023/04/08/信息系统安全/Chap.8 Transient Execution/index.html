<!DOCTYPE html>
<html lang="zh-Hans">
<head>

<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>

  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Zhi Mang Xing:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":false,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Transient Execution CPU Out-of-Order  现代 CPU 在执行指令时可以乱序执行以增加执行效率，其意义在于： 现代 CPU 都采用流水线模式，这就会出现  数据冒险，其造成了指令间的依赖关系。如 12mov %rax, 0(%rbx)add %rax, %rcx 其中在执行 add %rax, %rcx 时 %rax 的值依赖于前一条 mov">
<meta property="og:type" content="article">
<meta property="og:title" content="寄尘&#39;s Blog">
<meta property="og:url" content="http://example.com/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.8%20Transient%20Execution/index.html">
<meta property="og:site_name" content="寄尘&#39;s Blog">
<meta property="og:description" content="Transient Execution CPU Out-of-Order  现代 CPU 在执行指令时可以乱序执行以增加执行效率，其意义在于： 现代 CPU 都采用流水线模式，这就会出现  数据冒险，其造成了指令间的依赖关系。如 12mov %rax, 0(%rbx)add %rax, %rcx 其中在执行 add %rax, %rcx 时 %rax 的值依赖于前一条 mov">
<meta property="og:locale">
<meta property="og:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/image-20221121183641564.png">
<meta property="og:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/skylake_block_diagram.png">
<meta property="og:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/image-20221121233914046.png">
<meta property="og:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/image-20221121234139048.png">
<meta property="og:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/image-20221121233409918.png">
<meta property="og:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/1024px-Kernel_page-table_isolation.svg.png">
<meta property="og:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/image-20221122092312922.png">
<meta property="og:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/image-20221122100827067.png">
<meta property="og:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/741401-20220928192356218-1753396915.png">
<meta property="article:published_time" content="2023-04-08T15:31:20.533Z">
<meta property="article:modified_time" content="2023-02-21T14:35:37.215Z">
<meta property="article:author" content="自是水长东">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/image-20221121183641564.png">

<link rel="canonical" href="http://example.com/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.8%20Transient%20Execution/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title> | 寄尘's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>



<body itemscope itemtype="http://schema.org/WebPage">

<!-- <script src="/live2d/autoload.js"></script> --> <!-- 这条语句和live2d看板娘有关，去掉注释获得看板娘 -->

  <div class="container use-motion">
    <div class="headband"></div>

    <a target="_blank" rel="noopener" href="https://github.com/jichen2002" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">寄尘's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">人生寄一世，奄忽若飙尘</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.8%20Transient%20Execution/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="自是水长东">
      <meta itemprop="description" content="Medicine, law, business, engineering: these are noble pursuits and necessary to sustain life. But poetry, beauty, romance, love... these are what we stay alive for.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="寄尘's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-08 23:31:20" itemprop="dateCreated datePublished" datetime="2023-04-08T23:31:20+08:00">2023-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-21 22:35:37" itemprop="dateModified" datetime="2023-02-21T22:35:37+08:00">2023-02-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="transient-execution">Transient Execution</h1>
<h2 id="cpu">CPU</h2>
<h3 id="out-of-order">Out-of-Order</h3>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221121183641564.png" alt="image-20221121183641564" style="zoom:80%;" /></p>
<p>现代 CPU 在执行指令时可以乱序执行以增加执行效率，其意义在于：</p>
<p>现代 CPU 都采用流水线模式，这就会出现</p>
<ul>
<li><p>数据冒险，其造成了指令间的依赖关系。如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov %rax, 0(%rbx)</span><br><span class="line">add %rax, %rcx</span><br></pre></td></tr></table></figure>
<p>其中在执行 <code>add %rax, %rcx</code> 时 <code>%rax</code>
的值依赖于前一条 <code>mov</code> 指令将内存中的数据存储到
<code>%rax</code> 中。因此 <code>add</code> 指令在执行到 ALU
部分时至少要等到 <code>mov</code> 指令取出的数据加载到 <code>%rax</code>
中才能继续执行 <code>add</code> 指令。在等待时会插入 <code>nop</code>
指令什么也不做，因此效率就降低了</p>
<ul>
<li>处理数据冒险可采用转发提早将数据送回依赖的元件</li>
</ul></li>
<li><p>控制冒险</p>
<p>不仅包括分支的选择执行，还包括了一些内存访问操作的权限延迟检查</p>
<ul>
<li>通常采用预测执行的方法</li>
<li>对于权限检查而言，CPU 总是假设检查能够通过</li>
</ul></li>
<li><p>元件冒险</p>
<p>现代 CPU
中由于存在并行执行的操作，因此可能存在两条指令在同一时刻需要使用同一元件，因此会产生该问题，但通常解决方式很简单：</p>
<ul>
<li>增加元件数量</li>
</ul></li>
</ul>
<p>因此 CPU 对将要执行的指令进行合理的乱序执行可以令</p>
<ul>
<li>某些不存在依赖关系的指令并行执行</li>
<li>某些存在依赖关系的指令中的被依赖指令执行依赖指令依赖的数据后再去执行依赖指令</li>
<li>资源利用率更高（元件冒险）</li>
</ul>
<p>来减少插入的 <code>nop</code> 指令的数量，以此提高性能</p>
<h3 id="skylake-block-diagram">Skylake Block Diagram</h3>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\skylake_block_diagram.png" alt="skylake_block_diagram" style="zoom:80%;" /></p>
<p>Intel Skylake 是 Intel 第六代微处理器架构</p>
<h4 id="front-end">1. Front End</h4>
<p>注意前端（Front End）架构</p>
<ul>
<li><p>Instruction Fetch &amp; Predecode：</p>
<ul>
<li>该元件将汇编代码进行 (Pre-)Decode，并且可以同时 (Pre-)Decode
多条汇编指令</li>
<li>在 Decode 之后其可以同时输出 <span class="math inline">\(6\)</span>
条汇编指令</li>
</ul></li>
<li><p><span class="math inline">\(4\)</span>-Way Decode：</p>
<ul>
<li><p>从 Instruction Queue 中取出之前 Predecode 的指令再 Decode
一次，这一次是将 CISC 的复杂指令 Decode
为了一系列的微指令，例如假设有这么一条指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [ebx + ecx * 4 + 8] </span><br></pre></td></tr></table></figure>
<p>其作用为将地址为 <code>ebx + ecx * 4 + 8</code> 的内存中的数据送入
<code>eax</code>，那么该指令在 CPU
具体执行时肯定不是按一条指令执行的，而是拆分为多条微指令来执行的。但是这条指令却可以由汇编给出</p></li>
</ul></li>
</ul>
<p>因此，CISC 的概念只是指汇编指令架构，CPU 在真正执行之前需要 Decode
两次：</p>
<ul>
<li>对上层：提供 CISC 的汇编指令（考虑兼容性，只增不减，因此只要使用
<code>x86</code> 架构指令集编写的程序到今天还可以运行），Decode CISC
指令</li>
<li>对下层：将 Decode 之后的指令再次 Decode 为微指令</li>
</ul>
<p>这样做的好处在于：底层的微指令可以根据 CPU
架构的变化而变化从而来压榨出硬件的最大性能，同时还能够保证对上层程序的兼容性</p>
<p>并且，多一次 Decode
的开销并不会很大，因为影响性能的关键是一个程序中的循环体里的代码（或递归部分代码，即重复执行的代码），而这些代码只需要完整地
Decode 一次（此处指 Predecode + Decode）就可以一直执行</p>
<h4 id="execution-engine">2. Execution Engine</h4>
<p>执行引擎中，</p>
<ul>
<li><p>Scheduler：</p>
<p>图中说明 Scheduler 共有 <span class="math inline">\(97\)</span> 个
Entries，这说明其最多可以同时处理 <span
class="math inline">\(97\)</span> 条指令，可见现代 CPU
并行处理能力之强</p></li>
<li><p>Physical Register：</p>
<p>x<span class="math inline">\(86\)</span>-<span
class="math inline">\(64\)</span> 架构的 CPU 一共只有 <span
class="math inline">\(16\)</span> 个通用寄存器，但物理寄存器共有 <span
class="math inline">\(180\)</span> 个</p></li>
<li><p>EUs：</p>
<p>注意到其中的每个 Port
中都有大量的处理元件，这是指令并行执行的关键</p></li>
<li><p>Rename/ Allocate/ Retirement：</p>
<p>其中 Rename 表示寄存器重命名</p></li>
<li><p>Register Alias Table（RAT）：</p>
<p>RAT 中记录了物理寄存器与逻辑寄存器之间的映射</p></li>
</ul>
<h3 id="speculative-execution">Speculative Execution</h3>
<p>How to be even more out of order?</p>
<ul>
<li><p>Multiple-Issue</p>
<ul>
<li><p>Decode multiple instructions at one clock (Super Scalar),</p>
<p>尽可能在一个时钟内增加 Decode 量，这样调度可以更好地执行</p></li>
<li><p>when there is no conflict, they can be dispatched to different
back-end</p></li>
</ul></li>
<li><p>Resolve all kinds of conflict</p>
<p>解决冲突</p>
<ul>
<li><p>Register conflict: RAW, WAR, WAW, RAR √. (Register Renaming)</p>
<ul>
<li><p>RAW：Read After Write</p>
<p>显然 RAW 中 Read 不能和 Write
乱序，因此只需解决数据冒险即可，若会发生数据冒险则采用广播（转发）的方法</p></li>
<li><p>WAR：Write After Read</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read R1</span><br><span class="line">...</span><br><span class="line">write R1</span><br></pre></td></tr></table></figure>
<p>注意一个要点，当某个寄存器 reg
被写入数据时（不包括运算指令，单纯指类似 <code>mov</code>
的指令），说明此时该寄存器的数据是全新的，它并不对前面的任何关于 reg
的指令有任何依赖</p>
<p>也就是说，<code>write R1</code> 本质上可以和 <code>read R1</code>
并行执行甚至乱序执行，但要解决 <code>read R1</code> 的结果不受
<code>write R1</code> 影响这一问题。注意到上图 Skylake 寄存器提供了
<span class="math inline">\(180\)</span>
个物理通用寄存器，假设这些物理寄存器编号分别为
<code>F0, F1, ...</code>，那么我们只需要将两个 <code>R1</code>
替换为不同的物理寄存器即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read R1 -&gt; F3</span><br><span class="line">...</span><br><span class="line">write R1 -&gt; F4</span><br></pre></td></tr></table></figure>
<p>此时读写就可以打破依赖从而乱序执行了</p></li>
<li><p>WAW：Write After Write</p>
<p>与 RAW 相同，两次 <code>write</code>
之间是不存在依赖关系的，因此可以使用寄存器重命名</p></li>
<li><p>RAR：Read After Read</p></li>
</ul></li>
<li><p>ALU conflict: add more ALUs</p></li>
</ul>
<p>这些情况都将在 CPU Decode
时进行处理，根据指令间的依赖关系绘制出控制流图（Control Flow
Graph，CFG），之后调度器根据 CFG 进行指令间的调度</p></li>
<li><p>Branch Prediction</p>
<ul>
<li>Predict if a conditional jump really jumps</li>
<li>Predict the destination of indirect jump</li>
</ul></li>
<li><p>Cache pre-fetch</p>
<p>预取高速缓存。当内存访问指令的地址已经被计算出来且将要被访问时，如
<code>0x500</code>，那么 CPU 会把 <code>0x500</code> 先读取到 Cache
里，之后的访问速度就很快了</p>
<ul>
<li>Predict what memory will be accessed</li>
</ul></li>
</ul>
<p>然而这些方案都会导致某些安全问题</p>
<h2 id="meltdown">Meltdown</h2>
<h3 id="bypass-page-property-check">Bypass page property check</h3>
<ul>
<li><p>Every time an address is accessed, CPU MMU maps virtual address
to physical address</p>
<p>当有内存访问指令时，CPU 会先对已经计算出的地址进行翻译并将页表项 load
到 TLB 中，但这个过程不会对其进行安全性检查</p></li>
<li><p>MMU uses TLB to cache page table entries (mappings)</p></li>
<li><p>Security Check was done later</p>
<p>安全性检查在真正执行到该条指令时才会进行</p>
<ul>
<li><p>To make it more out-of-order</p>
<p>为什么能使乱序执行更加<strong>乱</strong>？</p></li>
</ul></li>
<li><p>If later check fails, roll back</p>
<ul>
<li>Not all components needs roll back</li>
<li>E.g., cache</li>
</ul>
<p>当进行安全性检查时，若不通过则 CPU
会回滚，但不是所有数据都能回滚，事实上大部分数据没办法回滚，例如
Cache、Heap、(Sometimes) Stack</p>
<p>对于 Stack：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221121233914046.png" alt="image-20221121233914046" style="zoom:80%;" /></p>
<p>显然此时回滚后只需把 <code>Callee</code> 的数据丢弃即可，Stack
可以回滚到原状态。但是若是出现修改了 <code>rsp</code>
之前的数据的行为：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221121234139048.png" alt="image-20221121234139048" style="zoom:80%;" /></p>
<p>那此时也和 Heap 一样无法回滚了</p>
<p>这是因为在修改覆盖这些数据时没有备份，同时也没有回滚的操作；而对于寄存器来说是有相应的备份和操作的</p></li>
</ul>
<h3 id="meltdown-1">Meltdown</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Try&#123;</span><br><span class="line">    xor eax, eax </span><br><span class="line">    movb al, [x]</span><br><span class="line">    mov ecx, [ebx + 4 * eax] # ebx: int a[256];</span><br><span class="line">&#125;catch(e)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>令 <code>x</code> 为内核地址，如 <code>0xf0000000</code></li>
<li>假设 <code>[0xf0000000] = 84</code>，并且是用户不可访问的</li>
<li><code>a[84]</code> 会被暂时性地存入
<code>ecx</code>，但在此之后会被回滚</li>
</ul>
<p>注意，这个时候</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movb al, [x]</span><br><span class="line">mov ecx, [ebx + 4 * eax] # ebx: int a[256];</span><br></pre></td></tr></table></figure>
<p>两条指令是会发生乱序执行的，这就是安全性检查推迟带来的结果，其中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movb al, [x]</span><br></pre></td></tr></table></figure>
<p>这条指令存在 <span class="math inline">\(2\)</span> 个过程：</p>
<ul>
<li><p>将 <code>[x]</code> 数据对应的页表项 load 到 TLB 中；将
<code>[x]</code> 数据 load 到 Cache 中（注意 Cache
很小，其单位不是页，通常 L<span class="math inline">\(1\)</span> Cache
一个单位只有 <span class="math inline">\(64\)</span> Bytes）。同时 CPU
假设权限检查能够通过，因此会将 <code>[x]</code> 指向的数据先转发给</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ecx, [ebx + 4 * eax] </span><br></pre></td></tr></table></figure>
<p>这条指令相应需要 <code>eax</code> 数据的过程中（如 ALU）</p></li>
<li><p>真正执行将 <code>[x]</code> 内容 load 到 <code>al</code>
中的过程，此时才会进行安全性检查</p></li>
</ul>
<p>此时只需要 <code>ebx + 4 * eax</code> 的值计算出来后将
<code>[ebx + 4 * eax]</code> 的数据相应页表项 load 到 Cache 和 TLB
中，无论</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ecx, [ebx + 4 * eax] </span><br></pre></td></tr></table></figure>
<p>是否真的把数据 load 到 <code>ecx</code> 中都无所谓了</p>
<p>也就是说可以视为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ecx, [ebx + 4 * eax] </span><br></pre></td></tr></table></figure>
<p>有 <span class="math inline">\(3\)</span> 个过程：</p>
<ul>
<li>计算 <code>ebx + 4 * eax</code></li>
<li>第二、三过程与 <code>movb al, [x]</code> 指令相同</li>
</ul>
<p>只需要 <code>mov ecx, [ebx + 4 * eax]</code> 这条指令的第一、二过程在
<code>movb al, [x]</code>
的安全性检查执行完毕之前执行完，攻击即为成功。这个时候
<code>a[84]</code> 已经在 Cache 中了</p>
<h4 id="another-thread">Another Thread</h4>
<p>此时攻击者只需再开另外一个线程执行下列代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">    s = time();</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">    e = time();</span><br><span class="line">    <span class="built_in">printf</span>(e-s);</span><br></pre></td></tr></table></figure>
<p>就可以得到访存指令所需时间：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221121233409918.png" alt="image-20221121233409918" style="zoom:80%;" /></p>
<p>很显然可以发现对于 <code>a[84]</code> 来说访问速度格外地快，说明
<code>a[84]</code> 就是在之前我们利用访存乱序执行 load 到 Cache
中的内存数据。因此根据访问速度异常快的数组的下标我们就可以很容易地知道
<code>0xf0000000</code> 中存储的数据是什么了</p>
<p>该攻击方式相当于一次任意读，只需将内核中存储的用户密码读取出来即可实现提权</p>
<h4 id="memory-access-granularity">Memory Access Granularity</h4>
<p>当然该攻击可能还存在一些问题：</p>
<p>if <code>a[84]</code> is accessed, <code>a[85], a[86], …</code> are
all faster</p>
<p>Because:</p>
<ul>
<li>CPU cache not only a dword, but a cache line
<ul>
<li>a cache line may contain <span class="math inline">\(64\)</span>
bytes for most recent Intel processors.</li>
</ul></li>
<li>CPU may prefetch multiple lines
<ul>
<li>If <code>a[x]</code> is accessed, there are chances that
<code>a[x+1] … a[x+16]</code> will be accessed later</li>
<li>If prediction is correct, later access can be faster.</li>
<li>If prediction is wrong, only cache &amp; memory bandwidth is
wasted.</li>
</ul></li>
</ul>
<p>为了解决该问题，可以开一个很大的数组，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">256</span> &lt;&lt; <span class="number">12</span>]; <span class="comment">// 2^12 Bytes = 4 KB</span></span><br></pre></td></tr></table></figure>
<p>并且在访问时使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i + (<span class="number">1</span> &lt;&lt; <span class="number">12</span>)];</span><br></pre></td></tr></table></figure>
<p>而 Cache 的一个单位的大小（Cache Line）是永远不可能达到 4K
的，因此可以解决上述问题</p>
<h3 id="defense-meltdown">Defense-Meltdown</h3>
<h4 id="kernel-page-table-isolation">Kernel page-table isolation</h4>
<ul>
<li><p>Kernel and user mode do not share page table</p>
<p>在用户态下，内核页只保留必要的信息，而不再保留所有信息（如用户密码等这些信息是用户程序不必知道的）。因此每次切换用户态和内核态时就需要切换页表</p></li>
<li><p>TLB is flushed when page table changes</p>
<p>这样会导致 TLB
在每次页面切换时都需要刷新（其实若有检查进程和页表对应关系就不需要反复刷新）</p></li>
<li><p>So TLB is flushed on returning to user/kernel mode</p></li>
<li><p>Changing page table is serialized, so speculation cannot
bypass.</p>
<p>切换页表时使用的指令为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov cr3, rax</span><br></pre></td></tr></table></figure>
<p><code>cr3</code> 为存储页表的控制寄存器，由于在由页表 <span
class="math inline">\(1\)</span> 切换到页表 <span
class="math inline">\(2\)</span> 的指令之后的指令的地址在页表 <span
class="math inline">\(1\)</span>
上肯定是无效的，因此之后的指令不会乱序到切换页表指令之前去执行。也就是说，在遇到切换页表指令时，CPU
会在该指令处停下推测执行（乱序指令），直到切换页表完成后继续</p></li>
<li><p>MMU does not have the PTE, so it does not know the physical
address, so the cache line cannot be pre-fetched.</p></li>
</ul>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\1024px-Kernel_page-table_isolation.svg.png" alt="1024px-Kernel_page-table_isolation.svg" style="zoom:80%;" /></p>
<p><strong>注意：</strong>Cache
实质上并不需要刷新，因为程序根本无法访问页表上没有的页</p>
<h4 id="consequence">Consequence</h4>
<p>当然</p>
<ul>
<li><p>When mode changes, memory access triggers a lot of TLB miss, as
TLB has been flushed</p>
<ul>
<li>When mode changes, all TLB entries are wiped out</li>
<li>MMU stall CPU to get mappings (walk page table)</li>
<li>Page table walking is costly: <span
class="math inline">\(3\)</span>-<span class="math inline">\(5\)</span>
layers</li>
</ul>
<p>增加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov cr3, rax</span><br></pre></td></tr></table></figure>
<p>这条指令导致的切换页表的开销实质上最多只会导致 <span
class="math inline">\(\%1\sim\%3\)</span>
的额外开销。使得开销剧增的是每次切换页表时 TLB
的刷新。这会使得每次发生中断时，处理中断和返回的前几次操作都会导致 TLB
miss，因此要增加多次的访存寻页操作，这个开销会非常大</p></li>
<li><p>Protection causes negative optimization in some cases</p>
<ul>
<li><p>When there are a lot of syscalls</p>
<p>Database, web</p>
<p>当然这些增加的开销对于某些应用的性能影响不大，但对于数据库、Web
应用等影响就很大：</p>
<ul>
<li>数据库：频繁地读写内存和发起 I/O
读写，导致其调用系统调用的行为非常频繁，所以内核要经常处理中断</li>
<li>Web 应用：频繁地收发包（同样需要系统调用）以及读写内存</li>
</ul></li>
<li><p>When there are a lot of interrupts</p>
<p>Servers have huge incoming NIC traffics</p>
<p>对于服务器而言，同样需要接发大量数据流，同样会导致极大的开销</p></li>
</ul></li>
</ul>
<h4 id="defense-from-intel-linux">Defense from Intel, Linux</h4>
<ul>
<li><p>PCID</p>
<ul>
<li><p>Add to each page table entry a process ID</p>
<p>在每个 TLB 上的 PTE 中增加一个 PCID 项，表示进程的 ID</p></li>
<li><p>When mode changes, only flush the TLBs of current ID</p></li>
<li><p>Problem: only <span class="math inline">\(12\)</span> bit, i.e.,
up to <span class="math inline">\(4096/2\)</span> processes</p></li>
</ul>
<p>PCID 的增加可以不必在每次切换页表时 flush TLB，这能极大地提升</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B -&gt; A -&gt; B -&gt; ...</span><br></pre></td></tr></table></figure>
<p>这类需要频繁在两个进程间切换的工作负载的效率</p></li>
<li><p>Linux</p>
<ul>
<li><p>By default turn on page table isolation</p></li>
<li><p>And also PCID</p></li>
<li><p>Transparent Huge Page</p>
<p>Less page table entries, less TLB miss.</p>
<p>随着计算机内存的增大以及算力需求的增加，某些科学计算可能需要开辟一块很大的内存，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> SIZE = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> a[SIZE][SIZE];</span><br></pre></td></tr></table></figure>
<p>开辟一个 <span class="math inline">\(4×10^{10}\)</span>
字节的大矩阵，那么此时 <span class="math inline">\(4\)</span>KB
的页就显得没有必要了。不妨直接分配一个大内存页，这可以帮助减少页表项数目（以减少内存开销）、减少
TLB miss（减少寻页时间开销）等</p></li>
</ul></li>
</ul>
<h2 id="spectre">Spectre</h2>
<h3 id="branch-prediction">Branch Prediction</h3>
<ul>
<li><p>Source Code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x != <span class="number">0</span></span><br><span class="line">    y = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y = <span class="number">6</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>Compiled to</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test eax, eax    # eax for x; test set the ZF bit of flag register</span><br><span class="line">jnz 0x123        # jnz check ZF to know if jump or not</span><br></pre></td></tr></table></figure>
<p>其中，<code>test</code> 指令只保存与（and）运算的计算 Flags
而不保存计算结果</p></li>
<li><p>Branch stalls the entire CPU</p>
<ul>
<li>Because CPUs do not know which path to execute</li>
<li>CPU uses speculative execution to executes beyond jump</li>
</ul>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221122092312922.png" alt="image-20221122092312922" style="zoom:80%;" /></p>
<p>上图为一张 CPU 逆向图，注意到 CPU 中的 Branch Prediction 实际上占据了
CPU 很大的一块空间。这说明了 Branch Prediction
的复杂性和重要性，同时注意：通常而言，</p>
<ul>
<li>存储部分是整齐的，即图中看起来具有一个个 cell
的部分。这是因为对于存储而言，其每个单元电路排布都是相同的</li>
<li>逻辑部分是不规则的，因为每个元件的逻辑处理通常不同</li>
</ul>
<p>可以看出 Branch Prediction
部分有很大一部分空间用于存储，这说明分支预测需要记录非常多的信息</p></li>
<li><p>How does CPU know if <code>jnz</code> jumps or not?</p>
<ul>
<li><p>the flag register is not ready now, but could be predicted
according to history</p></li>
<li><p>Branch Predictor 分支预测器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YYYYYNYYY -&gt; Y (Choose Y because of 8/9 chances)</span><br><span class="line">YYYYYYNNN -&gt; N (Choose N because recent three consecutive N witnessed)</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="what-if-indirect-branch">What if Indirect Branch?</h3>
<ul>
<li>How CPU know the destination address if the jump is indirect
<ul>
<li><code>jmp [eax]</code></li>
<li>Wait for eax? eax may not be ready but CPU will not stall</li>
</ul></li>
<li>Branch Target Buffer
<ul>
<li>History of jmp destination address, i.e., eax</li>
<li>To predict the destination</li>
<li><code>0x123 0x123 0x123 -&gt; jump to 0x123</code></li>
</ul>
分支预测器中为每个间接跳转有一个 branch target
buffer，里面会存储历史值使得 CPU 猜中的概率较高</li>
</ul>
<h3 id="spectre-1">Spectre</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> s_len = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> s[s_len];</span><br><span class="line"><span class="keyword">char</span> secret[<span class="number">10</span>]; <span class="comment">//secret follows s</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; s_len</span><br><span class="line">    <span class="keyword">return</span> s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_len; i++) <span class="comment">// training, let CPU believe i always &lt; s_len</span></span><br><span class="line">	tmp = access(i); </span><br><span class="line">tmp = a[access(<span class="number">105</span>)]; <span class="comment">// secret[5] is leaked</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Train the CPU branch predictor</p>
<ul>
<li>Make a lot of conditional jumps, and really jump</li>
<li>CPU will believe the jump always jump</li>
</ul>
<p>训练 CPU 认为 <code>if i &lt; s_len</code> 总是能通过，那么在 CPU
执行完 <code>if i &lt; s_len</code> 之前就会开始执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmp = a[access(<span class="number">105</span>)]; <span class="comment">// secret[5] is leaked</span></span><br></pre></td></tr></table></figure>
<p>那么与 Meltdown 攻击类似，此时 <code>a[access(105)]</code> 就会被载入
Cache 中，之后再根据数组 <code>a</code> 各元素的访问时间即可推测出
<code>secret[5]</code> 的值</p></li>
<li><p>Then do bad things in the branch</p>
<ul>
<li>Like access a memory of malicious address</li>
<li>To cause cache differences</li>
</ul></li>
<li><p>But eventually, it will not jump</p>
<ul>
<li>So, CPU will roll back</li>
</ul></li>
<li><p>At last, measure cache status</p></li>
</ul>
<p><strong>注意 Meltdown 和 Spectre 攻击的区别：</strong></p>
<ul>
<li>Meltdown 用于绕过进程的沙箱保护机制去访问内核数据</li>
<li>Spectre
用于绕过进程内程序员设置的保护去访问程序员不想让其他人访问的数据，但它无法越过进程</li>
</ul>
<h4 id="fengshui---delay-execution">Fengshui - Delay execution</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> i &lt; s_len <span class="comment">// 1    </span></span><br><span class="line">        <span class="keyword">return</span> s[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp = a[access(<span class="number">105</span>)]; <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>但是如果不采取其它措施会发现该攻击的成功率不高，因为
<code>i &lt; s_len</code> 这个比较的速度非常快，而 <code>s[i]</code>
如果还需要访存，很可能会非常慢，因此难以在 <code>if</code>
语句检查完之前开始执行 <code>a[access(105)]</code></p>
<ul>
<li><p>Prerequisite 先决条件</p>
<ul>
<li>Compares(1) is still ongoing, but assignment(2) has finished.</li>
<li>Let’s slow down 1, but accelerate 2.</li>
</ul></li>
<li><p>How to slow down 1?</p>
<ul>
<li><p>clear cache of s_len. s_len</p>
<p>令 <code>s_len</code> 不在 Cache 中，那么此时就需要重新载入
<code>s_len</code></p></li>
<li><p>x &lt; s_len costs hundreds times of cycles</p></li>
</ul></li>
<li><p>How to accelerate 2?</p>
<ul>
<li><p>make s in cache</p>
<p>让 <code>s</code> 在 Cache 里面，很快 <code>s[i]</code>
就可以返回</p></li>
</ul></li>
</ul>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221122100827067.png" alt="image-20221122100827067" style="zoom:80%;" /></p>
<p>注意从最高的 L<span class="math inline">\(1\)</span> Cache 到最低的
Disk Drive 的访问速度差距起码在 <span
class="math inline">\(10^6\)</span> 量级，而系统通常会提供 flush Cache
的 API，使得我们可以很好地操控 Cache 中的数据</p>
<h4 id="isolate-cache-lines">Isolate cache lines</h4>
<ul>
<li><p>```c tmp = a[access(105)];<br />
tmp = a[access(105) * 4096];<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- The cache line size is $64$ bytes for Core i$7$</span><br><span class="line"></span><br><span class="line">  - if `access(105)` returns `10`</span><br><span class="line">  - `10` to `74` will all be cached.</span><br><span class="line">  - So we can separate away them in a, for each returned number.</span><br><span class="line"></span><br><span class="line">- CPU pre-fetches some data.</span><br><span class="line"></span><br><span class="line">  - CPU assumes next some bytes will also be accessed.</span><br><span class="line">  - So maybe $2$ or more cache lines will be cached.</span><br><span class="line">  - `10` to `10 + 64 * 3` may be all cached.</span><br><span class="line"></span><br><span class="line">### Defense Spectre</span><br><span class="line"></span><br><span class="line">#### Defense-Disable speculative execution</span><br><span class="line"></span><br><span class="line">- Disaster to performance. </span><br><span class="line"></span><br><span class="line">  - AMD Ryzen can hold $192$ micro ops (micro instruction) in flight</span><br><span class="line">  - if disabled, one instruction can be executed at one time.</span><br><span class="line"></span><br><span class="line">  关闭预测执行会导致 CPU 性能大幅下降，因此 CPU 也不存在 API 能够开关 Speculative Execution，因此预测执行总是开启的</span><br><span class="line"></span><br><span class="line">- lfence instruction</span><br><span class="line"></span><br><span class="line">  该指令为针对访存指令的乱序执行可能造成的问题设计的，其保证 `lfence` 前的访存指令都被执行完毕后才允许 CPU 执行之后的访存指令</span><br><span class="line"></span><br><span class="line">  - Originally used to do memory barrier</span><br><span class="line"></span><br><span class="line">  - Tell CPU do not run after this instruction before commit.</span><br><span class="line"></span><br><span class="line">    例如当出现</span><br><span class="line"></span><br><span class="line">    ```c</span><br><span class="line">    a = 1;</span><br><span class="line">    lfence;</span><br><span class="line">    b = 2;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>a = 1</code> 命令被执行完毕被 commit 之前，CPU 不会去执行
<code>b = 2</code></p>
<ul>
<li><p>Add at the end of each loop?</p>
<p>设置这种 barrier 的开销很大，它会阻塞后面的指令，不能在 loop
结尾去加</p></li>
</ul></li>
<li><p>Speculative execution fence</p>
<ul>
<li><p>SERIALIZE in Intel <span class="math inline">\(12\)</span>th
Core</p>
<p>该指令不影响内存乱序，但阻止预测执行</p></li>
</ul></li>
</ul>
<h4 id="defense-process-based-isolation">Defense-Process Based
Isolation</h4>
<ul>
<li><p>Processes have independent memory space.</p></li>
<li><p>Split important data into a separate process.</p>
<p>可以将不同的代码写在不同进程上，进程之间无法通过 Spectre
访问之间的（不允许访问的）数据</p>
<ul>
<li><p>Chrome assign to each web tab a process.</p>
<p>Chrome 的每个 tab 就是一个进程，因此每个 tab
之间无法互相访问到之间的数据，这也是为什么浏览器本身吃内存的原因</p></li>
<li><p>So one web tab cannot spectre other tabs, as they use different
set of page tables.</p></li>
</ul></li>
<li><p>How to bypass?</p>
<ul>
<li>CPU also guess TLB sometimes, as many processes share page
table.</li>
</ul></li>
</ul>
<h4 id="defense-blur-timming">Defense-Blur Timming</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = time();</span><br><span class="line"><span class="keyword">int</span> tmp = a[i];</span><br><span class="line">e = time();</span><br><span class="line"><span class="built_in">printf</span>(e-s);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>what if time() is not accurate?</p>
<p>Meltdown 和 Spectre 都需要精确的时间（ns 级别）来判断载入 Cache
的数据</p>
<ul>
<li>API can blur time</li>
<li>This makes sense for high-level programming languages e.g.,
javascript</li>
</ul></li>
<li><p>Attackers may count by themselves in another thread</p>
<p>但该方法可以很容易地被破解：攻击者独立开启一个线程，执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) cnt++;</span><br></pre></td></tr></table></figure>
<p>即可根据 <code>cnt</code>
的计数来估算时间，并且这个方法估算的时间精确度很高，足够用于执行
Meltdown 和 Spectre 攻击</p></li>
</ul>
<h3 id="spectre-variant">Spectre Variant</h3>
<ul>
<li>Not rely on cache status, but port contention
<ul>
<li>When an instruction is in execution, a port will be occupied</li>
<li>Other instructions using the port will queue</li>
<li>So the completion time indicates if an instruction executes</li>
</ul></li>
<li>Not measure cache status, measure bus contention
<ul>
<li>Interconnect bus is shared across cores</li>
<li>Memory access causes cache elevation/eviction</li>
<li>So the memory access time indicates if there is concurrent memory
access.</li>
</ul></li>
</ul>
<h2 id="extend">Extend</h2>
<h3 id="volatile">Volatile</h3>
<h4 id="volatile-的含义">volatile 的含义</h4>
<p>在谈及 C/C++ 中的 <code>volatile</code> 关键字时，总有人会拿 volatile
这个英文单词的中文解释说事。他们把 volatile
翻译作「易变的」。但事实上，对于翻译来说，很多时候目标语言很难找到一个词能够反映源语言中单词的全部含义和细节。此处「易变的」就无法做到这一点。</p>
<p>Volatile
的意思，若要详细理解，还是应该查阅权威的英英字典。在柯林斯高阶学习词典中，volatile
是这样解释的：</p>
<blockquote>
<p>A situation that is volatile is likely to change suddenly and
unexpectedly.</p>
</blockquote>
<p>这里对 volatile 的解释有三个精髓的形容词和副词，体现了 volatile
的含义。</p>
<ul>
<li>likely：可能的。这意味着被 volatile
形容的对象「有可能也有可能不」发生改变，因此我们不能对这样的对象的状态做出任何假设。</li>
<li>suddenly：突然地。这意味着被 volatile
形容的对象可能发生瞬时改变。</li>
<li>unexpectedly：不可预期地。这与 likely 相互呼应，意味着被 volatile
形容的对象可能以各种不可预期的方式和时间发生更改。</li>
</ul>
<p>因此，volatile
其实就是告诉我们，被它修饰的对象出现任何情况都不要奇怪，我们不能对它们做任何假设。</p>
<h4 id="程序中的-volatile">程序中的 volatile</h4>
<p>对于程序员来说，程序本身的任何行为都必须是可预期的。那么，在程序当中，什么才叫
volatile
呢？这个问题的答案也很简单：程序可能受到程序之外的因素影响。</p>
<p>考虑以下 C/C++ 代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> *p = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">a = *p;</span><br><span class="line">b = *p;</span><br></pre></td></tr></table></figure>
<p>若忽略 <code>volatile</code>，那么 <code>p</code> 就只是一个「指向
<code>int</code> 类型的指针」。这样一来，<code>a = *p;</code> 和
<code>b = *p;</code>
两句，就只需要从内存中读取一次就够了。因为从内存中读取一次之后，CPU
的寄存器中就已经有了这个值；把这个值直接复用就可以了。这样一来，编译器就会做优化，把两次访存的操作优化成一次。这样做是基于一个假设：我们在代码里没有改变
<code>p</code> 指向内存地址的值，那么这个值就一定不会发生改变。</p>
<blockquote>
<p>此处说的「读取内存」，包括了读取 CPU 缓存和读取计算机主存。</p>
</blockquote>
<p>然而，由于 MMIP（Memory mapped
I/O）的存在，这个假设不一定是真的。例如说，假设 <code>p</code>
指向的内存是一个硬件设备。这样一来，从 <code>p</code>
指向的内存读取数据可能伴随着<strong>可观测的副作用</strong>：硬件状态的修改。此时，代码的原意可能是将硬件设备返回的连续两个
<code>int</code> 分别保存在 <code>a</code> 和 <code>b</code>
当中。这种情况下，编译器的优化就会导致程序行为不符合预期了。</p>
<p>总结来说，被 <code>volatile</code>
修饰的变量，在对其进行读写操作时，会引发一些<strong>可观测的副作用</strong>。而这些可观测的副作用，是由<strong>程序之外的因素决定的</strong>。</p>
<h4 id="关键字-volatile-的含义">关键字 volatile 的含义</h4>
<p><a
href="https://link.zhihu.com/?target=http%3A//en.cppreference.com/w/Cppreference%3AFAQ">CPP
reference 网站</a>是对 C 和 C++
语言标准的整理。因此，绝大多数时候，我们可以通过这个网站对语言标准进行查询。关于
<code>volatile</code> 关键字，有 <a
href="https://link.zhihu.com/?target=http%3A//en.cppreference.com/w/c/language/volatile">C
语言标准</a>和 <a
href="https://link.zhihu.com/?target=http%3A//en.cppreference.com/w/cpp/language/cv">C++
语言标准</a>可查。这里摘录两份标准对 <code>volatile</code>
访问的描述。</p>
<blockquote>
<p>C 语言：Every access (both read and write) made through an lvalue
expression of volatile-qualified type is considered an observable side
effect for the purpose of optimization and is evaluated strictly
according to the rules of the abstract machine (that is, all writes are
completed at some time before the next sequence point). This means that
within a single thread of execution, a volatile access cannot be
optimized out or reordered relative to another visible side effect that
is separated by a sequence point from the volatile access. C++
语言：Every access (read or write operation, member function call, etc.)
made through a glvalue expression of volatile-qualified type is treated
as a visible side-effect for the purposes of optimization (that is,
within a single thread of execution, volatile accesses cannot be
optimized out or reordered with another visible side effect that is
sequenced-before or sequenced-after the volatile access. This makes
volatile objects suitable for communication with a signal handler, but
not with another thread of execution, see std::memory_order). Any
attempt to refer to a volatile object through a non-volatile glvalue
(e.g. through a reference or pointer to non-volatile type) results in
undefined behavior.</p>
</blockquote>
<p>这里首先解释两组概念：值类型和序列点（执行序列）。</p>
<p>值类型指的是左值（lvalue）右值（rvalue）这些概念。关于左值和右值，<a
href="https://link.zhihu.com/?target=https%3A//liam0205.me/2016/12/11/rvalue-reference-in-Cpp/">前作</a>有过介绍。简单的理解，左值可以出现在赋值等号的左边，使用时取的是作为对象的身份；右值不可以出现在赋值等号的左边，使用时取的是对象的值。除了
lvalue 和 rvalue，C++ 还定义了其他的值类型。其中，xvalue
大体可以理解为返回右值引用的函数调用或表达式，而 glvalue 则是 lvalue 和
xvalue 之和。</p>
<p>序列点则是 C/C++ 中讨论执行顺序时会提到的概念。对于 C/C++
的表达式来说，执行表达式有两种类型的动作：(1) 计算某个值、(2)
副作用（例如访问 <code>volatile</code>
对象，原子同步，修改文件等）。因此，如果在两个表达式 <code>E1</code> 和
<code>E2</code> 中间有一个序列点，或者在 C++ 中 <code>E1</code>
于序列中在 <code>E2</code> 之前，则 <code>E1</code>
的求值动作和副作用都会在
<code>E2</code>的求值动作和副作用之前。关于序列点和序列顺序规则，可以参考：<a
href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Sequence_point">这里</a>和<a
href="https://link.zhihu.com/?target=http%3A//en.cppreference.com/w/cpp/language/eval_order%23Rules">这里</a>。</p>
<p>因此我们讲，在 C/C++ 中，对 <code>volatile</code>
对象的访问，有编译器优化上的副作用：</p>
<ul>
<li>不允许被优化消失（optimized out）；</li>
<li>于序列上在另一个对 <code>volatile</code> 对象的访问之前。</li>
</ul>
<p>这里提及的「不允许被优化」表示对 <code>volatile</code>
变量的访问，编译器不能做任何假设和推理，都必须按部就班地与「内存」进行交互。因此，上述例中「复用寄存器中的值」就是不允许的。</p>
<p>需要注意的是，无论是 C 还是 C++ 的标准，对于 <code>volatile</code>
访问的序列性，都有单线程执行的前提。其中 C++
标准特别提及，这个顺序性在多线程环境里不一定成立。</p>
<h4 id="volatile-与多线程">volatile 与多线程</h4>
<p><code>volatile</code>
可以解决多线程中的某些问题，这一错误认识荼毒多年。例如，在<a
href="https://link.zhihu.com/?target=https%3A//web.archive.org/save/https%3A//www.zhihu.com/topic/20034193/hot">知乎「volatile」话题下的介绍</a>就是「多线程开发中保持可见性的关键字」。为了拨乱反正，这里先给出结论（注意这些结论都基于本文第一节提出的约定之上）：</p>
<ul>
<li><p><code>volatile</code> 不能解决多线程中的问题。</p></li>
<li><p>按照 <a
href="https://link.zhihu.com/?target=http%3A//web.archive.org/web/20180120044239/http%3A//www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html">Hans
Boehm &amp; Nick Maclaren 的总结</a>，<code>volatile</code>
只在三种场合下是合适的。</p></li>
<li><ul>
<li>和信号处理（signal handler）相关的场合；</li>
<li>和内存映射硬件（memory mapped hardware）相关的场合；</li>
<li>和非本地跳转（<code>setjmp</code> 和
<code>longjmp</code>）相关的场合。</li>
</ul></li>
</ul>
<p>以下我们尝试来用 <code>volatile</code>
关键字解决多线程同步的一个基本问题：happens-before。</p>
<h4 id="case">Case</h4>
<h5 id="naïve-case">1. naïve case</h5>
<p>首先我们考虑这样一段（伪）代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global shared data</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread1</span>() &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    Type* value = <span class="keyword">new</span> <span class="built_in">Type</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    <span class="built_in">thread2</span>(value);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> != value) &#123; <span class="keyword">delete</span> value; &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread2</span>(Type* value) &#123;</span><br><span class="line">    <span class="comment">// do some evaluations</span></span><br><span class="line">    value-&gt;<span class="built_in">update</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码将 thread1 作为主线程，等待 thread2 准备好
value。因此，thread2 在更新 value 之后将 flag 置为真，而 thread1
死循环地检测 flag。简单来说，这段代码的意图希望实现 thread2 在 thread1
使用 value 之前执行完毕这样的语义。</p>
<p>对多线程编程稍有了解的人应该知道，这段代码是有问题的。问题主要出在两个方面。其一，在
thread1 中，flag = false 到 while 死循环里，没有任何机会对 flag
的值做修改，因此编译器可能会将 if (flag == true)
的内容全部优化掉。其二，在 thread2 中，尽管逻辑上 update 需要发生在 flag
= true 之前，但编译器和 CPU 并不知道；因此 flag = true 可能发生在 update
完成之前，因此 thread1 执行 apply(value) 时可能 value 还未准备好。</p>
<h5 id="加一个-volatile-试试">2. 加一个 volatile 试试？</h5>
<p>在错误的理解中，此时就到了 <code>volatile</code> 登场的时候了。</p>
<p>首先我们考虑这样一段（伪）代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global shared data</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// 1.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">thread1</span>() &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    Type* value = <span class="keyword">new</span> <span class="built_in">Type</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    <span class="built_in">thread2</span>(value);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;  <span class="comment">// 2.</span></span><br><span class="line">            <span class="built_in">apply</span>(value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> != value) &#123; <span class="keyword">delete</span> value; &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread2</span>(Type* value) &#123;</span><br><span class="line">    <span class="comment">// do some evaluations</span></span><br><span class="line">    value-&gt;<span class="built_in">update</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，在 (1) 处，我们将 <code>flag</code> 声明为
<code>volatile</code>-qualified。因此，在 (2) 处，由于
<code>flag == true</code> 是对 <code>volatile</code> 变量的访问，故而
<code>if</code>-block 不会被优化消失。然而，尽管 <code>flag</code> 是
<code>volatile</code>-qualified，但
<code>value</code>并不是。因此，编译器仍有可能在优化时将
<code>thread2</code> 中的 <code>update</code> 和对 <code>flag</code>
的赋值交换顺序。此外，由于 <code>volatile</code> 禁止了编译器对
<code>flag</code> 的优化，这样使用 <code>volatile</code>
不仅无法达成目的，反而会导致性能下降。</p>
<h5 id="再加一个-volatile-呢">3. 再加一个 volatile 呢？</h5>
<p>在错误的理解中，可能会对 <code>value</code> 也加以
<code>volatile</code> 关键字修饰；颇有些「没有什么是一个
<code>volatile</code> 解决不了的；如果不行，那就两个」的意思。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global shared data</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread1</span>() &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">volatile</span> Type* value = <span class="keyword">new</span> <span class="built_in">Type</span>(<span class="comment">/* parameters */</span>);   <span class="comment">// 1.</span></span><br><span class="line">    <span class="built_in">thread2</span>(value);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> != value) &#123; <span class="keyword">delete</span> value; &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread2</span>(<span class="keyword">volatile</span> Type* value) &#123;</span><br><span class="line">    <span class="comment">// do some evaluations</span></span><br><span class="line">    value-&gt;<span class="built_in">update</span>(<span class="comment">/* parameters */</span>);                    <span class="comment">// 2.</span></span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上一节代码的基础上，(1) 将 <code>value</code> 声明为
<code>volatile</code>-qualified。因此 (2) 处对两个
<code>volatile</code>-qualified
变量进行访问时，编译器不会交换他们的顺序。看起来就万事大吉了。</p>
<p>然而，<code>volatile</code>
只作用在编译器上，但我们的代码最终是要运行在 CPU 上的。尽管编译器不会将
(2) 处换序，但 CPU 的乱序执行（out-of-order
execution）已是几十年的老技术了；在 CPU 执行时，<code>value</code> 和
<code>flag</code> 的赋值仍有可能是被换序了的（store-store）。此外，(2)
处的 <code>value = new Type()</code>
一行代码并不如想象中那么简单。它实际上大概做了三件事情</p>
<ul>
<li>分配一块 <code>sizeof(Type)</code> 大小的内存；</li>
<li>在这块内存上，执行 <code>Type</code> 类型的初始化；</li>
<li>将这块内存的首地址赋值给 <code>value</code>。</li>
</ul>
<p>对于编译器来说，这些工作都是改表达式语句的求值和副作用，因此不会与
<code>flag</code> 赋值语句换序。但是，在 CPU
乱序执行之下，甚至有可能发生 <code>value</code> 和 <code>flag</code>
已赋值完毕，但内存里尚未完成 <code>Type</code> 初始化的情况。此时若
<code>thread1</code> 中使用 <code>value</code>，则程序可能崩溃。</p>
<blockquote>
<p>也许有人会说，x86 和 AMD64 架构的
CPU（大多数个人机器和服务器使用这两种架构的 CPU）只允许 sotre-load
乱序，而不会发生 store-store 乱序；或者在诸如 IA64 架构的处理器上，对
<code>volatile</code>-qualified
变量的访问采用了专门的指令。因而，在这些条件下，这段代码是安全的。尽管如此，使用
<code>volatile</code>
会禁止编译器优化相关变量，从而降低性能，所以也不建议依赖
<code>volatile</code>
在这种情况下做线程同步。另一方面，这严重依赖具体的硬件规范，超出了本文的约定讨论范围。</p>
</blockquote>
<h5 id="到底应该怎么做">4. 到底应该怎么做？</h5>
<p>回顾一下，我们最初遇到的问题其实需要解决两件事情。一是
<code>flag</code> 相关的代码块不能被轻易优化消失，二是要保证线程同步的
happens-before 语义。但本质上，设计使用 <code>flag</code>
本身也就是为了构建 happens-before
语义。这也就是说，两个问题，后者才是核心；如有其他不用 <code>flag</code>
的办法解决问题，那么 <code>flag</code> 就不重要。</p>
<p>对于当前问题，最简单的办法是使用原子操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global shared data</span></span><br><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; flag = <span class="literal">false</span>;  <span class="comment">// #include &lt;atomic&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">thread1</span>() &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    Type* value = <span class="keyword">new</span> <span class="built_in">Type</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    <span class="built_in">thread2</span>(value);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> != value) &#123; <span class="keyword">delete</span> value; &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread2</span>(Type* value) &#123;</span><br><span class="line">    <span class="comment">// do some evaluations</span></span><br><span class="line">    value-&gt;<span class="built_in">update</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于对 <code>std::atomic&lt;bool&gt;</code>
的操作是原子的，同时构建了良好的内存屏障，因此整个代码的行为在标准下是良定义的。</p>
<p>除此之外，还可以结合使用互斥量和条件变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global shared data</span></span><br><span class="line">std::mutex m;                   <span class="comment">// #include &lt;mutex&gt;</span></span><br><span class="line">std::condition_variable cv;     <span class="comment">// #include &lt;condition_variable&gt;</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread1</span>() &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    Type* value = <span class="keyword">new</span> <span class="built_in">Type</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    <span class="built_in">thread2</span>(value);</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lk, []()&#123; <span class="keyword">return</span> flag; &#125;);</span><br><span class="line">    <span class="built_in">apply</span>(value);</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> != value) &#123; <span class="keyword">delete</span> value; &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread2</span>(Type* value) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="comment">// do some evaluations</span></span><br><span class="line">    value-&gt;<span class="built_in">update</span>(<span class="comment">/* parameters */</span>);</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，由线程之间的同步由互斥量和条件变量来保证，同时也避免了
<code>while (true)</code> 死循环空耗 CPU 的情况。</p>
<h4 id="参考资料">参考资料</h4>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33074506">谈谈 C/C++ 中的
volatile - 知乎 (zhihu.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/">cppreference.com</a></li>
</ul>
<h3 id="try-catch">try … catch</h3>
<p>对于 <code>try ... catch</code>
异常处理而言，其好处在于可以让程序员减少</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(...)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n × if()&#123;&#125;;else&#123;&#125;;</span></span><br></pre></td></tr></table></figure>
<p>这种大量 <code>if ... else</code> 的检查判断，而将业务代码都写到
<code>try&#123;...&#125;</code> 中，错误处理代码都写到 <code>catch&#123;...&#125;</code>
中，使代码更简洁</p>
<h4 id="try-catch-in-c">1. try … catch in C</h4>
<ul>
<li><p>C has no exception handling</p>
<p>C 语言程序中不存在 exception handling 程序</p>
<ul>
<li>But exception is very useful</li>
<li>It make codes more readable</li>
</ul></li>
<li><p>Developers may implement it</p>
<ul>
<li>To hook faults, including segfault</li>
</ul></li>
<li><p>setjump stores stack pointer into a buffer</p></li>
<li><p>long jump restore the buffer to stack pointer</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">catch_segv</span><span class="params">()</span></span>&#123;</span><br><span class="line">    siglongjmp(jbuf, <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(SIGSEGV, catch_segv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigsetjmp(jbuf, <span class="number">1</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="comment">/* as try*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* as catch*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C 中，可以利用 <code>sigsetjmp()</code> 和
<code>siglongjmp()</code> 函数来进行错误处理，达到
<code>try ... catch</code> 的效果，其中</p>
<ul>
<li><p>```c sighandler_t signal(int signum, sighandler_t handler);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">该函数作用为注册一个信号处理函数，其中</span><br><span class="line"></span><br><span class="line">- 第一个参数 `signum` 指明了信号类型，它可以取除了 `SIGKILL` 和 `SIGSTOP` 之外的任何一种信号</span><br><span class="line"></span><br><span class="line">- 第二个参数 `handler` 描述当信号发生时相应的处理方式：</span><br><span class="line"></span><br><span class="line">  - `SIG_IGN` 表示忽略该信号</span><br><span class="line"></span><br><span class="line">    ```c</span><br><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    #include &lt;signal.h&gt;</span><br><span class="line">    int main(int argc, char *argv[]) &#123;</span><br><span class="line">        signal(SIGINT, SIG_DFL);</span><br><span class="line">        while(1);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>`SIGINT` 信号代表由 `nterruptKey` 产生，通常是 `CTRL +C` 或者是 `DELETE` 。执行上述代码时，按下 `CTRL + C` 程序没有反应。这就对了，如果我们想结束该程序可以按下 `CTRL +\` 来结束，当我们按下 `CTRL +\` 组合键时，产生了 `SIGQUIT` 信号，此信号并没有被忽略</code></pre>
<ul>
<li><p><code>SIG_DFL</code> 表示恢复对信号的系统默认处理</p></li>
<li><p><code>sighandler_t</code> 类型的函数指针</p>
<p>此函数必须在 <code>signal()</code> 被调用前申明，<code>handler</code>
中为这个函数的名字。当接收到一个类型为 <code>sig</code> 的信号时，就执行
<code>handler</code> 所指定的函数。<code>(int)signum</code>
是传递给它的唯一参数。执行了 <code>signal()</code>
调用后，进程只要接收到类型为 <code>sig</code>
的信号，不管其正在执行程序的哪一部分，就立即执行 <code>func()</code>
函数。当 <code>func()</code>
函数执行结束后，控制权返回进程被中断的那一点继续执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*signal_handler)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_handler_fun</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;catch signal %d\n&quot;</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    signal(SIGINT, signal_hander_fun);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当我们按下 <code>CTRL +C</code>
键时会打印该信号值。可以看出该信号的值为 <span
class="math inline">\(2\)</span>。要想退出可以按下 <code>CTRL +\</code>
打印结果为最后一行</p>
<pre><font color="#4E9A06"><b>fuckyou@ubuntu</b></font>:<font color="#3465A4"><b>~/Desktop</b></font>$ ./c
^Ccatch signal 2
^Ccatch signal 2
^Ccatch signal 2
^Ccatch signal 2
^Ccatch signal 2
^\Quit (core dumped)
</pre></li>
</ul></li>
<li><p>```c int sigsetjmp(sigjmp_buf env, int savesigs); void
siglongjmp(sigjmp_buf env, int val); <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   其中，对于 `sigsetjmp()` 函数：</span><br><span class="line"></span><br><span class="line">  - 参数 `env` 用来保存目前堆栈环境，一般声明为全局变量 </span><br><span class="line">  - 参数 `savesigs` 若为非 $0$ 则代表搁置的信号集合也会一块保存 </span><br><span class="line"></span><br><span class="line">  若成功执行 `sigsetjmp()` 函数，则返回值为 $0$ </span><br><span class="line"></span><br><span class="line">  对于 `siglongjmp()` 函数：</span><br><span class="line"></span><br><span class="line">  `siglongjmp()` 函数被调用时会跳转回最近执行的 `sigsetjmp()` 处并设置其返回值</span><br><span class="line"></span><br><span class="line">  - 参数 `env` 表示存储要用来恢复当前堆栈环境的变量</span><br><span class="line">  - 参数 `val` 为返回 `sigsetjmp()` 处 `sigsetjmp()` 的返回值</span><br><span class="line"></span><br><span class="line">因此上述代码的逻辑如下：</span><br><span class="line"></span><br><span class="line">- 调用 `signal()` 函数为 Segmentation Fault 注册一个处理函数</span><br><span class="line">- 在处理可能发生 Segmentation Fault 的代码段前调用 `sigsetjmp()` 函数保存现场</span><br><span class="line">  - 若调用 `sigsetjmp()` 保存现场成功则返回 $0$，`if(True)`，因此执行 `/* as try */` 部分</span><br><span class="line">  - 若不成功直接执行 `/* as catch */` 部分</span><br><span class="line">- 在执行 `/* as try */` 时若出现 Segmentation Fault，则跳转到 `catch_segv()` 函数执行，其会调用 `siglongjmp()` 函数回到 `if()` 处重新进行判断，此时的相等判断左侧的值被置为 `int val`，因此 `if(False)` 跳转至 `/* as catch */` 中执行</span><br><span class="line"></span><br><span class="line">综上即为 C 中实现 `try ... catch` 的逻辑实现</span><br><span class="line"></span><br><span class="line">**Linux 信号**</span><br><span class="line"></span><br><span class="line">-  `SIGHUP`：当用户退出 `Shell` 时，由该 `Shell` 启的发所有进程都退接收到这个信号，默认动作为终止进程</span><br><span class="line">-  `SIGINT`：用户按下 `Ctrl  +  C` 组合键时，用户端时向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程</span><br><span class="line">-  `SIGQUIT`：当用户按下 `Ctrl  + /` 组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程并产生 core 文件</span><br><span class="line">-  `SIGILL`： CPU 检测到某进程执行了非法指令。默认动作为终止进程并产生 core 文件</span><br><span class="line">-  `SIGTRAP`：该信号由断点指令或其他 trap 指令产生。默认动作为终止进程并产生 core 文件。</span><br><span class="line">-  `SIGABRT`：调用 `abort` 函数时产生该信号。默认动作为终止进程并产生 core 文件。</span><br><span class="line">-  `SIGBUS`：非法访问内存地址，包括内存地址对齐（alignment）出错，默认动作为终止进程并产生 core 文件。</span><br><span class="line">-  `SIGFPE`：在发生致命的算术错误时产生。不仅包括浮点运行错误，还包括溢出及除数为 $0$ 等所有的算术错误。默认动作为终止进程并产生 core 文件</span><br><span class="line">-  `SIGKILL`：无条件终止进程。本信号不能被忽略、处理和阻塞。默认动作为终止进程。它向系统管理员提供了一种可以杀死任何进程的方法</span><br><span class="line">-  `SIGUSR1`：用户定义的信号，即程序可以在程序中定义并使用该信号。默认动作为终止进程</span><br><span class="line">-  `SIGSEGV`：指示进程进行了无效的内存访问。默认动作为终止进程并使用该信号。默认动作为终止进程</span><br><span class="line">-  `SIGUSR2`：这是另外一个用户定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程</span><br><span class="line">-  `SIGPIPE`： Broken pipe ：向一个没有读端的管道写数据。默认动作为终止进程</span><br><span class="line">-  `SIGALRM`：定时器超时，超时的时间由系统调用 `alarm` 设置。默认动作为终止进程</span><br><span class="line">-  `SIGTERM`：程序结束信号，与 `SIGKILL` 不同的是，该信号可以被阻塞和处理。通常用来要求程序正常退出。执行 `Shell` 命令 `kill` 时，缺少产生这个信号。默认动作为终止进程</span><br><span class="line">-  `SIGCHLD`：子程序结束时，父进程会收到这个信号。默认动作为忽略该信号</span><br><span class="line">-  `SIGCONT`：让一个暂停的进程继续执行</span><br><span class="line">-  `SIGSTOP`：停止进程的执行。注意它和 `SIGTERM` 以及 `SIGINT` 的区别：该进程还未结束，只是暂停执行。本信号不能被忽略、处理和阻塞。默认作为暂停进程</span><br><span class="line">-  `SIGTSTP`：停止进程的动作，但该信号可以被处理和忽略。按下 `Ctrl  +  Z` 组合键时发出该信号。默认动作为暂停进程</span><br><span class="line">-  `SIGTTIN`：当后台进程要从用户终端读数据时，该终端中的所有进程会收到 `SIGTTIN` 信号。默认动作为暂停进程</span><br><span class="line">-  `SIGTTOU`：该信号类似于 `SIGTIN` ，在后台进程要向终端输出数据时产生。默认动作为暂停进程</span><br><span class="line">-  `SIGURG`：套接字（socket）上有紧急数据时，向当前正在运行的进程发出此信号，报告有紧急数据到达。默认动作为忽略该信号</span><br><span class="line">-  `SIGXCPU`：进程执行时间超过了分配给该进程的 CPU 时间，系统产生该信号并发送给该进程。默认动作为终止进程</span><br><span class="line">-  `SIGXFSZ`：超过文件最大长度的限制。默认动作为 `yl` 终止进程并产生 core 文件</span><br><span class="line">-  `SIGVTALRM`：虚拟时钟超时时产生该信号。类似于 `SIGALRM` ，但是它只计算该进程占有用的 CPU 时间。默认动作为终止进程</span><br><span class="line">-  `SIGPROF`：类似于 `SIGVTALRM` ，它不仅包括该进程占用的 CPU 时间还抱括执行系统调用的时间。默认动作为终止进程</span><br><span class="line">-  `SIGWINCH`：窗口大小改变时发出。默认动作为忽略该信号</span><br><span class="line">-  `SIGIO`：此信号向进程指示发出一个异步 IO 事件。默认动作为忽略</span><br><span class="line">-  `SIGPWR`：关机。默认动作为终止进程</span><br><span class="line">-  `SIGRTMIN ~ SIGRTMAX` ： Linux 的实时信号，它没有固定的含义（或者说可以由用户自由使用）。注意， Linux 线程机制使用了前 $3$ 个实时信号。所有的实时信号的默认动作都是终止进程</span><br><span class="line"></span><br><span class="line">参考资料：[LinuxC信号及信号处理（1）\_YinJianxiang的博客-CSDN博客_c信号表](https://blog.csdn.net/YinJianxiang/article/details/78448390) </span><br><span class="line"></span><br><span class="line">#### 2. try … catch in Java</span><br><span class="line"></span><br><span class="line">`try ... catch` 语句在 Java 中有一个特点：</span><br><span class="line"></span><br><span class="line">- 当 `try&#123;...&#125;` 语句中出现错误时，若后面没跟 `catch` 则会将错误 throw 到它的 caller 中的 `catch` 去处理</span><br><span class="line">- 若其 caller 中也没有 `catch` 则往更上层 throw</span><br><span class="line">- 这样递归地 throw 错误，若直到最高层 caller 中还是不存在 `catch` 处理错误则进程会被杀死</span><br><span class="line"></span><br><span class="line">### Memory Model</span><br><span class="line"></span><br><span class="line">- 松散内存模型（Relaxed Memory Model，RMM）：</span><br><span class="line"></span><br><span class="line">  ARM 架构使用的内存模型就是 RMM，其特点在于：不对访存指令的顺序做任何保证</span><br><span class="line"></span><br><span class="line">- 完全存储定序（Total Store Order，TSO）：</span><br><span class="line"></span><br><span class="line">  x$86$ 与 AMD$64$ 架构的采用的内存模型，其保证了 RR（读读），WW（写写），RW（读写）的次序不变，而仅对于 WR（写读）次序不保证。即只有读内存指令可以乱序至写内存指令之前，而写内存指令不能乱序到读内存指令之前</span><br><span class="line"></span><br><span class="line">  对于 x$86$ 与 AMD$64$ 架构，其本身在 CPU 与 Cache 之间带有读写队列，能够保证读读写写有序，而读写之间顺序的实现需要增加其它硬件或软硬件方法来实现</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221122154247872.png&quot; alt=&quot;image-20221122154247872&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">#### Error Caused by RMM</span><br><span class="line"></span><br><span class="line">对于 RMM，其本身可能导致某些问题，考虑如下一段代码：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">atomic&lt;int&gt; a&#123;0&#125;;</span><br><span class="line">atomic&lt;int&gt; b&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int ValueSet(int) &#123;</span><br><span class="line">    int t = 1;</span><br><span class="line">    a = 1;</span><br><span class="line">    b = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Observer(int) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;)&quot; &lt;&lt; endl; // 可能有多种输出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    thread t1(ValueSet, 0);</span><br><span class="line">    thread t2(Observer, 0);</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    cout &lt;&lt; &quot;Got (&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;)&quot; &lt;&lt; endl; // 输出 Got(1, 2)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// build command: g++ -std=c++11 main.cpp -lpthread</span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>我们依据代码，画出如下线程示意图：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\741401-20220928192356218-1753396915.png" alt="img" style="zoom:80%;" /></p>
<p>可以看出，Observer 线程可能打印 <span
class="math inline">\(3\)</span> 种 <code>(a, b)</code>
的组合。是否能打印除 <code>(0, 2)</code>
这种组合？按代码顺序看，是不可能的，而实际上完全可能的。因为编译器或处理器，可能会对指令重排序（reorder），以提高性能。</p>
<p>上面程序代码，对于 <code>a</code>、<code>b</code>
赋值语句执行先后顺序，并没有严格要求；而下面的代码，如果对其执行优化，导致顺序颠倒，可能发生严重错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; a&#123;<span class="number">0</span>&#125;;</span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; b&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Thread1</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    a = t;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Thread2</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">2</span>)</span><br><span class="line">        ; <span class="comment">// 自旋等待</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 总是期待a值为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(Thread1, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(Thread2, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Thread<span class="math inline">\(2\)</span> 中，我们期待
<code>b</code> 值为 <span class="math inline">\(2\)</span>
时，<code>a</code> 值已经为 <span class="math inline">\(1\)</span>（根据
Thread<span class="math inline">\(1\)</span>
中，<code>a</code>、<code>b</code>
赋值顺序）。然而，由于指令重排的影响，<code>a</code>、<code>b</code>
赋值顺序可能颠倒，那么程序可能就会发生问题。</p>
<h4 id="参考资料-1">参考资料</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/fortunely/p/16739327.html#c内存顺序memory_order">C++
内存模型与顺序一致性 - 明明1109 - 博客园 (cnblogs.com)</a></li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>自是水长东
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.8%20Transient%20Execution/" title="">http://example.com/2023/04/08/信息系统安全/Chap.8 Transient Execution/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.7%20High%20Level%20Programming/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.9%20Denial%20of%20Service/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#transient-execution"><span class="nav-number">1.</span> <span class="nav-text">Transient Execution</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cpu"><span class="nav-number">1.1.</span> <span class="nav-text">CPU</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#out-of-order"><span class="nav-number">1.1.1.</span> <span class="nav-text">Out-of-Order</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#skylake-block-diagram"><span class="nav-number">1.1.2.</span> <span class="nav-text">Skylake Block Diagram</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#front-end"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">1. Front End</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#execution-engine"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">2. Execution Engine</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#speculative-execution"><span class="nav-number">1.1.3.</span> <span class="nav-text">Speculative Execution</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#meltdown"><span class="nav-number">1.2.</span> <span class="nav-text">Meltdown</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bypass-page-property-check"><span class="nav-number">1.2.1.</span> <span class="nav-text">Bypass page property check</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#meltdown-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">Meltdown</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#another-thread"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Another Thread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memory-access-granularity"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">Memory Access Granularity</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defense-meltdown"><span class="nav-number">1.2.3.</span> <span class="nav-text">Defense-Meltdown</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kernel-page-table-isolation"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">Kernel page-table isolation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#consequence"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">Consequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defense-from-intel-linux"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">Defense from Intel, Linux</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spectre"><span class="nav-number">1.3.</span> <span class="nav-text">Spectre</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#branch-prediction"><span class="nav-number">1.3.1.</span> <span class="nav-text">Branch Prediction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#what-if-indirect-branch"><span class="nav-number">1.3.2.</span> <span class="nav-text">What if Indirect Branch?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spectre-1"><span class="nav-number">1.3.3.</span> <span class="nav-text">Spectre</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fengshui---delay-execution"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">Fengshui - Delay execution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#isolate-cache-lines"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">Isolate cache lines</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defense-process-based-isolation"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">Defense-Process Based
Isolation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defense-blur-timming"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">Defense-Blur Timming</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spectre-variant"><span class="nav-number">1.3.4.</span> <span class="nav-text">Spectre Variant</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extend"><span class="nav-number">1.4.</span> <span class="nav-text">Extend</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile"><span class="nav-number">1.4.1.</span> <span class="nav-text">Volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">volatile 的含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84-volatile"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">程序中的 volatile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-volatile-%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">关键字 volatile 的含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">volatile 与多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#case"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">Case</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#na%C3%AFve-case"><span class="nav-number">1.4.1.5.1.</span> <span class="nav-text">1. naïve case</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E4%B8%80%E4%B8%AA-volatile-%E8%AF%95%E8%AF%95"><span class="nav-number">1.4.1.5.2.</span> <span class="nav-text">2. 加一个 volatile 试试？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%8D%E5%8A%A0%E4%B8%80%E4%B8%AA-volatile-%E5%91%A2"><span class="nav-number">1.4.1.5.3.</span> <span class="nav-text">3. 再加一个 volatile 呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%B0%E5%BA%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A"><span class="nav-number">1.4.1.5.4.</span> <span class="nav-text">4. 到底应该怎么做？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">1.4.1.6.</span> <span class="nav-text">参考资料</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-catch"><span class="nav-number">1.4.2.</span> <span class="nav-text">try … catch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#try-catch-in-c"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">1. try … catch in C</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-1"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="自是水长东"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">自是水长东</p>
  <div class="site-description" itemprop="description">Medicine, law, business, engineering: these are noble pursuits and necessary to sustain life. But poetry, beauty, romance, love... these are what we stay alive for.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=27483202&auto=1&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<!-- 访客数和访问量的设置 -->
<div class="busuanzi-count">
  <script async="" src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js";></script>

  <span class="site-uv">
  <i class="fa fa-user"> 本站访客数</i>
  <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
  人
  </span>

  <span class="site-pv">
  <i class="fa fa-eye"> 本站总访问量</i>
  <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
  次
  </span>

</div>

 <!-- 网站运行时间的设置 -->
    <span id="timeDate">载入天数...</span>
    <span id="times">载入时分秒...</span>  Sometimes your whole life boils down to one insane move.
    <script>
        var now = new Date();
        function createtime() {
            var grt= new Date("09/01/2021 00:00:00");//此处修改你的建站时间或者网站上线时间
            now.setTime(now.getTime()+250);
            days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
            hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
            if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
            mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
            seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
            snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
            document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
            document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()",250);
    </script><script color="255,105,180" 
 opacity="0.5" 
 zIndex="-1" 
 count="150" 
 src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js">
 </script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
