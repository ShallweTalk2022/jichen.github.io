<!DOCTYPE html>
<html lang="zh-Hans">
<head>

<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>

  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Zhi Mang Xing:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":false,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="High Level Programming Motivation Why do programmers prefer high level language?  +No need to care memory. Java: GC C++: Smart Pointer +Built-in Advanced Data Structure Python: Dict, List, Set">
<meta property="og:type" content="article">
<meta property="og:title" content="寄尘&#39;s Blog">
<meta property="og:url" content="http://example.com/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.7%20High%20Level%20Programming/index.html">
<meta property="og:site_name" content="寄尘&#39;s Blog">
<meta property="og:description" content="High Level Programming Motivation Why do programmers prefer high level language?  +No need to care memory. Java: GC C++: Smart Pointer +Built-in Advanced Data Structure Python: Dict, List, Set">
<meta property="og:locale">
<meta property="og:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/image-20221031184026748.png">
<meta property="og:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/image-20221031185648166.png">
<meta property="og:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/image-20221031190507507.png">
<meta property="og:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/image-20221031202422291.png">
<meta property="article:published_time" content="2023-04-08T15:31:20.530Z">
<meta property="article:modified_time" content="2023-02-21T13:44:48.908Z">
<meta property="article:author" content="自是水长东">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/All%20Documents/Markdown/MD杂项/MD.IMG/image-20221031184026748.png">

<link rel="canonical" href="http://example.com/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.7%20High%20Level%20Programming/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title> | 寄尘's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>



<body itemscope itemtype="http://schema.org/WebPage">

<!-- <script src="/live2d/autoload.js"></script> --> <!-- 这条语句和live2d看板娘有关，去掉注释获得看板娘 -->

  <div class="container use-motion">
    <div class="headband"></div>

    <a target="_blank" rel="noopener" href="https://github.com/jichen2002" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">寄尘's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">人生寄一世，奄忽若飙尘</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.7%20High%20Level%20Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="自是水长东">
      <meta itemprop="description" content="Medicine, law, business, engineering: these are noble pursuits and necessary to sustain life. But poetry, beauty, romance, love... these are what we stay alive for.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="寄尘's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-08 23:31:20" itemprop="dateCreated datePublished" datetime="2023-04-08T23:31:20+08:00">2023-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-21 21:44:48" itemprop="dateModified" datetime="2023-02-21T21:44:48+08:00">2023-02-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="high-level-programming">High Level Programming</h1>
<h2 id="motivation">Motivation</h2>
<p>Why do programmers prefer high level language?</p>
<ul>
<li><p>+No need to care memory.</p>
<p>Java: GC</p>
<p>C++: Smart Pointer</p></li>
<li><p>+Built-in Advanced Data Structure</p>
<p>Python: Dict, List, Set</p>
<p>Java, C++: String</p></li>
<li><p>-Less static check</p>
<p>Python syntax check at runtime</p></li>
<li><p>~More Syntax Candy</p>
<p>:?, lambda</p>
<p>Exception</p></li>
</ul>
<p><strong>==扩展==</strong>：C++ 中的 vector 实现</p>
<p>C++ 中 vector 的实现为 vector
的数据量（size）大于其已申请的内存容量（capacity）时，其会再申请当前空间的一倍，这个申请的开销很大不可忽略，因此分析
vector 的复杂度时需要使用摊还分析（Amortized Analysis，均摊分析）</p>
<p>vector 的 <code>push_back()</code> 操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;data[size++] = data</span><br></pre></td></tr></table></figure>
<p>复杂度为 <span class="math inline">\(O(1)\)</span></p>
<p>当 <code>size = capacity</code> 时扩容操作会申请
<code>2 * capacity * sizeof(Type)</code> 大小的空间，并将此时 vector
内的所有数据复制过去，复杂度为 <span
class="math inline">\(O(n)\)</span>（设 capacity 为 <span
class="math inline">\(n\)</span>），那么从 <span
class="math inline">\(n/2\)</span> 到 <span
class="math inline">\(n\)</span> 的插入操作的复杂度就是 <span
class="math display">\[
O(1) +O(\frac{n}{n-n/2})=O(3)=O(1)
\]</span> 显然除了刚创建 vector 后的第一个操作 <code>push_back()</code>
为 <span class="math inline">\(O(2)\)</span> 以外其余复杂度都为 <span
class="math inline">\(O(3)\)</span>。即所有复杂度均为 <span
class="math inline">\(O(1)\)</span> 常数级别</p>
<p>vector 的 <code>pop_back()</code> 操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;data[size--] = data</span><br></pre></td></tr></table></figure>
<p>复杂度为 <span class="math inline">\(O(1)\)</span></p>
<p>然而对于 vector 的缩容操作就不能当 <code>size = capacity/2</code>
时进行了，否则可能导致复杂度震荡的问题：</p>
<p>在此情况下释放空间（复杂度 <span
class="math inline">\(O(n)\)</span>）后会出现
<code>size = capacity</code> 的情况。若 vector 的下个操作是
<code>push_back()</code> 则显然 vector
的容量再次不足，又需要扩容（复杂度为 <span
class="math inline">\(O(n)\)</span>）。这会导致若程序在此阈值附近进行大量
<code>push_back(), pop_back()</code> 操作，则每次操作的复杂度都为 <span
class="math inline">\(O(n)\)</span>，效率低下</p>
<p>因此 vector 的缩容操作应该等到 <code>size = capacity/4</code>
时再进行（此时申请 <span class="math inline">\(n/2\)</span> 的空间，并将
vector 中的数据复制过去）</p>
<h2 id="memory-safety">Memory Safety</h2>
<h3 id="c-c-memory-management-philosophy">C, C++ Memory Management
Philosophy</h3>
<ul>
<li>Developers explicitly invoke malloc/free new/delete</li>
<li>Very little overhead
<ul>
<li>free list</li>
<li><span class="math inline">\(O(1)\)</span> service time</li>
<li>No background activity</li>
<li>No runtime overhead</li>
</ul></li>
<li>Prone to bugs
<ul>
<li>use after free, double free, overflow…</li>
<li>Because the difficulty of handling memory for developers</li>
</ul></li>
</ul>
<h3 id="java-mm-philosophy">Java MM Philosophy</h3>
<ul>
<li><p>Developers do not need to take care of object lifetime</p>
<ul>
<li><p>Only explicitly new objects, no need to delete</p>
<p>只需显式申请，无需显式释放</p></li>
<li><p>No need to care about boundaries（Java
进行内存访问操作时会自动做边界检查）</p></li>
</ul></li>
<li><p>Background thread recycles memory for developers</p>
<p>Java 程序在运行时需要 runtime（运行时系统），即 JVM，而 JVM
本身也有自己的背景线程来执行内存管理（Memory
Management）。因此即使程序员编写的 Java
程序是一个单线程程序，在运行时也会是多线程运行的</p>
<p>JVM 的内存管理帮助程序员进行内存回收，但同时也存在以下缺点：</p>
<ul>
<li><p>Introduces overhead</p>
<p>内存管理本身需要需要执行更多代码并且加入更多的数据结构，因此引入更大的开销</p></li>
<li><p>Uneven request latency</p>
<p>不均匀请求延时。如对于一个服务器程序，假设一次响应请求的过程为收包（receive）、处理（process）、发包（send），那么这段时间通常是较为固定的。但使用
Java 编写的程序运行在 JVM 上，而 JVM
有时会打断程序开始执行内存回收，如果该行为发生在响应请求的过程中，则会导致该响应请求的延迟远高于正常的响应请求的过程</p></li>
</ul></li>
<li><p>Runtime VM checks boundaries for developers</p>
<ul>
<li><p>Slow down memory access</p>
<p>边界检查有时是不必要的</p></li>
</ul></li>
<li><p>Trade performance for safety</p>
<p>Java 的策略本质上是以效率换取安全的做法</p></li>
</ul>
<h2 id="java-garbage-collection">Java Garbage Collection</h2>
<ul>
<li><p>Memory should be recycled automatically</p>
<ul>
<li><p>To save memory</p></li>
<li><p>To avoid fragmentation</p></li>
</ul></li>
<li><p>Constraint</p>
<ul>
<li><p>JVM does not know which objects can be recycled.</p></li>
<li><p>For C/C++, developers invoke free/delete</p>
<p>对于 C/C++
而言，其堆管理器不会通过移动正在使用内存块的方式来优化内存碎片；并且在如下情况下：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221031184026748.png" alt="image-20221031184026748" style="zoom:80%;" /></p>
<p>即使堆顶处只有 <span class="math inline">\(1\)</span> 个 Byte
的内存块在使用，而其下的所有空间都是空闲的，C/C++
也不会移动该内存块到堆底以调用 <code>brk()</code>
释放堆顶的内存。这是因为 C/C++ 的地址是可以被显式使用的，但 C/C++
并不提供主动去修改它的功能，因此若移动内存块会导致指向该内存的指针的值变为错误的，从而可能导致很多内存错误</p></li>
</ul></li>
<li><p>How?</p>
<ul>
<li>Discovery of unreachable objects（发现不可达的对象）</li>
<li>Regard unreachable objects as free-able（裁定它们是可以被 free
的）</li>
<li>Stop the world to tidy memory（将 Java
程序所有线程停下后开始整理内存）</li>
</ul></li>
</ul>
<h3 id="high-level-idea-of-ref-count-based-gc">High level idea of ref
count based GC</h3>
<ul>
<li><p>Maintain reference counter of objects.</p>
<ul>
<li><p>Object can only be possibly recycled when no pointer
references.</p></li>
<li><p>So, instrumenting reference change, and maintain a reference
counter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A(); <span class="comment">// &lt;-ref_cnt0, ref_cnt0++</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Nulling a reference (--)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">null</span>; <span class="comment">// ref_cnt0--</span></span><br></pre></td></tr></table></figure></li>
<li><p>Reassigning a reference variable (--, ++)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A b = <span class="keyword">new</span> A(); <span class="comment">// &lt;-ref_cnt1++</span></span><br><span class="line">a = b          <span class="comment">// ref_cnt0--, ref_cnt1++</span></span><br></pre></td></tr></table></figure></li>
<li><p>Reference leaves its scope (--)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unknown</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A c = <span class="keyword">new</span> A() <span class="comment">// ref_cnt2++</span></span><br><span class="line">    g.b = a       <span class="comment">// ref_cnt2++</span></span><br><span class="line">&#125;                 <span class="comment">// ref_cnt2--</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>Stop the world to recycle zero-ref objects</p>
<p>Why stop the world (all threads)?</p></li>
<li><p>How about object array?</p></li>
</ul>
<p>注意：</p>
<ul>
<li><p>当某个对象的 <code>ref_cnt = 0</code>
时，它并不马上被删除，而是等待 JVM 在某个时间节点下开启 GC
后才对其进行处理</p></li>
<li><p>对于对象数组，其每个对象都会产生一个引用计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A[<span class="number">10</span>] <span class="comment">// &lt;-ref_cnt0-9，ref_cnt0-9++</span></span><br><span class="line">b=a[<span class="number">5</span>]          <span class="comment">// ref_cnt5++</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="reference-count-based-gc">Reference Count based GC</h3>
<ul>
<li><p>Does zero reference equal to unreachable?</p>
<ul>
<li>If <span class="math inline">\(0\)</span> ref, the object must be
unreachable.</li>
<li>But not all unreachable objects have zero ref-count.</li>
</ul></li>
<li><p>Isolation Island Issue</p>
<ul>
<li>A pair of objects refence each other</li>
<li>So the reference count is not zero, but not reachable.</li>
<li>Reference count alone cannot recognize all free objects</li>
</ul>
<p>例如循环链表：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221031185648166.png" alt="image-20221031185648166" style="zoom:80%;" /></p>
<p>因此 Java 实际上并不使用引用计数的方法来进行内存回收</p></li>
</ul>
<h3 id="reachability-test-based-gc">Reachability Test based GC</h3>
<ul>
<li><p>Stop the world</p>
<p>So reference relationship does not change during GC</p></li>
<li><p>Test if an object is still reachable</p>
<ul>
<li><p>An object is reachable if only it is reachable from the GC
root</p></li>
<li><p>What is GC root?</p>
<p>GC root 是程序一定可达的内存部分，以下几种内存是一定可达的：</p>
<ul>
<li><p>Local objects of functions in call stack</p>
<p>调用栈中的局部变量</p></li>
<li><p>Static variables</p>
<p>静态变量的生命周期一定是贯穿整个程序运行时间的</p></li>
<li><p>Constants</p></li>
<li><p>JNI（Java Native Interface）</p>
<p>Java 调用 C/C++ 等语言写的程序的入口</p></li>
</ul></li>
</ul>
<p>其检测方法实质使用的是深搜（DFS）的方法：</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221031190507507.png" alt="image-20221031190507507" style="zoom:80%;" /></p></li>
</ul>
<h2 id="gc-implementation">GC implementation</h2>
<ul>
<li><p>Mark &amp; Free：Just free the unreachable objects</p>
<p>解决内存回收：将所有不可达对象的内存清除</p></li>
<li><p>Copy：Copy all reachable objects to new heap</p>
<p>解决内存回收以及碎片化问题：将所有存活对象复制到新的内存块，原内存块全部释放</p></li>
<li><p>Mark &amp; Tidy：Free unreachable objects and defragmentation</p>
<p>解决内存回收以及碎片化问题：释放所有不可达的的对象，并将存活对象向堆底移动</p></li>
</ul>
<h3 id="java-heap-zones">Java Heap Zones</h3>
<ul>
<li><p>Eden</p>
<ul>
<li>New objects, i.e., created after last GC</li>
<li>Over 98% objects are ephemeral (will be recycled in the next GC), so
GC can recycle most of the objects in Eden zone.</li>
<li>Young GC: directly clear the zone and move remained objects to
survivor.</li>
</ul>
<p>概率模型表示通常在上一次 GC 和本次 GC
之间被创建的对象（称之为新生代）有 <span
class="math inline">\(98\)</span>% 的概率不可达从而被回收，因此 JVM
会将这 <span class="math inline">\(98\)</span>% 的内存回收，并将剩余
<span class="math inline">\(2\)</span>% 的存活对象移动到
Survivor（称之为中生代）区域</p></li>
<li><p>Survivor</p>
<ul>
<li>Objects survived from a young GC, i.e., the <span
class="math inline">\(2\)</span>% objects.</li>
<li>Split to “From” and “To” zones, to avoid fragmentation</li>
</ul>
<p>中生代区域的对象不会在每次 GC 中都被检查和清理，而是 <span
class="math inline">\(n\)</span> 次 GC
才会有一次同时对中生代对象进行检查和清理，若未被清理则拷贝至老生代区域</p></li>
<li><p>Old</p>
<ul>
<li>Moved from survivor, when the objects experienced many GC.</li>
</ul>
<p>同上，老生代区域被检查和清理的频率更加低，它们有很大的概率永远存活下去（直至进程结束）</p></li>
</ul>
<h2 id="java-gc-pros-cons">Java GC Pros &amp; Cons</h2>
<ul>
<li><p>Pros</p>
<ul>
<li><p>Totally transparent to developers</p></li>
<li><p>Strong memory safety guarantee</p>
<p>JVM developers are less prone to forget memory recycle</p></li>
<li><p>==Sometimes better performance==</p>
<p>==Objects are not recycled immediately, and may be delayed to spare
time for GC.==</p></li>
</ul></li>
<li><p>Cons</p>
<ul>
<li><p>Object copy overhead</p></li>
<li><p>Larger memory usage</p>
<p>extra data structure for counter. Delayed object recycle etc.</p>
<p>JVM（使用 C/C++ 编写）管理内存时，由于 Java 只有引用没有指针，并且
JVM
要实现拷贝内存来解决碎片化问题就要求为每个对象建立一个引用到指针的映射，即
<code>map&lt;ref, pointer&gt;</code>。那么 JVM 在进行内存整理时只需要将
<code>pointer</code>
修改即可保证程序线程重启之后引用访问内存的正确性了</p></li>
<li><p>Stop the world increases tail latency</p>
<ul>
<li><p>如何不 stop world 也能执行 GC？</p>
<p>对 <code>map&lt;&gt;</code> 加锁即可，但开销会比 GC
来得大，因此只在不能 stop world 的业务要求下使用</p></li>
<li><p>什么时候不能 stop world？</p>
<p>即对延时敏感的情况，如某个业务要求延迟不能超过 <span
class="math inline">\(10\)</span>ms，那么此时可能就不能使用 stop
world，因此 stop world
检查和清理所有内存空间的时间会比对一个内存块加锁检查的时间多得多</p></li>
</ul></li>
</ul></li>
</ul>
<h3 id="gc-misc">GC misc</h3>
<ul>
<li><p>Implicitly notify JVM to GC</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>将引用置为 <code>null</code> 可以显式通知 JVM 其所引用的对象需要被
GC。当然，此时不会马上开启 GC，但能够降低 GC 搜索难度</p></li>
<li><p>Explicitly Notification to JVMSystem.gc()</p>
<p>调用该函数能够立刻发起 JVM 执行 GC，适用于</p>
<ul>
<li>负载不均衡的场景以利用空闲时间 GC</li>
<li>在大块内存使用完毕后调用以减少内存的占用</li>
</ul></li>
<li><p>When to call destructor?</p>
<ul>
<li><p>On C++, when an object leaves its scope, or when it is
deleted</p>
<p>C++ 调用析构函数：</p>
<ul>
<li>delete（使用 <code>new</code>
在堆上开辟空间的对象：<code>A a = new A()</code>）</li>
<li>退出作用域（在栈上的对象：<code>A a = A()</code>）</li>
</ul></li>
<li><p>How about Java?</p>
<p>Java 只有在 GC
时才会调用析构函数，但有可能永远不调用析构函数（直到退出程序时），因此
Java 析构函数的调用无法预测</p></li>
</ul></li>
</ul>
<h2 id="raii-resource-acquisition-is-initialization">RAII (Resource
Acquisition Is Initialization)</h2>
<ul>
<li>Resource Acquisition Is Initialization
<ul>
<li><p>Compiler automatically recycles local variables.</p>
<p>编译器自动回收局部变量</p></li>
<li><p>So let the lifetime of objects tied with local variables</p>
<p>对象的生命期与局部变量绑定</p></li>
<li><p>Resources are released when local variables leaves it scope.</p>
<p>当局部变量离开作用域时，其资源将被释放</p></li>
</ul></li>
<li>C++ philosophy of automatic memory recycle
<ul>
<li>Basic C++ provide freedom for developers to maintain memory</li>
<li>But it is buggy prone</li>
<li>Smart pointer (RAII) helps developers automatically free
objects</li>
</ul></li>
</ul>
<h3 id="raii-naive-usage">RAII Naive Usage</h3>
<ul>
<li><p>Use local variables Only</p>
<p>So all objects can be recycled automatically</p>
<p>When adding RSP.</p></li>
<li><p>How to deal with returning object pointer (dangling pointer)?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">P* <span class="title">func</span><span class="params">()</span></span>&#123;P* p = <span class="keyword">new</span> P; <span class="keyword">return</span> p;&#125;</span><br></pre></td></tr></table></figure>
<p>Maybe caller should prepare the memory and deliver the pointer via
args.</p>
<p>因此可能会写出这种程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">P* <span class="title">func</span><span class="params">()</span></span>&#123;P p = P; <span class="keyword">return</span> &amp;p;&#125;</span><br></pre></td></tr></table></figure>
<p>但当 <code>func()</code> 函数结束后，<code>p</code>
在栈上的空间将会被释放，<code>&amp;p</code> 就是一个悬空指针（dangling
pointer）</p></li>
<li><p>How to deal with multi-thread?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P* p = <span class="keyword">new</span> P; </span><br><span class="line">    Thread* t = <span class="keyword">new</span> Thread(p);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>编译器是不感知多线程的，多线程使用库实现，但编译器不会认为调用一个
<code>pthread</code> 函数和调用其它函数有什么区别</p></li>
</ul>
<h3 id="raii-smart-pointer">RAII –Smart Pointer</h3>
<ul>
<li><p>Encapsulate a pointer in an local object.</p>
<p>将指针封装在局部对象中</p>
<ul>
<li><p>Developers no longer use normal pointers</p>
<p>开发者不再使用普通指针</p></li>
</ul></li>
<li><p>The lifetime of the local object is managed by compilers.</p>
<p>因此该局部对象就由编译器来管理</p>
<ul>
<li>The constructor and destructor of local object is automatically
called when the object leaves its scope.</li>
</ul></li>
<li><p>Use destructor to recycle memory for developers</p>
<ul>
<li>Only the smart pointer developers need to remember to release
memory</li>
<li>Normal developers do not need to care memory recycle</li>
</ul></li>
</ul>
<p>该方法的本质是利用类局部变量在退出作用域时会自动调用析构函数来自动实现管理堆上对象的生命周期</p>
<h3 id="c-smart-pointer">C++ Smart Pointer</h3>
<p>An example of self made smart pointer:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *ptr; <span class="comment">// Actual pointer</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(<span class="keyword">int</span> *p = <span class="literal">NULL</span>)</span></span>&#123; ptr = p;&#125;</span><br><span class="line">     <span class="comment">// Destructor</span></span><br><span class="line">    ~Smartptr() &#123; <span class="keyword">delete</span> (ptr); &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Overloading dereferencing operator</span></span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *ptr;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">SmartPtr <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>())</span></span>;</span><br><span class="line">    *ptr = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ptr is automatically released by destructor</li>
<li>main developers do not need to care about delete</li>
</ul>
<p>可以使用模板类方法将该智能指针类应用到所有数据类型上</p>
<p>STD 标准库提供了 Smart Pointer 类：</p>
<ul>
<li><p>unique_ptr</p>
<ul>
<li>If a unique pointer P1 is pointing to an object, only one pointer
can point this object at one time.</li>
<li>So we can’t share the object with another pointer, but we can
transfer the control to P2 by moving from P1.</li>
</ul></li>
<li><p>shared_ptr</p>
<ul>
<li>If you are using shared_ptr, then more than one pointer can point to
one object at a time</li>
<li>For each object, it maintains a Reference Counter</li>
<li>Recycle memory only when the counter is zero.</li>
</ul>
<p>然而 <code>shared_ptr</code> 无法解决循环岛问题</p></li>
<li><p>weak_ptr</p>
<ul>
<li><p>It’s much more similar to shared_ptr except it’ll not maintain a
Reference Counter.</p></li>
<li><p>So a weak_ptr may be dangling. Developers can check the validity
of a pointer by calling expired()</p>
<p>但 <code>expired()</code> 会存在线程不安全的问题，存在 TOUTTOC
问题</p></li>
</ul></li>
</ul>
<p>智能指针举例：</p>
<ul>
<li><p>unique_ptr：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;Rectangle&gt; <span class="title">P1</span><span class="params">(<span class="keyword">new</span> Rectangle(<span class="number">10</span>,<span class="number">5</span>))</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; P1-&gt;area() &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//This&#x27;ll print 50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr&lt;Rectangle&gt;P2(P1);</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Rectangle&gt; P2; </span><br><span class="line">    P2 = move(P1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This&#x27;ll print 50</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; P2-&gt;area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout&lt;&lt;P1-&gt;area()&lt;&lt;end1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>move</code> 即为将 <code>P1</code> 所指对象交给
<code>P2</code>，并销毁 <code>P1</code></p></li>
<li><p>shared_ptr：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Rectangle&gt; <span class="title">P1</span><span class="params">(<span class="keyword">new</span> Rectangle(<span class="number">10</span>,<span class="number">5</span>))</span></span>;</span><br><span class="line">    <span class="comment">//This&#x27;11 print 50</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; P1-&gt;area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    shared ptr&lt;Rectangle&gt; P2;</span><br><span class="line">    P2=P1; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// This&#x27;ll print 50</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;P2-&gt;area()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This&#x27;ll now not give an error,</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; P1-&gt;area() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// This&#x27;1l also print 50 now</span></span><br><span class="line">    <span class="comment">// This&#x27;ll print 2 as Reference Counter is 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; P1.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 <code>shared_ptr</code> 重载了 <code>=</code> 运算符，可以将
<code>P1</code> 指向的对象赋给 <code>P2</code></p></li>
</ul>
<h2 id="raii-based-memory-management-by-default">RAII based memory
management by default</h2>
<ul>
<li><p>RUST</p>
<p>Rust achieves memory safety without garbage collection.</p>
<p>rust 语言实现的实质就是使用智能指针</p></li>
<li><p>Ownership</p>
<ul>
<li>Each heap object in Rust has a variable that’s called its
owner.</li>
<li><strong>There can only be one owner at a time.</strong></li>
<li>When the owner goes out of scope, the value will be dropped
(deleted).</li>
</ul></li>
<li><p>Ownership Borrowing</p>
<ul>
<li>Borrow checker</li>
<li>You can have only one mutable reference to a particular piece of
data in a particular scope, i.e., no shared pointer.</li>
<li>Whenever a mutable borrow is active, no other borrows of the object
are active</li>
</ul>
<p>mutable 是可写的借用；而 inmutable 是只读的借用，正如 C/C++
<code>strcpy()</code> 函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcpy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> src)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中 <code>const char* const</code> 前一个 const
表示指针的值只读；后一个 const 表示指针指向内存的数据只读</p></li>
</ul>
<p>具体例子：</p>
<ul>
<li><p>A reference cannot be moved to another, once it loses
ownership:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br></pre></td></tr></table></figure>
<p>此时会报错，因为在执行 <code>let s2 = s1</code> 后 <code>s1</code>
的对象的所有权已经被转移给 <code>s2</code></p>
<p>以下为正确的写法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.clone();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br></pre></td></tr></table></figure>
<p>此时程序将会在内存中克隆一个完全一样的 <code>s1</code> 将其赋值给
<code>s2</code></p></li>
<li><p>Callee can borrow the ownership, by using &amp;</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> len = calculate_lenth(&amp;s1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.!&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_lenth</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>s: &amp;String</code> 中 &amp; 表示借用；若不加 &amp; 则表示
<code>move</code></p>
<p>Return ownership when calls return</p></li>
<li><p>When mutable borrowing is active, no other borrow can be
active</p>
<p>==Single mutable reference==，如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">push_all</span></span>(from: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;, to: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;)&#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> from.iter()&#123;</span><br><span class="line">        to.push(*i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    push_all(&amp;vec, &amp;<span class="keyword">mut</span> vec);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中，<code>&amp;</code> 为 immutable 的借用；<code>&amp;mut</code>
为 mutable 的借用</p>
<p>由于一个作用域中存在 mutable
的借用时就只能存在一个借用，因此上述代码会报错</p>
<p>由于该机制导致共享内存（共享内存必须可读可写）在 rust
中实现不了，因此 rust 引入了 unsafe
的机制来关闭以上特性以实现内存共享</p></li>
</ul>
<h2 id="language-based-access-control">Language Based access
control</h2>
<ul>
<li><p>Restrict developers from accessing variables or
functions</p></li>
<li><p>Private/Public /Protected C++ inheritance.</p>
<ul>
<li>Only public variables and functions are exposed to class users.</li>
<li>Only functions inside a class can access the private variables.</li>
<li>Protected inheritance</li>
</ul>
<p>成员访问权限：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Same class</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr class="even">
<td>Derived classes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr class="odd">
<td>Outside classes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>继承方式：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>公有继承</td>
<td>public</td>
<td>protected</td>
<td>不可见</td>
</tr>
<tr class="even">
<td>私有继承</td>
<td>private</td>
<td>private</td>
<td>不可见</td>
</tr>
<tr class="odd">
<td>保护继承</td>
<td>protected</td>
<td>protected</td>
<td>不可见</td>
</tr>
</tbody>
</table></li>
</ul>
<p>其中继承方式详解为：</p>
<p>公有继承（public）、私有继承（private）、保护继承（protected）是常用的三种继承方式。　　</p>
<ul>
<li><p>公有继承（public）</p>
<p>公有继承的特点是<a
target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=基类&amp;spm=1001.2101.3001.7020">基类</a>的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。　　</p></li>
<li><p>私有继承（private）：默认的继承方式（如果缺省，默认为 private
继承）</p>
<p>私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。子类也不能转换成相应的基类，如果转换，会报错：“不允许对不可访问的基类进行转换”</p></li>
<li><p>保护继承（protected）</p>
<p>保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的</p></li>
</ul>
<h3 id="bypass-language-based-access-control">Bypass language based
access control</h3>
<ul>
<li><p>For C++</p>
<ul>
<li><p>Use pointer to access the private variables and function.</p>
<p>即将类指针强制类型转换为 <code>void*</code>
类型即可通过指针加减法访问类的所有成员</p></li>
<li><p>Notice the this argument of member functions</p>
<p>通过某种方法得到 <code>this</code>
指针也可以访问类的所有成员</p></li>
</ul></li>
<li><p>For Java</p>
<ul>
<li>Use reflection to access（反射技术）</li>
</ul></li>
</ul>
<h2 id="dimensions-levels-of-safety">Dimensions &amp; levels of
safety</h2>
<ul>
<li><p>There are many dimensions of safety</p>
<p>memory-safety, type-safety, thread-safety, arithmetic safety,
guarantees about (non)nullness, about immutability, about the absence of
aliasing,...</p>
<p>thread-safety：如 Javascript，为了实现线程安全，其 runtime
是单线程的</p>
<p>absence of aliasing：禁止别名对程序分析有好处</p></li>
<li><p>For some dimensions, there can be many levels of safety</p>
<p><img src="D:\All Documents\Markdown\MD杂项\MD.IMG\image-20221031202422291.png" alt="image-20221031202422291" style="zoom:80%;" /></p></li>
</ul>
<p><strong>扩展：</strong>eBPF</p>
<p>eBPF（extended Berkeley Packet Filter）是一种可以在 Linux
内核中运行用户编写的程序，而不需要修改内核代码或加载内核模块的技术，其让
Linux 内核变得可编程化了。eBPF 程序采用 C 语言编写，并可以通过 clang
编译成目标文件 —— eBPF 字节码。对于程序而言 eBPF
相当于虚拟机，其会通过验证器验证要嵌入内核的程序，确保其不会导致内核崩溃或无限执行下去等</p>
<p>例如 wireshark 应用的编写就利用了 eBPF。wireshark
可以抓取所有网络中的包，但一个非特权程序显然是不允许抓取所有的包的，而只能开一个
socket 进行收发包的操作</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>自是水长东
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.7%20High%20Level%20Programming/" title="">http://example.com/2023/04/08/信息系统安全/Chap.7 High Level Programming/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.5%20Sandboxing/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/08/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/Chap.8%20Transient%20Execution/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#high-level-programming"><span class="nav-number">1.</span> <span class="nav-text">High Level Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#motivation"><span class="nav-number">1.1.</span> <span class="nav-text">Motivation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memory-safety"><span class="nav-number">1.2.</span> <span class="nav-text">Memory Safety</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c-c-memory-management-philosophy"><span class="nav-number">1.2.1.</span> <span class="nav-text">C, C++ Memory Management
Philosophy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-mm-philosophy"><span class="nav-number">1.2.2.</span> <span class="nav-text">Java MM Philosophy</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-garbage-collection"><span class="nav-number">1.3.</span> <span class="nav-text">Java Garbage Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#high-level-idea-of-ref-count-based-gc"><span class="nav-number">1.3.1.</span> <span class="nav-text">High level idea of ref
count based GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reference-count-based-gc"><span class="nav-number">1.3.2.</span> <span class="nav-text">Reference Count based GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reachability-test-based-gc"><span class="nav-number">1.3.3.</span> <span class="nav-text">Reachability Test based GC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gc-implementation"><span class="nav-number">1.4.</span> <span class="nav-text">GC implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java-heap-zones"><span class="nav-number">1.4.1.</span> <span class="nav-text">Java Heap Zones</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-gc-pros-cons"><span class="nav-number">1.5.</span> <span class="nav-text">Java GC Pros &amp; Cons</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gc-misc"><span class="nav-number">1.5.1.</span> <span class="nav-text">GC misc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#raii-resource-acquisition-is-initialization"><span class="nav-number">1.6.</span> <span class="nav-text">RAII (Resource
Acquisition Is Initialization)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#raii-naive-usage"><span class="nav-number">1.6.1.</span> <span class="nav-text">RAII Naive Usage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#raii-smart-pointer"><span class="nav-number">1.6.2.</span> <span class="nav-text">RAII –Smart Pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-smart-pointer"><span class="nav-number">1.6.3.</span> <span class="nav-text">C++ Smart Pointer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#raii-based-memory-management-by-default"><span class="nav-number">1.7.</span> <span class="nav-text">RAII based memory
management by default</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#language-based-access-control"><span class="nav-number">1.8.</span> <span class="nav-text">Language Based access
control</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bypass-language-based-access-control"><span class="nav-number">1.8.1.</span> <span class="nav-text">Bypass language based
access control</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dimensions-levels-of-safety"><span class="nav-number">1.9.</span> <span class="nav-text">Dimensions &amp; levels of
safety</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="自是水长东"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">自是水长东</p>
  <div class="site-description" itemprop="description">Medicine, law, business, engineering: these are noble pursuits and necessary to sustain life. But poetry, beauty, romance, love... these are what we stay alive for.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=27483202&auto=1&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<!-- 访客数和访问量的设置 -->
<div class="busuanzi-count">
  <script async="" src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js";></script>

  <span class="site-uv">
  <i class="fa fa-user"> 本站访客数</i>
  <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
  人
  </span>

  <span class="site-pv">
  <i class="fa fa-eye"> 本站总访问量</i>
  <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
  次
  </span>

</div>

 <!-- 网站运行时间的设置 -->
    <span id="timeDate">载入天数...</span>
    <span id="times">载入时分秒...</span>  Sometimes your whole life boils down to one insane move.
    <script>
        var now = new Date();
        function createtime() {
            var grt= new Date("09/01/2021 00:00:00");//此处修改你的建站时间或者网站上线时间
            now.setTime(now.getTime()+250);
            days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
            hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
            if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
            mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
            seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
            snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
            document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
            document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()",250);
    </script><script color="255,105,180" 
 opacity="0.5" 
 zIndex="-1" 
 count="150" 
 src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js">
 </script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
